(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const i of o)if(i.type==="childList")for(const r of i.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function n(o){const i={};return o.integrity&&(i.integrity=o.integrity),o.referrerPolicy&&(i.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?i.credentials="include":o.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(o){if(o.ep)return;o.ep=!0;const i=n(o);fetch(o.href,i)}})();function ho(e){const t=Object.create(null);for(const n of e.split(","))t[n]=1;return n=>n in t}const de={},cn=[],pt=()=>{},Gi=()=>!1,hs=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97),fo=e=>e.startsWith("onUpdate:"),Te=Object.assign,po=(e,t)=>{const n=e.indexOf(t);n>-1&&e.splice(n,1)},Ea=Object.prototype.hasOwnProperty,re=(e,t)=>Ea.call(e,t),X=Array.isArray,un=e=>fs(e)==="[object Map]",Xi=e=>fs(e)==="[object Set]",Q=e=>typeof e=="function",_e=e=>typeof e=="string",qt=e=>typeof e=="symbol",ge=e=>e!==null&&typeof e=="object",Yi=e=>(ge(e)||Q(e))&&Q(e.then)&&Q(e.catch),Ji=Object.prototype.toString,fs=e=>Ji.call(e),Ra=e=>fs(e).slice(8,-1),Qi=e=>fs(e)==="[object Object]",go=e=>_e(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,Cn=ho(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),ps=e=>{const t=Object.create(null);return(n=>t[n]||(t[n]=e(n)))},Aa=/-\w/g,Ft=ps(e=>e.replace(Aa,t=>t.slice(1).toUpperCase())),Pa=/\B([A-Z])/g,Vt=ps(e=>e.replace(Pa,"-$1").toLowerCase()),Zi=ps(e=>e.charAt(0).toUpperCase()+e.slice(1)),Rs=ps(e=>e?`on${Zi(e)}`:""),Wt=(e,t)=>!Object.is(e,t),Yn=(e,...t)=>{for(let n=0;n<e.length;n++)e[n](...t)},er=(e,t,n,s=!1)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,writable:s,value:n})},mo=e=>{const t=parseFloat(e);return isNaN(t)?e:t},Ia=e=>{const t=_e(e)?Number(e):NaN;return isNaN(t)?e:t};let Wo;const gs=()=>Wo||(Wo=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function Oe(e){if(X(e)){const t={};for(let n=0;n<e.length;n++){const s=e[n],o=_e(s)?$a(s):Oe(s);if(o)for(const i in o)t[i]=o[i]}return t}else if(_e(e)||ge(e))return e}const Da=/;(?![^(]*\))/g,Na=/:([^]+)/,Ma=/\/\*[^]*?\*\//g;function $a(e){const t={};return e.replace(Ma,"").split(Da).forEach(n=>{if(n){const s=n.split(Na);s.length>1&&(t[s[0].trim()]=s[1].trim())}}),t}function tn(e){let t="";if(_e(e))t=e;else if(X(e))for(let n=0;n<e.length;n++){const s=tn(e[n]);s&&(t+=s+" ")}else if(ge(e))for(const n in e)e[n]&&(t+=n+" ");return t.trim()}const Ba="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",La=ho(Ba);function tr(e){return!!e||e===""}const nr=e=>!!(e&&e.__v_isRef===!0),Be=e=>_e(e)?e:e==null?"":X(e)||ge(e)&&(e.toString===Ji||!Q(e.toString))?nr(e)?Be(e.value):JSON.stringify(e,sr,2):String(e),sr=(e,t)=>nr(t)?sr(e,t.value):un(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((n,[s,o],i)=>(n[As(s,i)+" =>"]=o,n),{})}:Xi(t)?{[`Set(${t.size})`]:[...t.values()].map(n=>As(n))}:qt(t)?As(t):ge(t)&&!X(t)&&!Qi(t)?String(t):t,As=(e,t="")=>{var n;return qt(e)?`Symbol(${(n=e.description)!=null?n:t})`:e};let je;class Oa{constructor(t=!1){this.detached=t,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=je,!t&&je&&(this.index=(je.scopes||(je.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].pause();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].resume();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].resume()}}run(t){if(this._active){const n=je;try{return je=this,t()}finally{je=n}}}on(){++this._on===1&&(this.prevScope=je,je=this)}off(){this._on>0&&--this._on===0&&(je=this.prevScope,this.prevScope=void 0)}stop(t){if(this._active){this._active=!1;let n,s;for(n=0,s=this.effects.length;n<s;n++)this.effects[n].stop();for(this.effects.length=0,n=0,s=this.cleanups.length;n<s;n++)this.cleanups[n]();if(this.cleanups.length=0,this.scopes){for(n=0,s=this.scopes.length;n<s;n++)this.scopes[n].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!t){const o=this.parent.scopes.pop();o&&o!==this&&(this.parent.scopes[this.index]=o,o.index=this.index)}this.parent=void 0}}}function Wa(){return je}let fe;const Ps=new WeakSet;class or{constructor(t){this.fn=t,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,je&&je.active&&je.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,Ps.has(this)&&(Ps.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||rr(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,Fo(this),ar(this);const t=fe,n=st;fe=this,st=!0;try{return this.fn()}finally{lr(this),fe=t,st=n,this.flags&=-3}}stop(){if(this.flags&1){for(let t=this.deps;t;t=t.nextDep)yo(t);this.deps=this.depsTail=void 0,Fo(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?Ps.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){Ks(this)&&this.run()}get dirty(){return Ks(this)}}let ir=0,Sn,kn;function rr(e,t=!1){if(e.flags|=8,t){e.next=kn,kn=e;return}e.next=Sn,Sn=e}function vo(){ir++}function bo(){if(--ir>0)return;if(kn){let t=kn;for(kn=void 0;t;){const n=t.next;t.next=void 0,t.flags&=-9,t=n}}let e;for(;Sn;){let t=Sn;for(Sn=void 0;t;){const n=t.next;if(t.next=void 0,t.flags&=-9,t.flags&1)try{t.trigger()}catch(s){e||(e=s)}t=n}}if(e)throw e}function ar(e){for(let t=e.deps;t;t=t.nextDep)t.version=-1,t.prevActiveLink=t.dep.activeLink,t.dep.activeLink=t}function lr(e){let t,n=e.depsTail,s=n;for(;s;){const o=s.prevDep;s.version===-1?(s===n&&(n=o),yo(s),Fa(s)):t=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=o}e.deps=t,e.depsTail=n}function Ks(e){for(let t=e.deps;t;t=t.nextDep)if(t.dep.version!==t.version||t.dep.computed&&(cr(t.dep.computed)||t.dep.version!==t.version))return!0;return!!e._dirty}function cr(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===Dn)||(e.globalVersion=Dn,!e.isSSR&&e.flags&128&&(!e.deps&&!e._dirty||!Ks(e))))return;e.flags|=2;const t=e.dep,n=fe,s=st;fe=e,st=!0;try{ar(e);const o=e.fn(e._value);(t.version===0||Wt(o,e._value))&&(e.flags|=128,e._value=o,t.version++)}catch(o){throw t.version++,o}finally{fe=n,st=s,lr(e),e.flags&=-3}}function yo(e,t=!1){const{dep:n,prevSub:s,nextSub:o}=e;if(s&&(s.nextSub=o,e.prevSub=void 0),o&&(o.prevSub=s,e.nextSub=void 0),n.subs===e&&(n.subs=s,!s&&n.computed)){n.computed.flags&=-5;for(let i=n.computed.deps;i;i=i.nextDep)yo(i,!0)}!t&&!--n.sc&&n.map&&n.map.delete(n.key)}function Fa(e){const{prevDep:t,nextDep:n}=e;t&&(t.nextDep=n,e.prevDep=void 0),n&&(n.prevDep=t,e.nextDep=void 0)}let st=!0;const ur=[];function Tt(){ur.push(st),st=!1}function Et(){const e=ur.pop();st=e===void 0?!0:e}function Fo(e){const{cleanup:t}=e;if(e.cleanup=void 0,t){const n=fe;fe=void 0;try{t()}finally{fe=n}}}let Dn=0;class Ha{constructor(t,n){this.sub=t,this.dep=n,this.version=n.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class _o{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(t){if(!fe||!st||fe===this.computed)return;let n=this.activeLink;if(n===void 0||n.sub!==fe)n=this.activeLink=new Ha(fe,this),fe.deps?(n.prevDep=fe.depsTail,fe.depsTail.nextDep=n,fe.depsTail=n):fe.deps=fe.depsTail=n,dr(n);else if(n.version===-1&&(n.version=this.version,n.nextDep)){const s=n.nextDep;s.prevDep=n.prevDep,n.prevDep&&(n.prevDep.nextDep=s),n.prevDep=fe.depsTail,n.nextDep=void 0,fe.depsTail.nextDep=n,fe.depsTail=n,fe.deps===n&&(fe.deps=s)}return n}trigger(t){this.version++,Dn++,this.notify(t)}notify(t){vo();try{for(let n=this.subs;n;n=n.prevSub)n.sub.notify()&&n.sub.dep.notify()}finally{bo()}}}function dr(e){if(e.dep.sc++,e.sub.flags&4){const t=e.dep.computed;if(t&&!e.dep.subs){t.flags|=20;for(let s=t.deps;s;s=s.nextDep)dr(s)}const n=e.dep.subs;n!==e&&(e.prevSub=n,n&&(n.nextSub=e)),e.dep.subs=e}}const Gs=new WeakMap,Jt=Symbol(""),Xs=Symbol(""),Nn=Symbol("");function Pe(e,t,n){if(st&&fe){let s=Gs.get(e);s||Gs.set(e,s=new Map);let o=s.get(n);o||(s.set(n,o=new _o),o.map=s,o.key=n),o.track()}}function Ct(e,t,n,s,o,i){const r=Gs.get(e);if(!r){Dn++;return}const a=l=>{l&&l.trigger()};if(vo(),t==="clear")r.forEach(a);else{const l=X(e),u=l&&go(n);if(l&&n==="length"){const c=Number(s);r.forEach((h,p)=>{(p==="length"||p===Nn||!qt(p)&&p>=c)&&a(h)})}else switch((n!==void 0||r.has(void 0))&&a(r.get(n)),u&&a(r.get(Nn)),t){case"add":l?u&&a(r.get("length")):(a(r.get(Jt)),un(e)&&a(r.get(Xs)));break;case"delete":l||(a(r.get(Jt)),un(e)&&a(r.get(Xs)));break;case"set":un(e)&&a(r.get(Jt));break}}bo()}function on(e){const t=se(e);return t===e?t:(Pe(t,"iterate",Nn),tt(e)?t:t.map(ot))}function ms(e){return Pe(e=se(e),"iterate",Nn),e}function $t(e,t){return Rt(e)?fn(Qt(e)?ot(t):t):ot(t)}const qa={__proto__:null,[Symbol.iterator](){return Is(this,Symbol.iterator,e=>$t(this,e))},concat(...e){return on(this).concat(...e.map(t=>X(t)?on(t):t))},entries(){return Is(this,"entries",e=>(e[1]=$t(this,e[1]),e))},every(e,t){return vt(this,"every",e,t,void 0,arguments)},filter(e,t){return vt(this,"filter",e,t,n=>n.map(s=>$t(this,s)),arguments)},find(e,t){return vt(this,"find",e,t,n=>$t(this,n),arguments)},findIndex(e,t){return vt(this,"findIndex",e,t,void 0,arguments)},findLast(e,t){return vt(this,"findLast",e,t,n=>$t(this,n),arguments)},findLastIndex(e,t){return vt(this,"findLastIndex",e,t,void 0,arguments)},forEach(e,t){return vt(this,"forEach",e,t,void 0,arguments)},includes(...e){return Ds(this,"includes",e)},indexOf(...e){return Ds(this,"indexOf",e)},join(e){return on(this).join(e)},lastIndexOf(...e){return Ds(this,"lastIndexOf",e)},map(e,t){return vt(this,"map",e,t,void 0,arguments)},pop(){return bn(this,"pop")},push(...e){return bn(this,"push",e)},reduce(e,...t){return Ho(this,"reduce",e,t)},reduceRight(e,...t){return Ho(this,"reduceRight",e,t)},shift(){return bn(this,"shift")},some(e,t){return vt(this,"some",e,t,void 0,arguments)},splice(...e){return bn(this,"splice",e)},toReversed(){return on(this).toReversed()},toSorted(e){return on(this).toSorted(e)},toSpliced(...e){return on(this).toSpliced(...e)},unshift(...e){return bn(this,"unshift",e)},values(){return Is(this,"values",e=>$t(this,e))}};function Is(e,t,n){const s=ms(e),o=s[t]();return s!==e&&!tt(e)&&(o._next=o.next,o.next=()=>{const i=o._next();return i.done||(i.value=n(i.value)),i}),o}const Va=Array.prototype;function vt(e,t,n,s,o,i){const r=ms(e),a=r!==e&&!tt(e),l=r[t];if(l!==Va[t]){const h=l.apply(e,i);return a?ot(h):h}let u=n;r!==e&&(a?u=function(h,p){return n.call(this,$t(e,h),p,e)}:n.length>2&&(u=function(h,p){return n.call(this,h,p,e)}));const c=l.call(r,u,s);return a&&o?o(c):c}function Ho(e,t,n,s){const o=ms(e);let i=n;return o!==e&&(tt(e)?n.length>3&&(i=function(r,a,l){return n.call(this,r,a,l,e)}):i=function(r,a,l){return n.call(this,r,$t(e,a),l,e)}),o[t](i,...s)}function Ds(e,t,n){const s=se(e);Pe(s,"iterate",Nn);const o=s[t](...n);return(o===-1||o===!1)&&So(n[0])?(n[0]=se(n[0]),s[t](...n)):o}function bn(e,t,n=[]){Tt(),vo();const s=se(e)[t].apply(e,n);return bo(),Et(),s}const ja=ho("__proto__,__v_isRef,__isVue"),hr=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(qt));function Ua(e){qt(e)||(e=String(e));const t=se(this);return Pe(t,"has",e),t.hasOwnProperty(e)}class fr{constructor(t=!1,n=!1){this._isReadonly=t,this._isShallow=n}get(t,n,s){if(n==="__v_skip")return t.__v_skip;const o=this._isReadonly,i=this._isShallow;if(n==="__v_isReactive")return!o;if(n==="__v_isReadonly")return o;if(n==="__v_isShallow")return i;if(n==="__v_raw")return s===(o?i?tl:vr:i?mr:gr).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(s)?t:void 0;const r=X(t);if(!o){let l;if(r&&(l=qa[n]))return l;if(n==="hasOwnProperty")return Ua}const a=Reflect.get(t,n,De(t)?t:s);if((qt(n)?hr.has(n):ja(n))||(o||Pe(t,"get",n),i))return a;if(De(a)){const l=r&&go(n)?a:a.value;return o&&ge(l)?Js(l):l}return ge(a)?o?Js(a):vs(a):a}}class pr extends fr{constructor(t=!1){super(!1,t)}set(t,n,s,o){let i=t[n];const r=X(t)&&go(n);if(!this._isShallow){const u=Rt(i);if(!tt(s)&&!Rt(s)&&(i=se(i),s=se(s)),!r&&De(i)&&!De(s))return u||(i.value=s),!0}const a=r?Number(n)<t.length:re(t,n),l=Reflect.set(t,n,s,De(t)?t:o);return t===se(o)&&(a?Wt(s,i)&&Ct(t,"set",n,s):Ct(t,"add",n,s)),l}deleteProperty(t,n){const s=re(t,n);t[n];const o=Reflect.deleteProperty(t,n);return o&&s&&Ct(t,"delete",n,void 0),o}has(t,n){const s=Reflect.has(t,n);return(!qt(n)||!hr.has(n))&&Pe(t,"has",n),s}ownKeys(t){return Pe(t,"iterate",X(t)?"length":Jt),Reflect.ownKeys(t)}}class za extends fr{constructor(t=!1){super(!0,t)}set(t,n){return!0}deleteProperty(t,n){return!0}}const Ka=new pr,Ga=new za,Xa=new pr(!0);const Ys=e=>e,jn=e=>Reflect.getPrototypeOf(e);function Ya(e,t,n){return function(...s){const o=this.__v_raw,i=se(o),r=un(i),a=e==="entries"||e===Symbol.iterator&&r,l=e==="keys"&&r,u=o[e](...s),c=n?Ys:t?fn:ot;return!t&&Pe(i,"iterate",l?Xs:Jt),Te(Object.create(u),{next(){const{value:h,done:p}=u.next();return p?{value:h,done:p}:{value:a?[c(h[0]),c(h[1])]:c(h),done:p}}})}}function Un(e){return function(...t){return e==="delete"?!1:e==="clear"?void 0:this}}function Ja(e,t){const n={get(o){const i=this.__v_raw,r=se(i),a=se(o);e||(Wt(o,a)&&Pe(r,"get",o),Pe(r,"get",a));const{has:l}=jn(r),u=t?Ys:e?fn:ot;if(l.call(r,o))return u(i.get(o));if(l.call(r,a))return u(i.get(a));i!==r&&i.get(o)},get size(){const o=this.__v_raw;return!e&&Pe(se(o),"iterate",Jt),o.size},has(o){const i=this.__v_raw,r=se(i),a=se(o);return e||(Wt(o,a)&&Pe(r,"has",o),Pe(r,"has",a)),o===a?i.has(o):i.has(o)||i.has(a)},forEach(o,i){const r=this,a=r.__v_raw,l=se(a),u=t?Ys:e?fn:ot;return!e&&Pe(l,"iterate",Jt),a.forEach((c,h)=>o.call(i,u(c),u(h),r))}};return Te(n,e?{add:Un("add"),set:Un("set"),delete:Un("delete"),clear:Un("clear")}:{add(o){!t&&!tt(o)&&!Rt(o)&&(o=se(o));const i=se(this);return jn(i).has.call(i,o)||(i.add(o),Ct(i,"add",o,o)),this},set(o,i){!t&&!tt(i)&&!Rt(i)&&(i=se(i));const r=se(this),{has:a,get:l}=jn(r);let u=a.call(r,o);u||(o=se(o),u=a.call(r,o));const c=l.call(r,o);return r.set(o,i),u?Wt(i,c)&&Ct(r,"set",o,i):Ct(r,"add",o,i),this},delete(o){const i=se(this),{has:r,get:a}=jn(i);let l=r.call(i,o);l||(o=se(o),l=r.call(i,o)),a&&a.call(i,o);const u=i.delete(o);return l&&Ct(i,"delete",o,void 0),u},clear(){const o=se(this),i=o.size!==0,r=o.clear();return i&&Ct(o,"clear",void 0,void 0),r}}),["keys","values","entries",Symbol.iterator].forEach(o=>{n[o]=Ya(o,e,t)}),n}function wo(e,t){const n=Ja(e,t);return(s,o,i)=>o==="__v_isReactive"?!e:o==="__v_isReadonly"?e:o==="__v_raw"?s:Reflect.get(re(n,o)&&o in s?n:s,o,i)}const Qa={get:wo(!1,!1)},Za={get:wo(!1,!0)},el={get:wo(!0,!1)};const gr=new WeakMap,mr=new WeakMap,vr=new WeakMap,tl=new WeakMap;function nl(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function sl(e){return e.__v_skip||!Object.isExtensible(e)?0:nl(Ra(e))}function vs(e){return Rt(e)?e:Co(e,!1,Ka,Qa,gr)}function br(e){return Co(e,!1,Xa,Za,mr)}function Js(e){return Co(e,!0,Ga,el,vr)}function Co(e,t,n,s,o){if(!ge(e)||e.__v_raw&&!(t&&e.__v_isReactive))return e;const i=sl(e);if(i===0)return e;const r=o.get(e);if(r)return r;const a=new Proxy(e,i===2?s:n);return o.set(e,a),a}function Qt(e){return Rt(e)?Qt(e.__v_raw):!!(e&&e.__v_isReactive)}function Rt(e){return!!(e&&e.__v_isReadonly)}function tt(e){return!!(e&&e.__v_isShallow)}function So(e){return e?!!e.__v_raw:!1}function se(e){const t=e&&e.__v_raw;return t?se(t):e}function ol(e){return!re(e,"__v_skip")&&Object.isExtensible(e)&&er(e,"__v_skip",!0),e}const ot=e=>ge(e)?vs(e):e,fn=e=>ge(e)?Js(e):e;function De(e){return e?e.__v_isRef===!0:!1}function ce(e){return yr(e,!1)}function il(e){return yr(e,!0)}function yr(e,t){return De(e)?e:new rl(e,t)}class rl{constructor(t,n){this.dep=new _o,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=n?t:se(t),this._value=n?t:ot(t),this.__v_isShallow=n}get value(){return this.dep.track(),this._value}set value(t){const n=this._rawValue,s=this.__v_isShallow||tt(t)||Rt(t);t=s?t:se(t),Wt(t,n)&&(this._rawValue=t,this._value=s?t:ot(t),this.dep.trigger())}}function Le(e){return De(e)?e.value:e}const al={get:(e,t,n)=>t==="__v_raw"?e:Le(Reflect.get(e,t,n)),set:(e,t,n,s)=>{const o=e[t];return De(o)&&!De(n)?(o.value=n,!0):Reflect.set(e,t,n,s)}};function _r(e){return Qt(e)?e:new Proxy(e,al)}class ll{constructor(t,n,s){this.fn=t,this.setter=n,this._value=void 0,this.dep=new _o(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=Dn-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!n,this.isSSR=s}notify(){if(this.flags|=16,!(this.flags&8)&&fe!==this)return rr(this,!0),!0}get value(){const t=this.dep.track();return cr(this),t&&(t.version=this.dep.version),this._value}set value(t){this.setter&&this.setter(t)}}function cl(e,t,n=!1){let s,o;return Q(e)?s=e:(s=e.get,o=e.set),new ll(s,o,n)}const zn={},ss=new WeakMap;let Gt;function ul(e,t=!1,n=Gt){if(n){let s=ss.get(n);s||ss.set(n,s=[]),s.push(e)}}function dl(e,t,n=de){const{immediate:s,deep:o,once:i,scheduler:r,augmentJob:a,call:l}=n,u=A=>o?A:tt(A)||o===!1||o===0?St(A,1):St(A);let c,h,p,g,y=!1,_=!1;if(De(e)?(h=()=>e.value,y=tt(e)):Qt(e)?(h=()=>u(e),y=!0):X(e)?(_=!0,y=e.some(A=>Qt(A)||tt(A)),h=()=>e.map(A=>{if(De(A))return A.value;if(Qt(A))return u(A);if(Q(A))return l?l(A,2):A()})):Q(e)?t?h=l?()=>l(e,2):e:h=()=>{if(p){Tt();try{p()}finally{Et()}}const A=Gt;Gt=c;try{return l?l(e,3,[g]):e(g)}finally{Gt=A}}:h=pt,t&&o){const A=h,q=o===!0?1/0:o;h=()=>St(A(),q)}const b=Wa(),w=()=>{c.stop(),b&&b.active&&po(b.effects,c)};if(i&&t){const A=t;t=(...q)=>{A(...q),w()}}let T=_?new Array(e.length).fill(zn):zn;const N=A=>{if(!(!(c.flags&1)||!c.dirty&&!A))if(t){const q=c.run();if(o||y||(_?q.some((O,B)=>Wt(O,T[B])):Wt(q,T))){p&&p();const O=Gt;Gt=c;try{const B=[q,T===zn?void 0:_&&T[0]===zn?[]:T,g];T=q,l?l(t,3,B):t(...B)}finally{Gt=O}}}else c.run()};return a&&a(N),c=new or(h),c.scheduler=r?()=>r(N,!1):N,g=A=>ul(A,!1,c),p=c.onStop=()=>{const A=ss.get(c);if(A){if(l)l(A,4);else for(const q of A)q();ss.delete(c)}},t?s?N(!0):T=c.run():r?r(N.bind(null,!0),!0):c.run(),w.pause=c.pause.bind(c),w.resume=c.resume.bind(c),w.stop=w,w}function St(e,t=1/0,n){if(t<=0||!ge(e)||e.__v_skip||(n=n||new Map,(n.get(e)||0)>=t))return e;if(n.set(e,t),t--,De(e))St(e.value,t,n);else if(X(e))for(let s=0;s<e.length;s++)St(e[s],t,n);else if(Xi(e)||un(e))e.forEach(s=>{St(s,t,n)});else if(Qi(e)){for(const s in e)St(e[s],t,n);for(const s of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e,s)&&St(e[s],t,n)}return e}function qn(e,t,n,s){try{return s?e(...s):e()}catch(o){bs(o,t,n)}}function it(e,t,n,s){if(Q(e)){const o=qn(e,t,n,s);return o&&Yi(o)&&o.catch(i=>{bs(i,t,n)}),o}if(X(e)){const o=[];for(let i=0;i<e.length;i++)o.push(it(e[i],t,n,s));return o}}function bs(e,t,n,s=!0){const o=t?t.vnode:null,{errorHandler:i,throwUnhandledErrorInProduction:r}=t&&t.appContext.config||de;if(t){let a=t.parent;const l=t.proxy,u=`https://vuejs.org/error-reference/#runtime-${n}`;for(;a;){const c=a.ec;if(c){for(let h=0;h<c.length;h++)if(c[h](e,l,u)===!1)return}a=a.parent}if(i){Tt(),qn(i,null,10,[e,l,u]),Et();return}}hl(e,n,o,s,r)}function hl(e,t,n,s=!0,o=!1){if(o)throw e;console.error(e)}const We=[];let ht=-1;const dn=[];let Bt=null,rn=0;const wr=Promise.resolve();let os=null;function Cr(e){const t=os||wr;return e?t.then(this?e.bind(this):e):t}function fl(e){let t=ht+1,n=We.length;for(;t<n;){const s=t+n>>>1,o=We[s],i=Mn(o);i<e||i===e&&o.flags&2?t=s+1:n=s}return t}function ko(e){if(!(e.flags&1)){const t=Mn(e),n=We[We.length-1];!n||!(e.flags&2)&&t>=Mn(n)?We.push(e):We.splice(fl(t),0,e),e.flags|=1,Sr()}}function Sr(){os||(os=wr.then(xr))}function pl(e){X(e)?dn.push(...e):Bt&&e.id===-1?Bt.splice(rn+1,0,e):e.flags&1||(dn.push(e),e.flags|=1),Sr()}function qo(e,t,n=ht+1){for(;n<We.length;n++){const s=We[n];if(s&&s.flags&2){if(e&&s.id!==e.uid)continue;We.splice(n,1),n--,s.flags&4&&(s.flags&=-2),s(),s.flags&4||(s.flags&=-2)}}}function kr(e){if(dn.length){const t=[...new Set(dn)].sort((n,s)=>Mn(n)-Mn(s));if(dn.length=0,Bt){Bt.push(...t);return}for(Bt=t,rn=0;rn<Bt.length;rn++){const n=Bt[rn];n.flags&4&&(n.flags&=-2),n.flags&8||n(),n.flags&=-2}Bt=null,rn=0}}const Mn=e=>e.id==null?e.flags&2?-1:1/0:e.id;function xr(e){try{for(ht=0;ht<We.length;ht++){const t=We[ht];t&&!(t.flags&8)&&(t.flags&4&&(t.flags&=-2),qn(t,t.i,t.i?15:14),t.flags&4||(t.flags&=-2))}}finally{for(;ht<We.length;ht++){const t=We[ht];t&&(t.flags&=-2)}ht=-1,We.length=0,kr(),os=null,(We.length||dn.length)&&xr()}}let et=null,Tr=null;function is(e){const t=et;return et=e,Tr=e&&e.type.__scopeId||null,t}function Er(e,t=et,n){if(!t||e._n)return e;const s=(...o)=>{s._d&&ls(-1);const i=is(t);let r;try{r=e(...o)}finally{is(i),s._d&&ls(1)}return r};return s._n=!0,s._c=!0,s._d=!0,s}function Ns(e,t){if(et===null)return e;const n=xs(et),s=e.dirs||(e.dirs=[]);for(let o=0;o<t.length;o++){let[i,r,a,l=de]=t[o];i&&(Q(i)&&(i={mounted:i,updated:i}),i.deep&&St(r),s.push({dir:i,instance:n,value:r,oldValue:void 0,arg:a,modifiers:l}))}return e}function jt(e,t,n,s){const o=e.dirs,i=t&&t.dirs;for(let r=0;r<o.length;r++){const a=o[r];i&&(a.oldValue=i[r].value);let l=a.dir[s];l&&(Tt(),it(l,n,8,[e.el,a,e,t]),Et())}}function Jn(e,t){if(He){let n=He.provides;const s=He.parent&&He.parent.provides;s===n&&(n=He.provides=Object.create(s)),n[e]=t}}function xt(e,t,n=!1){const s=ia();if(s||hn){let o=hn?hn._context.provides:s?s.parent==null||s.ce?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides:void 0;if(o&&e in o)return o[e];if(arguments.length>1)return n&&Q(t)?t.call(s&&s.proxy):t}}const gl=Symbol.for("v-scx"),ml=()=>xt(gl);function Qn(e,t,n){return Rr(e,t,n)}function Rr(e,t,n=de){const{immediate:s,deep:o,flush:i,once:r}=n,a=Te({},n),l=t&&s||!t&&i!=="post";let u;if(Ln){if(i==="sync"){const g=ml();u=g.__watcherHandles||(g.__watcherHandles=[])}else if(!l){const g=()=>{};return g.stop=pt,g.resume=pt,g.pause=pt,g}}const c=He;a.call=(g,y,_)=>it(g,c,y,_);let h=!1;i==="post"?a.scheduler=g=>{Me(g,c&&c.suspense)}:i!=="sync"&&(h=!0,a.scheduler=(g,y)=>{y?g():ko(g)}),a.augmentJob=g=>{t&&(g.flags|=4),h&&(g.flags|=2,c&&(g.id=c.uid,g.i=c))};const p=dl(e,t,a);return Ln&&(u?u.push(p):l&&p()),p}function vl(e,t,n){const s=this.proxy,o=_e(e)?e.includes(".")?Ar(s,e):()=>s[e]:e.bind(s,s);let i;Q(t)?i=t:(i=t.handler,n=t);const r=Vn(this),a=Rr(o,i.bind(s),n);return r(),a}function Ar(e,t){const n=t.split(".");return()=>{let s=e;for(let o=0;o<n.length&&s;o++)s=s[n[o]];return s}}const Pr=Symbol("_vte"),Ir=e=>e.__isTeleport,xn=e=>e&&(e.disabled||e.disabled===""),Vo=e=>e&&(e.defer||e.defer===""),jo=e=>typeof SVGElement<"u"&&e instanceof SVGElement,Uo=e=>typeof MathMLElement=="function"&&e instanceof MathMLElement,Qs=(e,t)=>{const n=e&&e.to;return _e(n)?t?t(n):null:n},Dr={name:"Teleport",__isTeleport:!0,process(e,t,n,s,o,i,r,a,l,u){const{mc:c,pc:h,pbc:p,o:{insert:g,querySelector:y,createText:_,createComment:b}}=u,w=xn(t.props);let{shapeFlag:T,children:N,dynamicChildren:A}=t;if(e==null){const q=t.el=_(""),O=t.anchor=_("");g(q,n,s),g(O,n,s);const B=(L,U)=>{T&16&&c(N,L,U,o,i,r,a,l)},j=()=>{const L=t.target=Qs(t.props,y),U=Nr(L,t,_,g);L&&(r!=="svg"&&jo(L)?r="svg":r!=="mathml"&&Uo(L)&&(r="mathml"),o&&o.isCE&&(o.ce._teleportTargets||(o.ce._teleportTargets=new Set)).add(L),w||(B(L,U),Zn(t,!1)))};w&&(B(n,O),Zn(t,!0)),Vo(t.props)?(t.el.__isMounted=!1,Me(()=>{j(),delete t.el.__isMounted},i)):j()}else{if(Vo(t.props)&&e.el.__isMounted===!1){Me(()=>{Dr.process(e,t,n,s,o,i,r,a,l,u)},i);return}t.el=e.el,t.targetStart=e.targetStart;const q=t.anchor=e.anchor,O=t.target=e.target,B=t.targetAnchor=e.targetAnchor,j=xn(e.props),L=j?n:O,U=j?q:B;if(r==="svg"||jo(O)?r="svg":(r==="mathml"||Uo(O))&&(r="mathml"),A?(p(e.dynamicChildren,A,L,o,i,r,a),Eo(e,t,!0)):l||h(e,t,L,U,o,i,r,a,!1),w)j?t.props&&e.props&&t.props.to!==e.props.to&&(t.props.to=e.props.to):Kn(t,n,q,u,1);else if((t.props&&t.props.to)!==(e.props&&e.props.to)){const te=t.target=Qs(t.props,y);te&&Kn(t,te,null,u,0)}else j&&Kn(t,O,B,u,1);Zn(t,w)}},remove(e,t,n,{um:s,o:{remove:o}},i){const{shapeFlag:r,children:a,anchor:l,targetStart:u,targetAnchor:c,target:h,props:p}=e;if(h&&(o(u),o(c)),i&&o(l),r&16){const g=i||!xn(p);for(let y=0;y<a.length;y++){const _=a[y];s(_,t,n,g,!!_.dynamicChildren)}}},move:Kn,hydrate:bl};function Kn(e,t,n,{o:{insert:s},m:o},i=2){i===0&&s(e.targetAnchor,t,n);const{el:r,anchor:a,shapeFlag:l,children:u,props:c}=e,h=i===2;if(h&&s(r,t,n),(!h||xn(c))&&l&16)for(let p=0;p<u.length;p++)o(u[p],t,n,2);h&&s(a,t,n)}function bl(e,t,n,s,o,i,{o:{nextSibling:r,parentNode:a,querySelector:l,insert:u,createText:c}},h){function p(_,b,w,T){b.anchor=h(r(_),b,a(_),n,s,o,i),b.targetStart=w,b.targetAnchor=T}const g=t.target=Qs(t.props,l),y=xn(t.props);if(g){const _=g._lpa||g.firstChild;if(t.shapeFlag&16)if(y)p(e,t,_,_&&r(_));else{t.anchor=r(e);let b=_;for(;b;){if(b&&b.nodeType===8){if(b.data==="teleport start anchor")t.targetStart=b;else if(b.data==="teleport anchor"){t.targetAnchor=b,g._lpa=t.targetAnchor&&r(t.targetAnchor);break}}b=r(b)}t.targetAnchor||Nr(g,t,c,u),h(_&&r(_),t,g,n,s,o,i)}Zn(t,y)}else y&&t.shapeFlag&16&&p(e,t,e,r(e));return t.anchor&&r(t.anchor)}const yl=Dr;function Zn(e,t){const n=e.ctx;if(n&&n.ut){let s,o;for(t?(s=e.el,o=e.anchor):(s=e.targetStart,o=e.targetAnchor);s&&s!==o;)s.nodeType===1&&s.setAttribute("data-v-owner",n.uid),s=s.nextSibling;n.ut()}}function Nr(e,t,n,s){const o=t.targetStart=n(""),i=t.targetAnchor=n("");return o[Pr]=i,e&&(s(o,e),s(i,e)),i}const wt=Symbol("_leaveCb"),Gn=Symbol("_enterCb");function _l(){const e={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return ws(()=>{e.isMounted=!0}),Hr(()=>{e.isUnmounting=!0}),e}const Ye=[Function,Array],Mr={mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Ye,onEnter:Ye,onAfterEnter:Ye,onEnterCancelled:Ye,onBeforeLeave:Ye,onLeave:Ye,onAfterLeave:Ye,onLeaveCancelled:Ye,onBeforeAppear:Ye,onAppear:Ye,onAfterAppear:Ye,onAppearCancelled:Ye},$r=e=>{const t=e.subTree;return t.component?$r(t.component):t},wl={name:"BaseTransition",props:Mr,setup(e,{slots:t}){const n=ia(),s=_l();return()=>{const o=t.default&&Or(t.default(),!0);if(!o||!o.length)return;const i=Br(o),r=se(e),{mode:a}=r;if(s.isLeaving)return Ms(i);const l=zo(i);if(!l)return Ms(i);let u=Zs(l,r,s,n,h=>u=h);l.type!==Fe&&$n(l,u);let c=n.subTree&&zo(n.subTree);if(c&&c.type!==Fe&&!Xt(c,l)&&$r(n).type!==Fe){let h=Zs(c,r,s,n);if($n(c,h),a==="out-in"&&l.type!==Fe)return s.isLeaving=!0,h.afterLeave=()=>{s.isLeaving=!1,n.job.flags&8||n.update(),delete h.afterLeave,c=void 0},Ms(i);a==="in-out"&&l.type!==Fe?h.delayLeave=(p,g,y)=>{const _=Lr(s,c);_[String(c.key)]=c,p[wt]=()=>{g(),p[wt]=void 0,delete u.delayedLeave,c=void 0},u.delayedLeave=()=>{y(),delete u.delayedLeave,c=void 0}}:c=void 0}else c&&(c=void 0);return i}}};function Br(e){let t=e[0];if(e.length>1){for(const n of e)if(n.type!==Fe){t=n;break}}return t}const Cl=wl;function Lr(e,t){const{leavingVNodes:n}=e;let s=n.get(t.type);return s||(s=Object.create(null),n.set(t.type,s)),s}function Zs(e,t,n,s,o){const{appear:i,mode:r,persisted:a=!1,onBeforeEnter:l,onEnter:u,onAfterEnter:c,onEnterCancelled:h,onBeforeLeave:p,onLeave:g,onAfterLeave:y,onLeaveCancelled:_,onBeforeAppear:b,onAppear:w,onAfterAppear:T,onAppearCancelled:N}=t,A=String(e.key),q=Lr(n,e),O=(L,U)=>{L&&it(L,s,9,U)},B=(L,U)=>{const te=U[1];O(L,U),X(L)?L.every(V=>V.length<=1)&&te():L.length<=1&&te()},j={mode:r,persisted:a,beforeEnter(L){let U=l;if(!n.isMounted)if(i)U=b||l;else return;L[wt]&&L[wt](!0);const te=q[A];te&&Xt(e,te)&&te.el[wt]&&te.el[wt](),O(U,[L])},enter(L){let U=u,te=c,V=h;if(!n.isMounted)if(i)U=w||u,te=T||c,V=N||h;else return;let ee=!1;const we=L[Gn]=Re=>{ee||(ee=!0,Re?O(V,[L]):O(te,[L]),j.delayedLeave&&j.delayedLeave(),L[Gn]=void 0)};U?B(U,[L,we]):we()},leave(L,U){const te=String(e.key);if(L[Gn]&&L[Gn](!0),n.isUnmounting)return U();O(p,[L]);let V=!1;const ee=L[wt]=we=>{V||(V=!0,U(),we?O(_,[L]):O(y,[L]),L[wt]=void 0,q[te]===e&&delete q[te])};q[te]=e,g?B(g,[L,ee]):ee()},clone(L){const U=Zs(L,t,n,s,o);return o&&o(U),U}};return j}function Ms(e){if(ys(e))return e=Ht(e),e.children=null,e}function zo(e){if(!ys(e))return Ir(e.type)&&e.children?Br(e.children):e;if(e.component)return e.component.subTree;const{shapeFlag:t,children:n}=e;if(n){if(t&16)return n[0];if(t&32&&Q(n.default))return n.default()}}function $n(e,t){e.shapeFlag&6&&e.component?(e.transition=t,$n(e.component.subTree,t)):e.shapeFlag&128?(e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t}function Or(e,t=!1,n){let s=[],o=0;for(let i=0;i<e.length;i++){let r=e[i];const a=n==null?r.key:String(n)+String(r.key!=null?r.key:i);r.type===Ee?(r.patchFlag&128&&o++,s=s.concat(Or(r.children,t,a))):(t||r.type!==Fe)&&s.push(a!=null?Ht(r,{key:a}):r)}if(o>1)for(let i=0;i<s.length;i++)s[i].patchFlag=-2;return s}function gt(e,t){return Q(e)?Te({name:e.name},t,{setup:e}):e}function Wr(e){e.ids=[e.ids[0]+e.ids[2]+++"-",0,0]}const rs=new WeakMap;function Tn(e,t,n,s,o=!1){if(X(e)){e.forEach((y,_)=>Tn(y,t&&(X(t)?t[_]:t),n,s,o));return}if(En(s)&&!o){s.shapeFlag&512&&s.type.__asyncResolved&&s.component.subTree.component&&Tn(e,t,n,s.component.subTree);return}const i=s.shapeFlag&4?xs(s.component):s.el,r=o?null:i,{i:a,r:l}=e,u=t&&t.r,c=a.refs===de?a.refs={}:a.refs,h=a.setupState,p=se(h),g=h===de?Gi:y=>re(p,y);if(u!=null&&u!==l){if(Ko(t),_e(u))c[u]=null,g(u)&&(h[u]=null);else if(De(u)){u.value=null;const y=t;y.k&&(c[y.k]=null)}}if(Q(l))qn(l,a,12,[r,c]);else{const y=_e(l),_=De(l);if(y||_){const b=()=>{if(e.f){const w=y?g(l)?h[l]:c[l]:l.value;if(o)X(w)&&po(w,i);else if(X(w))w.includes(i)||w.push(i);else if(y)c[l]=[i],g(l)&&(h[l]=c[l]);else{const T=[i];l.value=T,e.k&&(c[e.k]=T)}}else y?(c[l]=r,g(l)&&(h[l]=r)):_&&(l.value=r,e.k&&(c[e.k]=r))};if(r){const w=()=>{b(),rs.delete(e)};w.id=-1,rs.set(e,w),Me(w,n)}else Ko(e),b()}}}function Ko(e){const t=rs.get(e);t&&(t.flags|=8,rs.delete(e))}gs().requestIdleCallback;gs().cancelIdleCallback;const En=e=>!!e.type.__asyncLoader,ys=e=>e.type.__isKeepAlive;function Sl(e,t){Fr(e,"a",t)}function kl(e,t){Fr(e,"da",t)}function Fr(e,t,n=He){const s=e.__wdc||(e.__wdc=()=>{let o=n;for(;o;){if(o.isDeactivated)return;o=o.parent}return e()});if(_s(t,s,n),n){let o=n.parent;for(;o&&o.parent;)ys(o.parent.vnode)&&xl(s,t,n,o),o=o.parent}}function xl(e,t,n,s){const o=_s(t,e,s,!0);Cs(()=>{po(s[t],o)},n)}function _s(e,t,n=He,s=!1){if(n){const o=n[e]||(n[e]=[]),i=t.__weh||(t.__weh=(...r)=>{Tt();const a=Vn(n),l=it(t,n,e,r);return a(),Et(),l});return s?o.unshift(i):o.push(i),i}}const At=e=>(t,n=He)=>{(!Ln||e==="sp")&&_s(e,(...s)=>t(...s),n)},Tl=At("bm"),ws=At("m"),El=At("bu"),Rl=At("u"),Hr=At("bum"),Cs=At("um"),Al=At("sp"),Pl=At("rtg"),Il=At("rtc");function Dl(e,t=He){_s("ec",e,t)}const Nl=Symbol.for("v-ndc");function Rn(e,t,n,s){let o;const i=n,r=X(e);if(r||_e(e)){const a=r&&Qt(e);let l=!1,u=!1;a&&(l=!tt(e),u=Rt(e),e=ms(e)),o=new Array(e.length);for(let c=0,h=e.length;c<h;c++)o[c]=t(l?u?fn(ot(e[c])):ot(e[c]):e[c],c,void 0,i)}else if(typeof e=="number"){o=new Array(e);for(let a=0;a<e;a++)o[a]=t(a+1,a,void 0,i)}else if(ge(e))if(e[Symbol.iterator])o=Array.from(e,(a,l)=>t(a,l,void 0,i));else{const a=Object.keys(e);o=new Array(a.length);for(let l=0,u=a.length;l<u;l++){const c=a[l];o[l]=t(e[c],c,l,i)}}else o=[];return o}const eo=e=>e?ra(e)?xs(e):eo(e.parent):null,An=Te(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>eo(e.parent),$root:e=>eo(e.root),$host:e=>e.ce,$emit:e=>e.emit,$options:e=>Vr(e),$forceUpdate:e=>e.f||(e.f=()=>{ko(e.update)}),$nextTick:e=>e.n||(e.n=Cr.bind(e.proxy)),$watch:e=>vl.bind(e)}),$s=(e,t)=>e!==de&&!e.__isScriptSetup&&re(e,t),Ml={get({_:e},t){if(t==="__v_skip")return!0;const{ctx:n,setupState:s,data:o,props:i,accessCache:r,type:a,appContext:l}=e;if(t[0]!=="$"){const p=r[t];if(p!==void 0)switch(p){case 1:return s[t];case 2:return o[t];case 4:return n[t];case 3:return i[t]}else{if($s(s,t))return r[t]=1,s[t];if(o!==de&&re(o,t))return r[t]=2,o[t];if(re(i,t))return r[t]=3,i[t];if(n!==de&&re(n,t))return r[t]=4,n[t];to&&(r[t]=0)}}const u=An[t];let c,h;if(u)return t==="$attrs"&&Pe(e.attrs,"get",""),u(e);if((c=a.__cssModules)&&(c=c[t]))return c;if(n!==de&&re(n,t))return r[t]=4,n[t];if(h=l.config.globalProperties,re(h,t))return h[t]},set({_:e},t,n){const{data:s,setupState:o,ctx:i}=e;return $s(o,t)?(o[t]=n,!0):s!==de&&re(s,t)?(s[t]=n,!0):re(e.props,t)||t[0]==="$"&&t.slice(1)in e?!1:(i[t]=n,!0)},has({_:{data:e,setupState:t,accessCache:n,ctx:s,appContext:o,props:i,type:r}},a){let l;return!!(n[a]||e!==de&&a[0]!=="$"&&re(e,a)||$s(t,a)||re(i,a)||re(s,a)||re(An,a)||re(o.config.globalProperties,a)||(l=r.__cssModules)&&l[a])},defineProperty(e,t,n){return n.get!=null?e._.accessCache[t]=0:re(n,"value")&&this.set(e,t,n.value,null),Reflect.defineProperty(e,t,n)}};function Go(e){return X(e)?e.reduce((t,n)=>(t[n]=null,t),{}):e}let to=!0;function $l(e){const t=Vr(e),n=e.proxy,s=e.ctx;to=!1,t.beforeCreate&&Xo(t.beforeCreate,e,"bc");const{data:o,computed:i,methods:r,watch:a,provide:l,inject:u,created:c,beforeMount:h,mounted:p,beforeUpdate:g,updated:y,activated:_,deactivated:b,beforeDestroy:w,beforeUnmount:T,destroyed:N,unmounted:A,render:q,renderTracked:O,renderTriggered:B,errorCaptured:j,serverPrefetch:L,expose:U,inheritAttrs:te,components:V,directives:ee,filters:we}=t;if(u&&Bl(u,s,null),r)for(const oe in r){const ne=r[oe];Q(ne)&&(s[oe]=ne.bind(n))}if(o){const oe=o.call(n,n);ge(oe)&&(e.data=vs(oe))}if(to=!0,i)for(const oe in i){const ne=i[oe],Ge=Q(ne)?ne.bind(n,n):Q(ne.get)?ne.get.bind(n,n):pt,at=!Q(ne)&&Q(ne.set)?ne.set.bind(n):pt,Xe=xe({get:Ge,set:at});Object.defineProperty(s,oe,{enumerable:!0,configurable:!0,get:()=>Xe.value,set:Ae=>Xe.value=Ae})}if(a)for(const oe in a)qr(a[oe],s,n,oe);if(l){const oe=Q(l)?l.call(n):l;Reflect.ownKeys(oe).forEach(ne=>{Jn(ne,oe[ne])})}c&&Xo(c,e,"c");function ve(oe,ne){X(ne)?ne.forEach(Ge=>oe(Ge.bind(n))):ne&&oe(ne.bind(n))}if(ve(Tl,h),ve(ws,p),ve(El,g),ve(Rl,y),ve(Sl,_),ve(kl,b),ve(Dl,j),ve(Il,O),ve(Pl,B),ve(Hr,T),ve(Cs,A),ve(Al,L),X(U))if(U.length){const oe=e.exposed||(e.exposed={});U.forEach(ne=>{Object.defineProperty(oe,ne,{get:()=>n[ne],set:Ge=>n[ne]=Ge,enumerable:!0})})}else e.exposed||(e.exposed={});q&&e.render===pt&&(e.render=q),te!=null&&(e.inheritAttrs=te),V&&(e.components=V),ee&&(e.directives=ee),L&&Wr(e)}function Bl(e,t,n=pt){X(e)&&(e=no(e));for(const s in e){const o=e[s];let i;ge(o)?"default"in o?i=xt(o.from||s,o.default,!0):i=xt(o.from||s):i=xt(o),De(i)?Object.defineProperty(t,s,{enumerable:!0,configurable:!0,get:()=>i.value,set:r=>i.value=r}):t[s]=i}}function Xo(e,t,n){it(X(e)?e.map(s=>s.bind(t.proxy)):e.bind(t.proxy),t,n)}function qr(e,t,n,s){let o=s.includes(".")?Ar(n,s):()=>n[s];if(_e(e)){const i=t[e];Q(i)&&Qn(o,i)}else if(Q(e))Qn(o,e.bind(n));else if(ge(e))if(X(e))e.forEach(i=>qr(i,t,n,s));else{const i=Q(e.handler)?e.handler.bind(n):t[e.handler];Q(i)&&Qn(o,i,e)}}function Vr(e){const t=e.type,{mixins:n,extends:s}=t,{mixins:o,optionsCache:i,config:{optionMergeStrategies:r}}=e.appContext,a=i.get(t);let l;return a?l=a:!o.length&&!n&&!s?l=t:(l={},o.length&&o.forEach(u=>as(l,u,r,!0)),as(l,t,r)),ge(t)&&i.set(t,l),l}function as(e,t,n,s=!1){const{mixins:o,extends:i}=t;i&&as(e,i,n,!0),o&&o.forEach(r=>as(e,r,n,!0));for(const r in t)if(!(s&&r==="expose")){const a=Ll[r]||n&&n[r];e[r]=a?a(e[r],t[r]):t[r]}return e}const Ll={data:Yo,props:Jo,emits:Jo,methods:wn,computed:wn,beforeCreate:Ne,created:Ne,beforeMount:Ne,mounted:Ne,beforeUpdate:Ne,updated:Ne,beforeDestroy:Ne,beforeUnmount:Ne,destroyed:Ne,unmounted:Ne,activated:Ne,deactivated:Ne,errorCaptured:Ne,serverPrefetch:Ne,components:wn,directives:wn,watch:Wl,provide:Yo,inject:Ol};function Yo(e,t){return t?e?function(){return Te(Q(e)?e.call(this,this):e,Q(t)?t.call(this,this):t)}:t:e}function Ol(e,t){return wn(no(e),no(t))}function no(e){if(X(e)){const t={};for(let n=0;n<e.length;n++)t[e[n]]=e[n];return t}return e}function Ne(e,t){return e?[...new Set([].concat(e,t))]:t}function wn(e,t){return e?Te(Object.create(null),e,t):t}function Jo(e,t){return e?X(e)&&X(t)?[...new Set([...e,...t])]:Te(Object.create(null),Go(e),Go(t??{})):t}function Wl(e,t){if(!e)return t;if(!t)return e;const n=Te(Object.create(null),e);for(const s in t)n[s]=Ne(e[s],t[s]);return n}function jr(){return{app:null,config:{isNativeTag:Gi,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let Fl=0;function Hl(e,t){return function(s,o=null){Q(s)||(s=Te({},s)),o!=null&&!ge(o)&&(o=null);const i=jr(),r=new WeakSet,a=[];let l=!1;const u=i.app={_uid:Fl++,_component:s,_props:o,_container:null,_context:i,_instance:null,version:bc,get config(){return i.config},set config(c){},use(c,...h){return r.has(c)||(c&&Q(c.install)?(r.add(c),c.install(u,...h)):Q(c)&&(r.add(c),c(u,...h))),u},mixin(c){return i.mixins.includes(c)||i.mixins.push(c),u},component(c,h){return h?(i.components[c]=h,u):i.components[c]},directive(c,h){return h?(i.directives[c]=h,u):i.directives[c]},mount(c,h,p){if(!l){const g=u._ceVNode||ue(s,o);return g.appContext=i,p===!0?p="svg":p===!1&&(p=void 0),e(g,c,p),l=!0,u._container=c,c.__vue_app__=u,xs(g.component)}},onUnmount(c){a.push(c)},unmount(){l&&(it(a,u._instance,16),e(null,u._container),delete u._container.__vue_app__)},provide(c,h){return i.provides[c]=h,u},runWithContext(c){const h=hn;hn=u;try{return c()}finally{hn=h}}};return u}}let hn=null;const ql=(e,t)=>t==="modelValue"||t==="model-value"?e.modelModifiers:e[`${t}Modifiers`]||e[`${Ft(t)}Modifiers`]||e[`${Vt(t)}Modifiers`];function Vl(e,t,...n){if(e.isUnmounted)return;const s=e.vnode.props||de;let o=n;const i=t.startsWith("update:"),r=i&&ql(s,t.slice(7));r&&(r.trim&&(o=n.map(c=>_e(c)?c.trim():c)),r.number&&(o=n.map(mo)));let a,l=s[a=Rs(t)]||s[a=Rs(Ft(t))];!l&&i&&(l=s[a=Rs(Vt(t))]),l&&it(l,e,6,o);const u=s[a+"Once"];if(u){if(!e.emitted)e.emitted={};else if(e.emitted[a])return;e.emitted[a]=!0,it(u,e,6,o)}}const jl=new WeakMap;function Ur(e,t,n=!1){const s=n?jl:t.emitsCache,o=s.get(e);if(o!==void 0)return o;const i=e.emits;let r={},a=!1;if(!Q(e)){const l=u=>{const c=Ur(u,t,!0);c&&(a=!0,Te(r,c))};!n&&t.mixins.length&&t.mixins.forEach(l),e.extends&&l(e.extends),e.mixins&&e.mixins.forEach(l)}return!i&&!a?(ge(e)&&s.set(e,null),null):(X(i)?i.forEach(l=>r[l]=null):Te(r,i),ge(e)&&s.set(e,r),r)}function Ss(e,t){return!e||!hs(t)?!1:(t=t.slice(2).replace(/Once$/,""),re(e,t[0].toLowerCase()+t.slice(1))||re(e,Vt(t))||re(e,t))}function Qo(e){const{type:t,vnode:n,proxy:s,withProxy:o,propsOptions:[i],slots:r,attrs:a,emit:l,render:u,renderCache:c,props:h,data:p,setupState:g,ctx:y,inheritAttrs:_}=e,b=is(e);let w,T;try{if(n.shapeFlag&4){const A=o||s,q=A;w=ft(u.call(q,A,c,h,g,p,y)),T=a}else{const A=t;w=ft(A.length>1?A(h,{attrs:a,slots:r,emit:l}):A(h,null)),T=t.props?a:Ul(a)}}catch(A){Pn.length=0,bs(A,e,1),w=ue(Fe)}let N=w;if(T&&_!==!1){const A=Object.keys(T),{shapeFlag:q}=N;A.length&&q&7&&(i&&A.some(fo)&&(T=zl(T,i)),N=Ht(N,T,!1,!0))}return n.dirs&&(N=Ht(N,null,!1,!0),N.dirs=N.dirs?N.dirs.concat(n.dirs):n.dirs),n.transition&&$n(N,n.transition),w=N,is(b),w}const Ul=e=>{let t;for(const n in e)(n==="class"||n==="style"||hs(n))&&((t||(t={}))[n]=e[n]);return t},zl=(e,t)=>{const n={};for(const s in e)(!fo(s)||!(s.slice(9)in t))&&(n[s]=e[s]);return n};function Kl(e,t,n){const{props:s,children:o,component:i}=e,{props:r,children:a,patchFlag:l}=t,u=i.emitsOptions;if(t.dirs||t.transition)return!0;if(n&&l>=0){if(l&1024)return!0;if(l&16)return s?Zo(s,r,u):!!r;if(l&8){const c=t.dynamicProps;for(let h=0;h<c.length;h++){const p=c[h];if(r[p]!==s[p]&&!Ss(u,p))return!0}}}else return(o||a)&&(!a||!a.$stable)?!0:s===r?!1:s?r?Zo(s,r,u):!0:!!r;return!1}function Zo(e,t,n){const s=Object.keys(t);if(s.length!==Object.keys(e).length)return!0;for(let o=0;o<s.length;o++){const i=s[o];if(t[i]!==e[i]&&!Ss(n,i))return!0}return!1}function Gl({vnode:e,parent:t},n){for(;t;){const s=t.subTree;if(s.suspense&&s.suspense.activeBranch===e&&(s.el=e.el),s===e)(e=t.vnode).el=n,t=t.parent;else break}}const zr={},Kr=()=>Object.create(zr),Gr=e=>Object.getPrototypeOf(e)===zr;function Xl(e,t,n,s=!1){const o={},i=Kr();e.propsDefaults=Object.create(null),Xr(e,t,o,i);for(const r in e.propsOptions[0])r in o||(o[r]=void 0);n?e.props=s?o:br(o):e.type.props?e.props=o:e.props=i,e.attrs=i}function Yl(e,t,n,s){const{props:o,attrs:i,vnode:{patchFlag:r}}=e,a=se(o),[l]=e.propsOptions;let u=!1;if((s||r>0)&&!(r&16)){if(r&8){const c=e.vnode.dynamicProps;for(let h=0;h<c.length;h++){let p=c[h];if(Ss(e.emitsOptions,p))continue;const g=t[p];if(l)if(re(i,p))g!==i[p]&&(i[p]=g,u=!0);else{const y=Ft(p);o[y]=so(l,a,y,g,e,!1)}else g!==i[p]&&(i[p]=g,u=!0)}}}else{Xr(e,t,o,i)&&(u=!0);let c;for(const h in a)(!t||!re(t,h)&&((c=Vt(h))===h||!re(t,c)))&&(l?n&&(n[h]!==void 0||n[c]!==void 0)&&(o[h]=so(l,a,h,void 0,e,!0)):delete o[h]);if(i!==a)for(const h in i)(!t||!re(t,h))&&(delete i[h],u=!0)}u&&Ct(e.attrs,"set","")}function Xr(e,t,n,s){const[o,i]=e.propsOptions;let r=!1,a;if(t)for(let l in t){if(Cn(l))continue;const u=t[l];let c;o&&re(o,c=Ft(l))?!i||!i.includes(c)?n[c]=u:(a||(a={}))[c]=u:Ss(e.emitsOptions,l)||(!(l in s)||u!==s[l])&&(s[l]=u,r=!0)}if(i){const l=se(n),u=a||de;for(let c=0;c<i.length;c++){const h=i[c];n[h]=so(o,l,h,u[h],e,!re(u,h))}}return r}function so(e,t,n,s,o,i){const r=e[n];if(r!=null){const a=re(r,"default");if(a&&s===void 0){const l=r.default;if(r.type!==Function&&!r.skipFactory&&Q(l)){const{propsDefaults:u}=o;if(n in u)s=u[n];else{const c=Vn(o);s=u[n]=l.call(null,t),c()}}else s=l;o.ce&&o.ce._setProp(n,s)}r[0]&&(i&&!a?s=!1:r[1]&&(s===""||s===Vt(n))&&(s=!0))}return s}const Jl=new WeakMap;function Yr(e,t,n=!1){const s=n?Jl:t.propsCache,o=s.get(e);if(o)return o;const i=e.props,r={},a=[];let l=!1;if(!Q(e)){const c=h=>{l=!0;const[p,g]=Yr(h,t,!0);Te(r,p),g&&a.push(...g)};!n&&t.mixins.length&&t.mixins.forEach(c),e.extends&&c(e.extends),e.mixins&&e.mixins.forEach(c)}if(!i&&!l)return ge(e)&&s.set(e,cn),cn;if(X(i))for(let c=0;c<i.length;c++){const h=Ft(i[c]);ei(h)&&(r[h]=de)}else if(i)for(const c in i){const h=Ft(c);if(ei(h)){const p=i[c],g=r[h]=X(p)||Q(p)?{type:p}:Te({},p),y=g.type;let _=!1,b=!0;if(X(y))for(let w=0;w<y.length;++w){const T=y[w],N=Q(T)&&T.name;if(N==="Boolean"){_=!0;break}else N==="String"&&(b=!1)}else _=Q(y)&&y.name==="Boolean";g[0]=_,g[1]=b,(_||re(g,"default"))&&a.push(h)}}const u=[r,a];return ge(e)&&s.set(e,u),u}function ei(e){return e[0]!=="$"&&!Cn(e)}const xo=e=>e==="_"||e==="_ctx"||e==="$stable",To=e=>X(e)?e.map(ft):[ft(e)],Ql=(e,t,n)=>{if(t._n)return t;const s=Er((...o)=>To(t(...o)),n);return s._c=!1,s},Jr=(e,t,n)=>{const s=e._ctx;for(const o in e){if(xo(o))continue;const i=e[o];if(Q(i))t[o]=Ql(o,i,s);else if(i!=null){const r=To(i);t[o]=()=>r}}},Qr=(e,t)=>{const n=To(t);e.slots.default=()=>n},Zr=(e,t,n)=>{for(const s in t)(n||!xo(s))&&(e[s]=t[s])},Zl=(e,t,n)=>{const s=e.slots=Kr();if(e.vnode.shapeFlag&32){const o=t._;o?(Zr(s,t,n),n&&er(s,"_",o,!0)):Jr(t,s)}else t&&Qr(e,t)},ec=(e,t,n)=>{const{vnode:s,slots:o}=e;let i=!0,r=de;if(s.shapeFlag&32){const a=t._;a?n&&a===1?i=!1:Zr(o,t,n):(i=!t.$stable,Jr(t,o)),r=t}else t&&(Qr(e,t),r={default:1});if(i)for(const a in o)!xo(a)&&r[a]==null&&delete o[a]},Me=ic;function tc(e){return nc(e)}function nc(e,t){const n=gs();n.__VUE__=!0;const{insert:s,remove:o,patchProp:i,createElement:r,createText:a,createComment:l,setText:u,setElementText:c,parentNode:h,nextSibling:p,setScopeId:g=pt,insertStaticContent:y}=e,_=(d,f,m,k=null,E=null,x=null,F=void 0,$=null,M=!!f.dynamicChildren)=>{if(d===f)return;d&&!Xt(d,f)&&(k=v(d),Ae(d,E,x,!0),d=null),f.patchFlag===-2&&(M=!1,f.dynamicChildren=null);const{type:P,ref:G,shapeFlag:H}=f;switch(P){case ks:b(d,f,m,k);break;case Fe:w(d,f,m,k);break;case es:d==null&&T(f,m,k,F);break;case Ee:V(d,f,m,k,E,x,F,$,M);break;default:H&1?q(d,f,m,k,E,x,F,$,M):H&6?ee(d,f,m,k,E,x,F,$,M):(H&64||H&128)&&P.process(d,f,m,k,E,x,F,$,M,W)}G!=null&&E?Tn(G,d&&d.ref,x,f||d,!f):G==null&&d&&d.ref!=null&&Tn(d.ref,null,x,d,!0)},b=(d,f,m,k)=>{if(d==null)s(f.el=a(f.children),m,k);else{const E=f.el=d.el;f.children!==d.children&&u(E,f.children)}},w=(d,f,m,k)=>{d==null?s(f.el=l(f.children||""),m,k):f.el=d.el},T=(d,f,m,k)=>{[d.el,d.anchor]=y(d.children,f,m,k,d.el,d.anchor)},N=({el:d,anchor:f},m,k)=>{let E;for(;d&&d!==f;)E=p(d),s(d,m,k),d=E;s(f,m,k)},A=({el:d,anchor:f})=>{let m;for(;d&&d!==f;)m=p(d),o(d),d=m;o(f)},q=(d,f,m,k,E,x,F,$,M)=>{if(f.type==="svg"?F="svg":f.type==="math"&&(F="mathml"),d==null)O(f,m,k,E,x,F,$,M);else{const P=d.el&&d.el._isVueCE?d.el:null;try{P&&P._beginPatch(),L(d,f,E,x,F,$,M)}finally{P&&P._endPatch()}}},O=(d,f,m,k,E,x,F,$)=>{let M,P;const{props:G,shapeFlag:H,transition:z,dirs:Y}=d;if(M=d.el=r(d.type,x,G&&G.is,G),H&8?c(M,d.children):H&16&&j(d.children,M,null,k,E,Bs(d,x),F,$),Y&&jt(d,null,k,"created"),B(M,d,d.scopeId,F,k),G){for(const he in G)he!=="value"&&!Cn(he)&&i(M,he,null,G[he],x,k);"value"in G&&i(M,"value",null,G.value,x),(P=G.onVnodeBeforeMount)&&dt(P,k,d)}Y&&jt(d,null,k,"beforeMount");const Z=sc(E,z);Z&&z.beforeEnter(M),s(M,f,m),((P=G&&G.onVnodeMounted)||Z||Y)&&Me(()=>{P&&dt(P,k,d),Z&&z.enter(M),Y&&jt(d,null,k,"mounted")},E)},B=(d,f,m,k,E)=>{if(m&&g(d,m),k)for(let x=0;x<k.length;x++)g(d,k[x]);if(E){let x=E.subTree;if(f===x||na(x.type)&&(x.ssContent===f||x.ssFallback===f)){const F=E.vnode;B(d,F,F.scopeId,F.slotScopeIds,E.parent)}}},j=(d,f,m,k,E,x,F,$,M=0)=>{for(let P=M;P<d.length;P++){const G=d[P]=$?Lt(d[P]):ft(d[P]);_(null,G,f,m,k,E,x,F,$)}},L=(d,f,m,k,E,x,F)=>{const $=f.el=d.el;let{patchFlag:M,dynamicChildren:P,dirs:G}=f;M|=d.patchFlag&16;const H=d.props||de,z=f.props||de;let Y;if(m&&Ut(m,!1),(Y=z.onVnodeBeforeUpdate)&&dt(Y,m,f,d),G&&jt(f,d,m,"beforeUpdate"),m&&Ut(m,!0),(H.innerHTML&&z.innerHTML==null||H.textContent&&z.textContent==null)&&c($,""),P?U(d.dynamicChildren,P,$,m,k,Bs(f,E),x):F||ne(d,f,$,null,m,k,Bs(f,E),x,!1),M>0){if(M&16)te($,H,z,m,E);else if(M&2&&H.class!==z.class&&i($,"class",null,z.class,E),M&4&&i($,"style",H.style,z.style,E),M&8){const Z=f.dynamicProps;for(let he=0;he<Z.length;he++){const ae=Z[he],qe=H[ae],Ve=z[ae];(Ve!==qe||ae==="value")&&i($,ae,qe,Ve,E,m)}}M&1&&d.children!==f.children&&c($,f.children)}else!F&&P==null&&te($,H,z,m,E);((Y=z.onVnodeUpdated)||G)&&Me(()=>{Y&&dt(Y,m,f,d),G&&jt(f,d,m,"updated")},k)},U=(d,f,m,k,E,x,F)=>{for(let $=0;$<f.length;$++){const M=d[$],P=f[$],G=M.el&&(M.type===Ee||!Xt(M,P)||M.shapeFlag&198)?h(M.el):m;_(M,P,G,null,k,E,x,F,!0)}},te=(d,f,m,k,E)=>{if(f!==m){if(f!==de)for(const x in f)!Cn(x)&&!(x in m)&&i(d,x,f[x],null,E,k);for(const x in m){if(Cn(x))continue;const F=m[x],$=f[x];F!==$&&x!=="value"&&i(d,x,$,F,E,k)}"value"in m&&i(d,"value",f.value,m.value,E)}},V=(d,f,m,k,E,x,F,$,M)=>{const P=f.el=d?d.el:a(""),G=f.anchor=d?d.anchor:a("");let{patchFlag:H,dynamicChildren:z,slotScopeIds:Y}=f;Y&&($=$?$.concat(Y):Y),d==null?(s(P,m,k),s(G,m,k),j(f.children||[],m,G,E,x,F,$,M)):H>0&&H&64&&z&&d.dynamicChildren&&d.dynamicChildren.length===z.length?(U(d.dynamicChildren,z,m,E,x,F,$),(f.key!=null||E&&f===E.subTree)&&Eo(d,f,!0)):ne(d,f,m,G,E,x,F,$,M)},ee=(d,f,m,k,E,x,F,$,M)=>{f.slotScopeIds=$,d==null?f.shapeFlag&512?E.ctx.activate(f,m,k,F,M):we(f,m,k,E,x,F,M):Re(d,f,M)},we=(d,f,m,k,E,x,F)=>{const $=d.component=hc(d,k,E);if(ys(d)&&($.ctx.renderer=W),fc($,!1,F),$.asyncDep){if(E&&E.registerDep($,ve,F),!d.el){const M=$.subTree=ue(Fe);w(null,M,f,m),d.placeholder=M.el}}else ve($,d,f,m,E,x,F)},Re=(d,f,m)=>{const k=f.component=d.component;if(Kl(d,f,m))if(k.asyncDep&&!k.asyncResolved){oe(k,f,m);return}else k.next=f,k.update();else f.el=d.el,k.vnode=f},ve=(d,f,m,k,E,x,F)=>{const $=()=>{if(d.isMounted){let{next:H,bu:z,u:Y,parent:Z,vnode:he}=d;{const ct=ea(d);if(ct){H&&(H.el=he.el,oe(d,H,F)),ct.asyncDep.then(()=>{d.isUnmounted||$()});return}}let ae=H,qe;Ut(d,!1),H?(H.el=he.el,oe(d,H,F)):H=he,z&&Yn(z),(qe=H.props&&H.props.onVnodeBeforeUpdate)&&dt(qe,Z,H,he),Ut(d,!0);const Ve=Qo(d),lt=d.subTree;d.subTree=Ve,_(lt,Ve,h(lt.el),v(lt),d,E,x),H.el=Ve.el,ae===null&&Gl(d,Ve.el),Y&&Me(Y,E),(qe=H.props&&H.props.onVnodeUpdated)&&Me(()=>dt(qe,Z,H,he),E)}else{let H;const{el:z,props:Y}=f,{bm:Z,m:he,parent:ae,root:qe,type:Ve}=d,lt=En(f);Ut(d,!1),Z&&Yn(Z),!lt&&(H=Y&&Y.onVnodeBeforeMount)&&dt(H,ae,f),Ut(d,!0);{qe.ce&&qe.ce._def.shadowRoot!==!1&&qe.ce._injectChildStyle(Ve);const ct=d.subTree=Qo(d);_(null,ct,m,k,d,E,x),f.el=ct.el}if(he&&Me(he,E),!lt&&(H=Y&&Y.onVnodeMounted)){const ct=f;Me(()=>dt(H,ae,ct),E)}(f.shapeFlag&256||ae&&En(ae.vnode)&&ae.vnode.shapeFlag&256)&&d.a&&Me(d.a,E),d.isMounted=!0,f=m=k=null}};d.scope.on();const M=d.effect=new or($);d.scope.off();const P=d.update=M.run.bind(M),G=d.job=M.runIfDirty.bind(M);G.i=d,G.id=d.uid,M.scheduler=()=>ko(G),Ut(d,!0),P()},oe=(d,f,m)=>{f.component=d;const k=d.vnode.props;d.vnode=f,d.next=null,Yl(d,f.props,k,m),ec(d,f.children,m),Tt(),qo(d),Et()},ne=(d,f,m,k,E,x,F,$,M=!1)=>{const P=d&&d.children,G=d?d.shapeFlag:0,H=f.children,{patchFlag:z,shapeFlag:Y}=f;if(z>0){if(z&128){at(P,H,m,k,E,x,F,$,M);return}else if(z&256){Ge(P,H,m,k,E,x,F,$,M);return}}Y&8?(G&16&&D(P,E,x),H!==P&&c(m,H)):G&16?Y&16?at(P,H,m,k,E,x,F,$,M):D(P,E,x,!0):(G&8&&c(m,""),Y&16&&j(H,m,k,E,x,F,$,M))},Ge=(d,f,m,k,E,x,F,$,M)=>{d=d||cn,f=f||cn;const P=d.length,G=f.length,H=Math.min(P,G);let z;for(z=0;z<H;z++){const Y=f[z]=M?Lt(f[z]):ft(f[z]);_(d[z],Y,m,null,E,x,F,$,M)}P>G?D(d,E,x,!0,!1,H):j(f,m,k,E,x,F,$,M,H)},at=(d,f,m,k,E,x,F,$,M)=>{let P=0;const G=f.length;let H=d.length-1,z=G-1;for(;P<=H&&P<=z;){const Y=d[P],Z=f[P]=M?Lt(f[P]):ft(f[P]);if(Xt(Y,Z))_(Y,Z,m,null,E,x,F,$,M);else break;P++}for(;P<=H&&P<=z;){const Y=d[H],Z=f[z]=M?Lt(f[z]):ft(f[z]);if(Xt(Y,Z))_(Y,Z,m,null,E,x,F,$,M);else break;H--,z--}if(P>H){if(P<=z){const Y=z+1,Z=Y<G?f[Y].el:k;for(;P<=z;)_(null,f[P]=M?Lt(f[P]):ft(f[P]),m,Z,E,x,F,$,M),P++}}else if(P>z)for(;P<=H;)Ae(d[P],E,x,!0),P++;else{const Y=P,Z=P,he=new Map;for(P=Z;P<=z;P++){const Ue=f[P]=M?Lt(f[P]):ft(f[P]);Ue.key!=null&&he.set(Ue.key,P)}let ae,qe=0;const Ve=z-Z+1;let lt=!1,ct=0;const vn=new Array(Ve);for(P=0;P<Ve;P++)vn[P]=0;for(P=Y;P<=H;P++){const Ue=d[P];if(qe>=Ve){Ae(Ue,E,x,!0);continue}let ut;if(Ue.key!=null)ut=he.get(Ue.key);else for(ae=Z;ae<=z;ae++)if(vn[ae-Z]===0&&Xt(Ue,f[ae])){ut=ae;break}ut===void 0?Ae(Ue,E,x,!0):(vn[ut-Z]=P+1,ut>=ct?ct=ut:lt=!0,_(Ue,f[ut],m,null,E,x,F,$,M),qe++)}const Bo=lt?oc(vn):cn;for(ae=Bo.length-1,P=Ve-1;P>=0;P--){const Ue=Z+P,ut=f[Ue],Lo=f[Ue+1],Oo=Ue+1<G?Lo.el||ta(Lo):k;vn[P]===0?_(null,ut,m,Oo,E,x,F,$,M):lt&&(ae<0||P!==Bo[ae]?Xe(ut,m,Oo,2):ae--)}}},Xe=(d,f,m,k,E=null)=>{const{el:x,type:F,transition:$,children:M,shapeFlag:P}=d;if(P&6){Xe(d.component.subTree,f,m,k);return}if(P&128){d.suspense.move(f,m,k);return}if(P&64){F.move(d,f,m,W);return}if(F===Ee){s(x,f,m);for(let H=0;H<M.length;H++)Xe(M[H],f,m,k);s(d.anchor,f,m);return}if(F===es){N(d,f,m);return}if(k!==2&&P&1&&$)if(k===0)$.beforeEnter(x),s(x,f,m),Me(()=>$.enter(x),E);else{const{leave:H,delayLeave:z,afterLeave:Y}=$,Z=()=>{d.ctx.isUnmounted?o(x):s(x,f,m)},he=()=>{x._isLeaving&&x[wt](!0),H(x,()=>{Z(),Y&&Y()})};z?z(x,Z,he):he()}else s(x,f,m)},Ae=(d,f,m,k=!1,E=!1)=>{const{type:x,props:F,ref:$,children:M,dynamicChildren:P,shapeFlag:G,patchFlag:H,dirs:z,cacheIndex:Y}=d;if(H===-2&&(E=!1),$!=null&&(Tt(),Tn($,null,m,d,!0),Et()),Y!=null&&(f.renderCache[Y]=void 0),G&256){f.ctx.deactivate(d);return}const Z=G&1&&z,he=!En(d);let ae;if(he&&(ae=F&&F.onVnodeBeforeUnmount)&&dt(ae,f,d),G&6)mt(d.component,m,k);else{if(G&128){d.suspense.unmount(m,k);return}Z&&jt(d,null,f,"beforeUnmount"),G&64?d.type.remove(d,f,m,W,k):P&&!P.hasOnce&&(x!==Ee||H>0&&H&64)?D(P,f,m,!1,!0):(x===Ee&&H&384||!E&&G&16)&&D(M,f,m),k&&Pt(d)}(he&&(ae=F&&F.onVnodeUnmounted)||Z)&&Me(()=>{ae&&dt(ae,f,d),Z&&jt(d,null,f,"unmounted")},m)},Pt=d=>{const{type:f,el:m,anchor:k,transition:E}=d;if(f===Ee){It(m,k);return}if(f===es){A(d);return}const x=()=>{o(m),E&&!E.persisted&&E.afterLeave&&E.afterLeave()};if(d.shapeFlag&1&&E&&!E.persisted){const{leave:F,delayLeave:$}=E,M=()=>F(m,x);$?$(d.el,x,M):M()}else x()},It=(d,f)=>{let m;for(;d!==f;)m=p(d),o(d),d=m;o(f)},mt=(d,f,m)=>{const{bum:k,scope:E,job:x,subTree:F,um:$,m:M,a:P}=d;ti(M),ti(P),k&&Yn(k),E.stop(),x&&(x.flags|=8,Ae(F,d,f,m)),$&&Me($,f),Me(()=>{d.isUnmounted=!0},f)},D=(d,f,m,k=!1,E=!1,x=0)=>{for(let F=x;F<d.length;F++)Ae(d[F],f,m,k,E)},v=d=>{if(d.shapeFlag&6)return v(d.component.subTree);if(d.shapeFlag&128)return d.suspense.next();const f=p(d.anchor||d.el),m=f&&f[Pr];return m?p(m):f};let R=!1;const I=(d,f,m)=>{let k;d==null?f._vnode&&(Ae(f._vnode,null,null,!0),k=f._vnode.component):_(f._vnode||null,d,f,null,null,null,m),f._vnode=d,R||(R=!0,qo(k),kr(),R=!1)},W={p:_,um:Ae,m:Xe,r:Pt,mt:we,mc:j,pc:ne,pbc:U,n:v,o:e};return{render:I,hydrate:void 0,createApp:Hl(I)}}function Bs({type:e,props:t},n){return n==="svg"&&e==="foreignObject"||n==="mathml"&&e==="annotation-xml"&&t&&t.encoding&&t.encoding.includes("html")?void 0:n}function Ut({effect:e,job:t},n){n?(e.flags|=32,t.flags|=4):(e.flags&=-33,t.flags&=-5)}function sc(e,t){return(!e||e&&!e.pendingBranch)&&t&&!t.persisted}function Eo(e,t,n=!1){const s=e.children,o=t.children;if(X(s)&&X(o))for(let i=0;i<s.length;i++){const r=s[i];let a=o[i];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=o[i]=Lt(o[i]),a.el=r.el),!n&&a.patchFlag!==-2&&Eo(r,a)),a.type===ks&&(a.patchFlag!==-1?a.el=r.el:a.__elIndex=i+(e.type===Ee?1:0)),a.type===Fe&&!a.el&&(a.el=r.el)}}function oc(e){const t=e.slice(),n=[0];let s,o,i,r,a;const l=e.length;for(s=0;s<l;s++){const u=e[s];if(u!==0){if(o=n[n.length-1],e[o]<u){t[s]=o,n.push(s);continue}for(i=0,r=n.length-1;i<r;)a=i+r>>1,e[n[a]]<u?i=a+1:r=a;u<e[n[i]]&&(i>0&&(t[s]=n[i-1]),n[i]=s)}}for(i=n.length,r=n[i-1];i-- >0;)n[i]=r,r=t[r];return n}function ea(e){const t=e.subTree.component;if(t)return t.asyncDep&&!t.asyncResolved?t:ea(t)}function ti(e){if(e)for(let t=0;t<e.length;t++)e[t].flags|=8}function ta(e){if(e.placeholder)return e.placeholder;const t=e.component;return t?ta(t.subTree):null}const na=e=>e.__isSuspense;function ic(e,t){t&&t.pendingBranch?X(e)?t.effects.push(...e):t.effects.push(e):pl(e)}const Ee=Symbol.for("v-fgt"),ks=Symbol.for("v-txt"),Fe=Symbol.for("v-cmt"),es=Symbol.for("v-stc"),Pn=[];let ze=null;function le(e=!1){Pn.push(ze=e?null:[])}function rc(){Pn.pop(),ze=Pn[Pn.length-1]||null}let Bn=1;function ls(e,t=!1){Bn+=e,e<0&&ze&&t&&(ze.hasOnce=!0)}function sa(e){return e.dynamicChildren=Bn>0?ze||cn:null,rc(),Bn>0&&ze&&ze.push(e),e}function pe(e,t,n,s,o,i){return sa(C(e,t,n,s,o,i,!0))}function Ro(e,t,n,s,o){return sa(ue(e,t,n,s,o,!0))}function cs(e){return e?e.__v_isVNode===!0:!1}function Xt(e,t){return e.type===t.type&&e.key===t.key}const oa=({key:e})=>e??null,ts=({ref:e,ref_key:t,ref_for:n})=>(typeof e=="number"&&(e=""+e),e!=null?_e(e)||De(e)||Q(e)?{i:et,r:e,k:t,f:!!n}:e:null);function C(e,t=null,n=null,s=0,o=null,i=e===Ee?0:1,r=!1,a=!1){const l={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&oa(t),ref:t&&ts(t),scopeId:Tr,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:i,patchFlag:s,dynamicProps:o,dynamicChildren:null,appContext:null,ctx:et};return a?(Ao(l,n),i&128&&e.normalize(l)):n&&(l.shapeFlag|=_e(n)?8:16),Bn>0&&!r&&ze&&(l.patchFlag>0||i&6)&&l.patchFlag!==32&&ze.push(l),l}const ue=ac;function ac(e,t=null,n=null,s=0,o=null,i=!1){if((!e||e===Nl)&&(e=Fe),cs(e)){const a=Ht(e,t,!0);return n&&Ao(a,n),Bn>0&&!i&&ze&&(a.shapeFlag&6?ze[ze.indexOf(e)]=a:ze.push(a)),a.patchFlag=-2,a}if(vc(e)&&(e=e.__vccOpts),t){t=lc(t);let{class:a,style:l}=t;a&&!_e(a)&&(t.class=tn(a)),ge(l)&&(So(l)&&!X(l)&&(l=Te({},l)),t.style=Oe(l))}const r=_e(e)?1:na(e)?128:Ir(e)?64:ge(e)?4:Q(e)?2:0;return C(e,t,n,s,o,r,i,!0)}function lc(e){return e?So(e)||Gr(e)?Te({},e):e:null}function Ht(e,t,n=!1,s=!1){const{props:o,ref:i,patchFlag:r,children:a,transition:l}=e,u=t?cc(o||{},t):o,c={__v_isVNode:!0,__v_skip:!0,type:e.type,props:u,key:u&&oa(u),ref:t&&t.ref?n&&i?X(i)?i.concat(ts(t)):[i,ts(t)]:ts(t):i,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:a,target:e.target,targetStart:e.targetStart,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==Ee?r===-1?16:r|16:r,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:l,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&Ht(e.ssContent),ssFallback:e.ssFallback&&Ht(e.ssFallback),placeholder:e.placeholder,el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return l&&s&&$n(c,l.clone(c)),c}function oo(e=" ",t=0){return ue(ks,null,e,t)}function Ze(e,t){const n=ue(es,null,e);return n.staticCount=t,n}function kt(e="",t=!1){return t?(le(),Ro(Fe,null,e)):ue(Fe,null,e)}function ft(e){return e==null||typeof e=="boolean"?ue(Fe):X(e)?ue(Ee,null,e.slice()):cs(e)?Lt(e):ue(ks,null,String(e))}function Lt(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:Ht(e)}function Ao(e,t){let n=0;const{shapeFlag:s}=e;if(t==null)t=null;else if(X(t))n=16;else if(typeof t=="object")if(s&65){const o=t.default;o&&(o._c&&(o._d=!1),Ao(e,o()),o._c&&(o._d=!0));return}else{n=32;const o=t._;!o&&!Gr(t)?t._ctx=et:o===3&&et&&(et.slots._===1?t._=1:(t._=2,e.patchFlag|=1024))}else Q(t)?(t={default:t,_ctx:et},n=32):(t=String(t),s&64?(n=16,t=[oo(t)]):n=8);e.children=t,e.shapeFlag|=n}function cc(...e){const t={};for(let n=0;n<e.length;n++){const s=e[n];for(const o in s)if(o==="class")t.class!==s.class&&(t.class=tn([t.class,s.class]));else if(o==="style")t.style=Oe([t.style,s.style]);else if(hs(o)){const i=t[o],r=s[o];r&&i!==r&&!(X(i)&&i.includes(r))&&(t[o]=i?[].concat(i,r):r)}else o!==""&&(t[o]=s[o])}return t}function dt(e,t,n,s=null){it(e,t,7,[n,s])}const uc=jr();let dc=0;function hc(e,t,n){const s=e.type,o=(t?t.appContext:e.appContext)||uc,i={uid:dc++,vnode:e,type:s,parent:t,appContext:o,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new Oa(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(o.provides),ids:t?t.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:Yr(s,o),emitsOptions:Ur(s,o),emit:null,emitted:null,propsDefaults:de,inheritAttrs:s.inheritAttrs,ctx:de,data:de,props:de,attrs:de,slots:de,refs:de,setupState:de,setupContext:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return i.ctx={_:i},i.root=t?t.root:i,i.emit=Vl.bind(null,i),e.ce&&e.ce(i),i}let He=null;const ia=()=>He||et;let us,io;{const e=gs(),t=(n,s)=>{let o;return(o=e[n])||(o=e[n]=[]),o.push(s),i=>{o.length>1?o.forEach(r=>r(i)):o[0](i)}};us=t("__VUE_INSTANCE_SETTERS__",n=>He=n),io=t("__VUE_SSR_SETTERS__",n=>Ln=n)}const Vn=e=>{const t=He;return us(e),e.scope.on(),()=>{e.scope.off(),us(t)}},ni=()=>{He&&He.scope.off(),us(null)};function ra(e){return e.vnode.shapeFlag&4}let Ln=!1;function fc(e,t=!1,n=!1){t&&io(t);const{props:s,children:o}=e.vnode,i=ra(e);Xl(e,s,i,t),Zl(e,o,n||t);const r=i?pc(e,t):void 0;return t&&io(!1),r}function pc(e,t){const n=e.type;e.accessCache=Object.create(null),e.proxy=new Proxy(e.ctx,Ml);const{setup:s}=n;if(s){Tt();const o=e.setupContext=s.length>1?mc(e):null,i=Vn(e),r=qn(s,e,0,[e.props,o]),a=Yi(r);if(Et(),i(),(a||e.sp)&&!En(e)&&Wr(e),a){if(r.then(ni,ni),t)return r.then(l=>{si(e,l)}).catch(l=>{bs(l,e,0)});e.asyncDep=r}else si(e,r)}else aa(e)}function si(e,t,n){Q(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:ge(t)&&(e.setupState=_r(t)),aa(e)}function aa(e,t,n){const s=e.type;e.render||(e.render=s.render||pt);{const o=Vn(e);Tt();try{$l(e)}finally{Et(),o()}}}const gc={get(e,t){return Pe(e,"get",""),e[t]}};function mc(e){const t=n=>{e.exposed=n||{}};return{attrs:new Proxy(e.attrs,gc),slots:e.slots,emit:e.emit,expose:t}}function xs(e){return e.exposed?e.exposeProxy||(e.exposeProxy=new Proxy(_r(ol(e.exposed)),{get(t,n){if(n in t)return t[n];if(n in An)return An[n](e)},has(t,n){return n in t||n in An}})):e.proxy}function vc(e){return Q(e)&&"__vccOpts"in e}const xe=(e,t)=>cl(e,t,Ln);function Po(e,t,n){try{ls(-1);const s=arguments.length;return s===2?ge(t)&&!X(t)?cs(t)?ue(e,null,[t]):ue(e,t):ue(e,null,t):(s>3?n=Array.prototype.slice.call(arguments,2):s===3&&cs(n)&&(n=[n]),ue(e,t,n))}finally{ls(1)}}const bc="3.5.27";let ro;const oi=typeof window<"u"&&window.trustedTypes;if(oi)try{ro=oi.createPolicy("vue",{createHTML:e=>e})}catch{}const la=ro?e=>ro.createHTML(e):e=>e,yc="http://www.w3.org/2000/svg",_c="http://www.w3.org/1998/Math/MathML",_t=typeof document<"u"?document:null,ii=_t&&_t.createElement("template"),wc={insert:(e,t,n)=>{t.insertBefore(e,n||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,n,s)=>{const o=t==="svg"?_t.createElementNS(yc,e):t==="mathml"?_t.createElementNS(_c,e):n?_t.createElement(e,{is:n}):_t.createElement(e);return e==="select"&&s&&s.multiple!=null&&o.setAttribute("multiple",s.multiple),o},createText:e=>_t.createTextNode(e),createComment:e=>_t.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>_t.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},insertStaticContent(e,t,n,s,o,i){const r=n?n.previousSibling:t.lastChild;if(o&&(o===i||o.nextSibling))for(;t.insertBefore(o.cloneNode(!0),n),!(o===i||!(o=o.nextSibling)););else{ii.innerHTML=la(s==="svg"?`<svg>${e}</svg>`:s==="mathml"?`<math>${e}</math>`:e);const a=ii.content;if(s==="svg"||s==="mathml"){const l=a.firstChild;for(;l.firstChild;)a.appendChild(l.firstChild);a.removeChild(l)}t.insertBefore(a,n)}return[r?r.nextSibling:t.firstChild,n?n.previousSibling:t.lastChild]}},Dt="transition",yn="animation",On=Symbol("_vtc"),ca={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},Cc=Te({},Mr,ca),Sc=e=>(e.displayName="Transition",e.props=Cc,e),kc=Sc((e,{slots:t})=>Po(Cl,xc(e),t)),zt=(e,t=[])=>{X(e)?e.forEach(n=>n(...t)):e&&e(...t)},ri=e=>e?X(e)?e.some(t=>t.length>1):e.length>1:!1;function xc(e){const t={};for(const V in e)V in ca||(t[V]=e[V]);if(e.css===!1)return t;const{name:n="v",type:s,duration:o,enterFromClass:i=`${n}-enter-from`,enterActiveClass:r=`${n}-enter-active`,enterToClass:a=`${n}-enter-to`,appearFromClass:l=i,appearActiveClass:u=r,appearToClass:c=a,leaveFromClass:h=`${n}-leave-from`,leaveActiveClass:p=`${n}-leave-active`,leaveToClass:g=`${n}-leave-to`}=e,y=Tc(o),_=y&&y[0],b=y&&y[1],{onBeforeEnter:w,onEnter:T,onEnterCancelled:N,onLeave:A,onLeaveCancelled:q,onBeforeAppear:O=w,onAppear:B=T,onAppearCancelled:j=N}=t,L=(V,ee,we,Re)=>{V._enterCancelled=Re,Kt(V,ee?c:a),Kt(V,ee?u:r),we&&we()},U=(V,ee)=>{V._isLeaving=!1,Kt(V,h),Kt(V,g),Kt(V,p),ee&&ee()},te=V=>(ee,we)=>{const Re=V?B:T,ve=()=>L(ee,V,we);zt(Re,[ee,ve]),ai(()=>{Kt(ee,V?l:i),bt(ee,V?c:a),ri(Re)||li(ee,s,_,ve)})};return Te(t,{onBeforeEnter(V){zt(w,[V]),bt(V,i),bt(V,r)},onBeforeAppear(V){zt(O,[V]),bt(V,l),bt(V,u)},onEnter:te(!1),onAppear:te(!0),onLeave(V,ee){V._isLeaving=!0;const we=()=>U(V,ee);bt(V,h),V._enterCancelled?(bt(V,p),di(V)):(di(V),bt(V,p)),ai(()=>{V._isLeaving&&(Kt(V,h),bt(V,g),ri(A)||li(V,s,b,we))}),zt(A,[V,we])},onEnterCancelled(V){L(V,!1,void 0,!0),zt(N,[V])},onAppearCancelled(V){L(V,!0,void 0,!0),zt(j,[V])},onLeaveCancelled(V){U(V),zt(q,[V])}})}function Tc(e){if(e==null)return null;if(ge(e))return[Ls(e.enter),Ls(e.leave)];{const t=Ls(e);return[t,t]}}function Ls(e){return Ia(e)}function bt(e,t){t.split(/\s+/).forEach(n=>n&&e.classList.add(n)),(e[On]||(e[On]=new Set)).add(t)}function Kt(e,t){t.split(/\s+/).forEach(s=>s&&e.classList.remove(s));const n=e[On];n&&(n.delete(t),n.size||(e[On]=void 0))}function ai(e){requestAnimationFrame(()=>{requestAnimationFrame(e)})}let Ec=0;function li(e,t,n,s){const o=e._endId=++Ec,i=()=>{o===e._endId&&s()};if(n!=null)return setTimeout(i,n);const{type:r,timeout:a,propCount:l}=Rc(e,t);if(!r)return s();const u=r+"end";let c=0;const h=()=>{e.removeEventListener(u,p),i()},p=g=>{g.target===e&&++c>=l&&h()};setTimeout(()=>{c<l&&h()},a+1),e.addEventListener(u,p)}function Rc(e,t){const n=window.getComputedStyle(e),s=y=>(n[y]||"").split(", "),o=s(`${Dt}Delay`),i=s(`${Dt}Duration`),r=ci(o,i),a=s(`${yn}Delay`),l=s(`${yn}Duration`),u=ci(a,l);let c=null,h=0,p=0;t===Dt?r>0&&(c=Dt,h=r,p=i.length):t===yn?u>0&&(c=yn,h=u,p=l.length):(h=Math.max(r,u),c=h>0?r>u?Dt:yn:null,p=c?c===Dt?i.length:l.length:0);const g=c===Dt&&/\b(?:transform|all)(?:,|$)/.test(s(`${Dt}Property`).toString());return{type:c,timeout:h,propCount:p,hasTransform:g}}function ci(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max(...t.map((n,s)=>ui(n)+ui(e[s])))}function ui(e){return e==="auto"?0:Number(e.slice(0,-1).replace(",","."))*1e3}function di(e){return(e?e.ownerDocument:document).body.offsetHeight}function Ac(e,t,n){const s=e[On];s&&(t=(t?[t,...s]:[...s]).join(" ")),t==null?e.removeAttribute("class"):n?e.setAttribute("class",t):e.className=t}const hi=Symbol("_vod"),Pc=Symbol("_vsh"),Ic=Symbol(""),Dc=/(?:^|;)\s*display\s*:/;function Nc(e,t,n){const s=e.style,o=_e(n);let i=!1;if(n&&!o){if(t)if(_e(t))for(const r of t.split(";")){const a=r.slice(0,r.indexOf(":")).trim();n[a]==null&&ns(s,a,"")}else for(const r in t)n[r]==null&&ns(s,r,"");for(const r in n)r==="display"&&(i=!0),ns(s,r,n[r])}else if(o){if(t!==n){const r=s[Ic];r&&(n+=";"+r),s.cssText=n,i=Dc.test(n)}}else t&&e.removeAttribute("style");hi in e&&(e[hi]=i?s.display:"",e[Pc]&&(s.display="none"))}const fi=/\s*!important$/;function ns(e,t,n){if(X(n))n.forEach(s=>ns(e,t,s));else if(n==null&&(n=""),t.startsWith("--"))e.setProperty(t,n);else{const s=Mc(e,t);fi.test(n)?e.setProperty(Vt(s),n.replace(fi,""),"important"):e[s]=n}}const pi=["Webkit","Moz","ms"],Os={};function Mc(e,t){const n=Os[t];if(n)return n;let s=Ft(t);if(s!=="filter"&&s in e)return Os[t]=s;s=Zi(s);for(let o=0;o<pi.length;o++){const i=pi[o]+s;if(i in e)return Os[t]=i}return t}const gi="http://www.w3.org/1999/xlink";function mi(e,t,n,s,o,i=La(t)){s&&t.startsWith("xlink:")?n==null?e.removeAttributeNS(gi,t.slice(6,t.length)):e.setAttributeNS(gi,t,n):n==null||i&&!tr(n)?e.removeAttribute(t):e.setAttribute(t,i?"":qt(n)?String(n):n)}function vi(e,t,n,s,o){if(t==="innerHTML"||t==="textContent"){n!=null&&(e[t]=t==="innerHTML"?la(n):n);return}const i=e.tagName;if(t==="value"&&i!=="PROGRESS"&&!i.includes("-")){const a=i==="OPTION"?e.getAttribute("value")||"":e.value,l=n==null?e.type==="checkbox"?"on":"":String(n);(a!==l||!("_value"in e))&&(e.value=l),n==null&&e.removeAttribute(t),e._value=n;return}let r=!1;if(n===""||n==null){const a=typeof e[t];a==="boolean"?n=tr(n):n==null&&a==="string"?(n="",r=!0):a==="number"&&(n=0,r=!0)}try{e[t]=n}catch{}r&&e.removeAttribute(o||t)}function an(e,t,n,s){e.addEventListener(t,n,s)}function $c(e,t,n,s){e.removeEventListener(t,n,s)}const bi=Symbol("_vei");function Bc(e,t,n,s,o=null){const i=e[bi]||(e[bi]={}),r=i[t];if(s&&r)r.value=s;else{const[a,l]=Lc(t);if(s){const u=i[t]=Fc(s,o);an(e,a,u,l)}else r&&($c(e,a,r,l),i[t]=void 0)}}const yi=/(?:Once|Passive|Capture)$/;function Lc(e){let t;if(yi.test(e)){t={};let s;for(;s=e.match(yi);)e=e.slice(0,e.length-s[0].length),t[s[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):Vt(e.slice(2)),t]}let Ws=0;const Oc=Promise.resolve(),Wc=()=>Ws||(Oc.then(()=>Ws=0),Ws=Date.now());function Fc(e,t){const n=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=n.attached)return;it(Hc(s,n.value),t,5,[s])};return n.value=e,n.attached=Wc(),n}function Hc(e,t){if(X(t)){const n=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{n.call(e),e._stopped=!0},t.map(s=>o=>!o._stopped&&s&&s(o))}else return t}const _i=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&e.charCodeAt(2)>96&&e.charCodeAt(2)<123,qc=(e,t,n,s,o,i)=>{const r=o==="svg";t==="class"?Ac(e,s,r):t==="style"?Nc(e,n,s):hs(t)?fo(t)||Bc(e,t,n,s,i):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):Vc(e,t,s,r))?(vi(e,t,s),!e.tagName.includes("-")&&(t==="value"||t==="checked"||t==="selected")&&mi(e,t,s,r,i,t!=="value")):e._isVueCE&&(/[A-Z]/.test(t)||!_e(s))?vi(e,Ft(t),s,i,t):(t==="true-value"?e._trueValue=s:t==="false-value"&&(e._falseValue=s),mi(e,t,s,r))};function Vc(e,t,n,s){if(s)return!!(t==="innerHTML"||t==="textContent"||t in e&&_i(t)&&Q(n));if(t==="spellcheck"||t==="draggable"||t==="translate"||t==="autocorrect"||t==="sandbox"&&e.tagName==="IFRAME"||t==="form"||t==="list"&&e.tagName==="INPUT"||t==="type"&&e.tagName==="TEXTAREA")return!1;if(t==="width"||t==="height"){const o=e.tagName;if(o==="IMG"||o==="VIDEO"||o==="CANVAS"||o==="SOURCE")return!1}return _i(t)&&_e(n)?!1:t in e}const wi=e=>{const t=e.props["onUpdate:modelValue"]||!1;return X(t)?n=>Yn(t,n):t};function jc(e){e.target.composing=!0}function Ci(e){const t=e.target;t.composing&&(t.composing=!1,t.dispatchEvent(new Event("input")))}const Fs=Symbol("_assign");function Si(e,t,n){return t&&(e=e.trim()),n&&(e=mo(e)),e}const Hs={created(e,{modifiers:{lazy:t,trim:n,number:s}},o){e[Fs]=wi(o);const i=s||o.props&&o.props.type==="number";an(e,t?"change":"input",r=>{r.target.composing||e[Fs](Si(e.value,n,i))}),(n||i)&&an(e,"change",()=>{e.value=Si(e.value,n,i)}),t||(an(e,"compositionstart",jc),an(e,"compositionend",Ci),an(e,"change",Ci))},mounted(e,{value:t}){e.value=t??""},beforeUpdate(e,{value:t,oldValue:n,modifiers:{lazy:s,trim:o,number:i}},r){if(e[Fs]=wi(r),e.composing)return;const a=(i||e.type==="number")&&!/^0\d/.test(e.value)?mo(e.value):e.value,l=t??"";a!==l&&(document.activeElement===e&&e.type!=="range"&&(s&&t===n||o&&e.value.trim()===l)||(e.value=l))}},Uc=["ctrl","shift","alt","meta"],zc={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&e.button!==0,middle:e=>"button"in e&&e.button!==1,right:e=>"button"in e&&e.button!==2,exact:(e,t)=>Uc.some(n=>e[`${n}Key`]&&!t.includes(n))},ki=(e,t)=>{const n=e._withMods||(e._withMods={}),s=t.join(".");return n[s]||(n[s]=((o,...i)=>{for(let r=0;r<t.length;r++){const a=zc[t[r]];if(a&&a(o,t))return}return e(o,...i)}))},Kc={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},xi=(e,t)=>{const n=e._withKeys||(e._withKeys={}),s=t.join(".");return n[s]||(n[s]=(o=>{if(!("key"in o))return;const i=Vt(o.key);if(t.some(r=>r===i||Kc[r]===i))return e(o)}))},Gc=Te({patchProp:qc},wc);let Ti;function Xc(){return Ti||(Ti=tc(Gc))}const Yc=((...e)=>{const t=Xc().createApp(...e),{mount:n}=t;return t.mount=s=>{const o=Qc(s);if(!o)return;const i=t._component;!Q(i)&&!i.render&&!i.template&&(i.template=o.innerHTML),o.nodeType===1&&(o.textContent="");const r=n(o,!1,Jc(o));return o instanceof Element&&(o.removeAttribute("v-cloak"),o.setAttribute("data-v-app","")),r},t});function Jc(e){if(e instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&e instanceof MathMLElement)return"mathml"}function Qc(e){return _e(e)?document.querySelector(e):e}const ln=typeof document<"u";function ua(e){return typeof e=="object"||"displayName"in e||"props"in e||"__vccOpts"in e}function Zc(e){return e.__esModule||e[Symbol.toStringTag]==="Module"||e.default&&ua(e.default)}const ie=Object.assign;function qs(e,t){const n={};for(const s in t){const o=t[s];n[s]=rt(o)?o.map(e):e(o)}return n}const In=()=>{},rt=Array.isArray;function Ei(e,t){const n={};for(const s in e)n[s]=s in t?t[s]:e[s];return n}let ye=(function(e){return e[e.MATCHER_NOT_FOUND=1]="MATCHER_NOT_FOUND",e[e.NAVIGATION_GUARD_REDIRECT=2]="NAVIGATION_GUARD_REDIRECT",e[e.NAVIGATION_ABORTED=4]="NAVIGATION_ABORTED",e[e.NAVIGATION_CANCELLED=8]="NAVIGATION_CANCELLED",e[e.NAVIGATION_DUPLICATED=16]="NAVIGATION_DUPLICATED",e})({});const da=Symbol("");ye.MATCHER_NOT_FOUND+"",ye.NAVIGATION_GUARD_REDIRECT+"",ye.NAVIGATION_ABORTED+"",ye.NAVIGATION_CANCELLED+"",ye.NAVIGATION_DUPLICATED+"";function pn(e,t){return ie(new Error,{type:e,[da]:!0},t)}function yt(e,t){return e instanceof Error&&da in e&&(t==null||!!(e.type&t))}const eu=["params","query","hash"];function tu(e){if(typeof e=="string")return e;if(e.path!=null)return e.path;const t={};for(const n of eu)n in e&&(t[n]=e[n]);return JSON.stringify(t,null,2)}const nu=Symbol(""),Ri=Symbol(""),Io=Symbol(""),ha=Symbol(""),ao=Symbol("");const fa=/#/g,su=/&/g,ou=/\//g,iu=/=/g,ru=/\?/g,pa=/\+/g,au=/%5B/g,lu=/%5D/g,ga=/%5E/g,cu=/%60/g,ma=/%7B/g,uu=/%7C/g,va=/%7D/g,du=/%20/g;function Do(e){return e==null?"":encodeURI(""+e).replace(uu,"|").replace(au,"[").replace(lu,"]")}function hu(e){return Do(e).replace(ma,"{").replace(va,"}").replace(ga,"^")}function lo(e){return Do(e).replace(pa,"%2B").replace(du,"+").replace(fa,"%23").replace(su,"%26").replace(cu,"`").replace(ma,"{").replace(va,"}").replace(ga,"^")}function fu(e){return lo(e).replace(iu,"%3D")}function pu(e){return Do(e).replace(fa,"%23").replace(ru,"%3F")}function gu(e){return pu(e).replace(ou,"%2F")}function Wn(e){if(e==null)return null;try{return decodeURIComponent(""+e)}catch{}return""+e}const mu=/\/$/,vu=e=>e.replace(mu,"");function Vs(e,t,n="/"){let s,o={},i="",r="";const a=t.indexOf("#");let l=t.indexOf("?");return l=a>=0&&l>a?-1:l,l>=0&&(s=t.slice(0,l),i=t.slice(l,a>0?a:t.length),o=e(i.slice(1))),a>=0&&(s=s||t.slice(0,a),r=t.slice(a,t.length)),s=wu(s??t,n),{fullPath:s+i+r,path:s,query:o,hash:Wn(r)}}function bu(e,t){const n=t.query?e(t.query):"";return t.path+(n&&"?")+n+(t.hash||"")}function Ai(e,t){return!t||!e.toLowerCase().startsWith(t.toLowerCase())?e:e.slice(t.length)||"/"}function yu(e,t,n){const s=t.matched.length-1,o=n.matched.length-1;return s>-1&&s===o&&gn(t.matched[s],n.matched[o])&&ba(t.params,n.params)&&e(t.query)===e(n.query)&&t.hash===n.hash}function gn(e,t){return(e.aliasOf||e)===(t.aliasOf||t)}function ba(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(var n in e)if(!_u(e[n],t[n]))return!1;return!0}function _u(e,t){return rt(e)?Pi(e,t):rt(t)?Pi(t,e):(e&&e.valueOf())===(t&&t.valueOf())}function Pi(e,t){return rt(t)?e.length===t.length&&e.every((n,s)=>n===t[s]):e.length===1&&e[0]===t}function wu(e,t){if(e.startsWith("/"))return e;if(!e)return t;const n=t.split("/"),s=e.split("/"),o=s[s.length-1];(o===".."||o===".")&&s.push("");let i=n.length-1,r,a;for(r=0;r<s.length;r++)if(a=s[r],a!==".")if(a==="..")i>1&&i--;else break;return n.slice(0,i).join("/")+"/"+s.slice(r).join("/")}const Nt={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0};let co=(function(e){return e.pop="pop",e.push="push",e})({}),js=(function(e){return e.back="back",e.forward="forward",e.unknown="",e})({});function Cu(e){if(!e)if(ln){const t=document.querySelector("base");e=t&&t.getAttribute("href")||"/",e=e.replace(/^\w+:\/\/[^\/]+/,"")}else e="/";return e[0]!=="/"&&e[0]!=="#"&&(e="/"+e),vu(e)}const Su=/^[^#]+#/;function ku(e,t){return e.replace(Su,"#")+t}function xu(e,t){const n=document.documentElement.getBoundingClientRect(),s=e.getBoundingClientRect();return{behavior:t.behavior,left:s.left-n.left-(t.left||0),top:s.top-n.top-(t.top||0)}}const Ts=()=>({left:window.scrollX,top:window.scrollY});function Tu(e){let t;if("el"in e){const n=e.el,s=typeof n=="string"&&n.startsWith("#"),o=typeof n=="string"?s?document.getElementById(n.slice(1)):document.querySelector(n):n;if(!o)return;t=xu(o,e)}else t=e;"scrollBehavior"in document.documentElement.style?window.scrollTo(t):window.scrollTo(t.left!=null?t.left:window.scrollX,t.top!=null?t.top:window.scrollY)}function Ii(e,t){return(history.state?history.state.position-t:-1)+e}const uo=new Map;function Eu(e,t){uo.set(e,t)}function Ru(e){const t=uo.get(e);return uo.delete(e),t}function Au(e){return typeof e=="string"||e&&typeof e=="object"}function ya(e){return typeof e=="string"||typeof e=="symbol"}function Pu(e){const t={};if(e===""||e==="?")return t;const n=(e[0]==="?"?e.slice(1):e).split("&");for(let s=0;s<n.length;++s){const o=n[s].replace(pa," "),i=o.indexOf("="),r=Wn(i<0?o:o.slice(0,i)),a=i<0?null:Wn(o.slice(i+1));if(r in t){let l=t[r];rt(l)||(l=t[r]=[l]),l.push(a)}else t[r]=a}return t}function Di(e){let t="";for(let n in e){const s=e[n];if(n=fu(n),s==null){s!==void 0&&(t+=(t.length?"&":"")+n);continue}(rt(s)?s.map(o=>o&&lo(o)):[s&&lo(s)]).forEach(o=>{o!==void 0&&(t+=(t.length?"&":"")+n,o!=null&&(t+="="+o))})}return t}function Iu(e){const t={};for(const n in e){const s=e[n];s!==void 0&&(t[n]=rt(s)?s.map(o=>o==null?null:""+o):s==null?s:""+s)}return t}function _n(){let e=[];function t(s){return e.push(s),()=>{const o=e.indexOf(s);o>-1&&e.splice(o,1)}}function n(){e=[]}return{add:t,list:()=>e.slice(),reset:n}}function Ot(e,t,n,s,o,i=r=>r()){const r=s&&(s.enterCallbacks[o]=s.enterCallbacks[o]||[]);return()=>new Promise((a,l)=>{const u=p=>{p===!1?l(pn(ye.NAVIGATION_ABORTED,{from:n,to:t})):p instanceof Error?l(p):Au(p)?l(pn(ye.NAVIGATION_GUARD_REDIRECT,{from:t,to:p})):(r&&s.enterCallbacks[o]===r&&typeof p=="function"&&r.push(p),a())},c=i(()=>e.call(s&&s.instances[o],t,n,u));let h=Promise.resolve(c);e.length<3&&(h=h.then(u)),h.catch(p=>l(p))})}function Us(e,t,n,s,o=i=>i()){const i=[];for(const r of e)for(const a in r.components){let l=r.components[a];if(!(t!=="beforeRouteEnter"&&!r.instances[a]))if(ua(l)){const u=(l.__vccOpts||l)[t];u&&i.push(Ot(u,n,s,r,a,o))}else{let u=l();i.push(()=>u.then(c=>{if(!c)throw new Error(`Couldn't resolve component "${a}" at "${r.path}"`);const h=Zc(c)?c.default:c;r.mods[a]=c,r.components[a]=h;const p=(h.__vccOpts||h)[t];return p&&Ot(p,n,s,r,a,o)()}))}}return i}function Du(e,t){const n=[],s=[],o=[],i=Math.max(t.matched.length,e.matched.length);for(let r=0;r<i;r++){const a=t.matched[r];a&&(e.matched.find(u=>gn(u,a))?s.push(a):n.push(a));const l=e.matched[r];l&&(t.matched.find(u=>gn(u,l))||o.push(l))}return[n,s,o]}let Nu=()=>location.protocol+"//"+location.host;function _a(e,t){const{pathname:n,search:s,hash:o}=t,i=e.indexOf("#");if(i>-1){let r=o.includes(e.slice(i))?e.slice(i).length:1,a=o.slice(r);return a[0]!=="/"&&(a="/"+a),Ai(a,"")}return Ai(n,e)+s+o}function Mu(e,t,n,s){let o=[],i=[],r=null;const a=({state:p})=>{const g=_a(e,location),y=n.value,_=t.value;let b=0;if(p){if(n.value=g,t.value=p,r&&r===y){r=null;return}b=_?p.position-_.position:0}else s(g);o.forEach(w=>{w(n.value,y,{delta:b,type:co.pop,direction:b?b>0?js.forward:js.back:js.unknown})})};function l(){r=n.value}function u(p){o.push(p);const g=()=>{const y=o.indexOf(p);y>-1&&o.splice(y,1)};return i.push(g),g}function c(){if(document.visibilityState==="hidden"){const{history:p}=window;if(!p.state)return;p.replaceState(ie({},p.state,{scroll:Ts()}),"")}}function h(){for(const p of i)p();i=[],window.removeEventListener("popstate",a),window.removeEventListener("pagehide",c),document.removeEventListener("visibilitychange",c)}return window.addEventListener("popstate",a),window.addEventListener("pagehide",c),document.addEventListener("visibilitychange",c),{pauseListeners:l,listen:u,destroy:h}}function Ni(e,t,n,s=!1,o=!1){return{back:e,current:t,forward:n,replaced:s,position:window.history.length,scroll:o?Ts():null}}function $u(e){const{history:t,location:n}=window,s={value:_a(e,n)},o={value:t.state};o.value||i(s.value,{back:null,current:s.value,forward:null,position:t.length-1,replaced:!0,scroll:null},!0);function i(l,u,c){const h=e.indexOf("#"),p=h>-1?(n.host&&document.querySelector("base")?e:e.slice(h))+l:Nu()+e+l;try{t[c?"replaceState":"pushState"](u,"",p),o.value=u}catch(g){console.error(g),n[c?"replace":"assign"](p)}}function r(l,u){i(l,ie({},t.state,Ni(o.value.back,l,o.value.forward,!0),u,{position:o.value.position}),!0),s.value=l}function a(l,u){const c=ie({},o.value,t.state,{forward:l,scroll:Ts()});i(c.current,c,!0),i(l,ie({},Ni(s.value,l,null),{position:c.position+1},u),!1),s.value=l}return{location:s,state:o,push:a,replace:r}}function Bu(e){e=Cu(e);const t=$u(e),n=Mu(e,t.state,t.location,t.replace);function s(i,r=!0){r||n.pauseListeners(),history.go(i)}const o=ie({location:"",base:e,go:s,createHref:ku.bind(null,e)},t,n);return Object.defineProperty(o,"location",{enumerable:!0,get:()=>t.location.value}),Object.defineProperty(o,"state",{enumerable:!0,get:()=>t.state.value}),o}let Yt=(function(e){return e[e.Static=0]="Static",e[e.Param=1]="Param",e[e.Group=2]="Group",e})({});var Se=(function(e){return e[e.Static=0]="Static",e[e.Param=1]="Param",e[e.ParamRegExp=2]="ParamRegExp",e[e.ParamRegExpEnd=3]="ParamRegExpEnd",e[e.EscapeNext=4]="EscapeNext",e})(Se||{});const Lu={type:Yt.Static,value:""},Ou=/[a-zA-Z0-9_]/;function Wu(e){if(!e)return[[]];if(e==="/")return[[Lu]];if(!e.startsWith("/"))throw new Error(`Invalid path "${e}"`);function t(g){throw new Error(`ERR (${n})/"${u}": ${g}`)}let n=Se.Static,s=n;const o=[];let i;function r(){i&&o.push(i),i=[]}let a=0,l,u="",c="";function h(){u&&(n===Se.Static?i.push({type:Yt.Static,value:u}):n===Se.Param||n===Se.ParamRegExp||n===Se.ParamRegExpEnd?(i.length>1&&(l==="*"||l==="+")&&t(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),i.push({type:Yt.Param,value:u,regexp:c,repeatable:l==="*"||l==="+",optional:l==="*"||l==="?"})):t("Invalid state to consume buffer"),u="")}function p(){u+=l}for(;a<e.length;){if(l=e[a++],l==="\\"&&n!==Se.ParamRegExp){s=n,n=Se.EscapeNext;continue}switch(n){case Se.Static:l==="/"?(u&&h(),r()):l===":"?(h(),n=Se.Param):p();break;case Se.EscapeNext:p(),n=s;break;case Se.Param:l==="("?n=Se.ParamRegExp:Ou.test(l)?p():(h(),n=Se.Static,l!=="*"&&l!=="?"&&l!=="+"&&a--);break;case Se.ParamRegExp:l===")"?c[c.length-1]=="\\"?c=c.slice(0,-1)+l:n=Se.ParamRegExpEnd:c+=l;break;case Se.ParamRegExpEnd:h(),n=Se.Static,l!=="*"&&l!=="?"&&l!=="+"&&a--,c="";break;default:t("Unknown state");break}}return n===Se.ParamRegExp&&t(`Unfinished custom RegExp for param "${u}"`),h(),r(),o}const Mi="[^/]+?",Fu={sensitive:!1,strict:!1,start:!0,end:!0};var $e=(function(e){return e[e._multiplier=10]="_multiplier",e[e.Root=90]="Root",e[e.Segment=40]="Segment",e[e.SubSegment=30]="SubSegment",e[e.Static=40]="Static",e[e.Dynamic=20]="Dynamic",e[e.BonusCustomRegExp=10]="BonusCustomRegExp",e[e.BonusWildcard=-50]="BonusWildcard",e[e.BonusRepeatable=-20]="BonusRepeatable",e[e.BonusOptional=-8]="BonusOptional",e[e.BonusStrict=.7000000000000001]="BonusStrict",e[e.BonusCaseSensitive=.25]="BonusCaseSensitive",e})($e||{});const Hu=/[.+*?^${}()[\]/\\]/g;function qu(e,t){const n=ie({},Fu,t),s=[];let o=n.start?"^":"";const i=[];for(const u of e){const c=u.length?[]:[$e.Root];n.strict&&!u.length&&(o+="/");for(let h=0;h<u.length;h++){const p=u[h];let g=$e.Segment+(n.sensitive?$e.BonusCaseSensitive:0);if(p.type===Yt.Static)h||(o+="/"),o+=p.value.replace(Hu,"\\$&"),g+=$e.Static;else if(p.type===Yt.Param){const{value:y,repeatable:_,optional:b,regexp:w}=p;i.push({name:y,repeatable:_,optional:b});const T=w||Mi;if(T!==Mi){g+=$e.BonusCustomRegExp;try{new RegExp(`(${T})`)}catch(A){throw new Error(`Invalid custom RegExp for param "${y}" (${T}): `+A.message)}}let N=_?`((?:${T})(?:/(?:${T}))*)`:`(${T})`;h||(N=b&&u.length<2?`(?:/${N})`:"/"+N),b&&(N+="?"),o+=N,g+=$e.Dynamic,b&&(g+=$e.BonusOptional),_&&(g+=$e.BonusRepeatable),T===".*"&&(g+=$e.BonusWildcard)}c.push(g)}s.push(c)}if(n.strict&&n.end){const u=s.length-1;s[u][s[u].length-1]+=$e.BonusStrict}n.strict||(o+="/?"),n.end?o+="$":n.strict&&!o.endsWith("/")&&(o+="(?:/|$)");const r=new RegExp(o,n.sensitive?"":"i");function a(u){const c=u.match(r),h={};if(!c)return null;for(let p=1;p<c.length;p++){const g=c[p]||"",y=i[p-1];h[y.name]=g&&y.repeatable?g.split("/"):g}return h}function l(u){let c="",h=!1;for(const p of e){(!h||!c.endsWith("/"))&&(c+="/"),h=!1;for(const g of p)if(g.type===Yt.Static)c+=g.value;else if(g.type===Yt.Param){const{value:y,repeatable:_,optional:b}=g,w=y in u?u[y]:"";if(rt(w)&&!_)throw new Error(`Provided param "${y}" is an array but it is not repeatable (* or + modifiers)`);const T=rt(w)?w.join("/"):w;if(!T)if(b)p.length<2&&(c.endsWith("/")?c=c.slice(0,-1):h=!0);else throw new Error(`Missing required param "${y}"`);c+=T}}return c||"/"}return{re:r,score:s,keys:i,parse:a,stringify:l}}function Vu(e,t){let n=0;for(;n<e.length&&n<t.length;){const s=t[n]-e[n];if(s)return s;n++}return e.length<t.length?e.length===1&&e[0]===$e.Static+$e.Segment?-1:1:e.length>t.length?t.length===1&&t[0]===$e.Static+$e.Segment?1:-1:0}function wa(e,t){let n=0;const s=e.score,o=t.score;for(;n<s.length&&n<o.length;){const i=Vu(s[n],o[n]);if(i)return i;n++}if(Math.abs(o.length-s.length)===1){if($i(s))return 1;if($i(o))return-1}return o.length-s.length}function $i(e){const t=e[e.length-1];return e.length>0&&t[t.length-1]<0}const ju={strict:!1,end:!0,sensitive:!1};function Uu(e,t,n){const s=qu(Wu(e.path),n),o=ie(s,{record:e,parent:t,children:[],alias:[]});return t&&!o.record.aliasOf==!t.record.aliasOf&&t.children.push(o),o}function zu(e,t){const n=[],s=new Map;t=Ei(ju,t);function o(h){return s.get(h)}function i(h,p,g){const y=!g,_=Li(h);_.aliasOf=g&&g.record;const b=Ei(t,h),w=[_];if("alias"in h){const A=typeof h.alias=="string"?[h.alias]:h.alias;for(const q of A)w.push(Li(ie({},_,{components:g?g.record.components:_.components,path:q,aliasOf:g?g.record:_})))}let T,N;for(const A of w){const{path:q}=A;if(p&&q[0]!=="/"){const O=p.record.path,B=O[O.length-1]==="/"?"":"/";A.path=p.record.path+(q&&B+q)}if(T=Uu(A,p,b),g?g.alias.push(T):(N=N||T,N!==T&&N.alias.push(T),y&&h.name&&!Oi(T)&&r(h.name)),Ca(T)&&l(T),_.children){const O=_.children;for(let B=0;B<O.length;B++)i(O[B],T,g&&g.children[B])}g=g||T}return N?()=>{r(N)}:In}function r(h){if(ya(h)){const p=s.get(h);p&&(s.delete(h),n.splice(n.indexOf(p),1),p.children.forEach(r),p.alias.forEach(r))}else{const p=n.indexOf(h);p>-1&&(n.splice(p,1),h.record.name&&s.delete(h.record.name),h.children.forEach(r),h.alias.forEach(r))}}function a(){return n}function l(h){const p=Xu(h,n);n.splice(p,0,h),h.record.name&&!Oi(h)&&s.set(h.record.name,h)}function u(h,p){let g,y={},_,b;if("name"in h&&h.name){if(g=s.get(h.name),!g)throw pn(ye.MATCHER_NOT_FOUND,{location:h});b=g.record.name,y=ie(Bi(p.params,g.keys.filter(N=>!N.optional).concat(g.parent?g.parent.keys.filter(N=>N.optional):[]).map(N=>N.name)),h.params&&Bi(h.params,g.keys.map(N=>N.name))),_=g.stringify(y)}else if(h.path!=null)_=h.path,g=n.find(N=>N.re.test(_)),g&&(y=g.parse(_),b=g.record.name);else{if(g=p.name?s.get(p.name):n.find(N=>N.re.test(p.path)),!g)throw pn(ye.MATCHER_NOT_FOUND,{location:h,currentLocation:p});b=g.record.name,y=ie({},p.params,h.params),_=g.stringify(y)}const w=[];let T=g;for(;T;)w.unshift(T.record),T=T.parent;return{name:b,path:_,params:y,matched:w,meta:Gu(w)}}e.forEach(h=>i(h));function c(){n.length=0,s.clear()}return{addRoute:i,resolve:u,removeRoute:r,clearRoutes:c,getRoutes:a,getRecordMatcher:o}}function Bi(e,t){const n={};for(const s of t)s in e&&(n[s]=e[s]);return n}function Li(e){const t={path:e.path,redirect:e.redirect,name:e.name,meta:e.meta||{},aliasOf:e.aliasOf,beforeEnter:e.beforeEnter,props:Ku(e),children:e.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in e?e.components||null:e.component&&{default:e.component}};return Object.defineProperty(t,"mods",{value:{}}),t}function Ku(e){const t={},n=e.props||!1;if("component"in e)t.default=n;else for(const s in e.components)t[s]=typeof n=="object"?n[s]:n;return t}function Oi(e){for(;e;){if(e.record.aliasOf)return!0;e=e.parent}return!1}function Gu(e){return e.reduce((t,n)=>ie(t,n.meta),{})}function Xu(e,t){let n=0,s=t.length;for(;n!==s;){const i=n+s>>1;wa(e,t[i])<0?s=i:n=i+1}const o=Yu(e);return o&&(s=t.lastIndexOf(o,s-1)),s}function Yu(e){let t=e;for(;t=t.parent;)if(Ca(t)&&wa(e,t)===0)return t}function Ca({record:e}){return!!(e.name||e.components&&Object.keys(e.components).length||e.redirect)}function Wi(e){const t=xt(Io),n=xt(ha),s=xe(()=>{const l=Le(e.to);return t.resolve(l)}),o=xe(()=>{const{matched:l}=s.value,{length:u}=l,c=l[u-1],h=n.matched;if(!c||!h.length)return-1;const p=h.findIndex(gn.bind(null,c));if(p>-1)return p;const g=Fi(l[u-2]);return u>1&&Fi(c)===g&&h[h.length-1].path!==g?h.findIndex(gn.bind(null,l[u-2])):p}),i=xe(()=>o.value>-1&&td(n.params,s.value.params)),r=xe(()=>o.value>-1&&o.value===n.matched.length-1&&ba(n.params,s.value.params));function a(l={}){if(ed(l)){const u=t[Le(e.replace)?"replace":"push"](Le(e.to)).catch(In);return e.viewTransition&&typeof document<"u"&&"startViewTransition"in document&&document.startViewTransition(()=>u),u}return Promise.resolve()}return{route:s,href:xe(()=>s.value.href),isActive:i,isExactActive:r,navigate:a}}function Ju(e){return e.length===1?e[0]:e}const Qu=gt({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"},viewTransition:Boolean},useLink:Wi,setup(e,{slots:t}){const n=vs(Wi(e)),{options:s}=xt(Io),o=xe(()=>({[Hi(e.activeClass,s.linkActiveClass,"router-link-active")]:n.isActive,[Hi(e.exactActiveClass,s.linkExactActiveClass,"router-link-exact-active")]:n.isExactActive}));return()=>{const i=t.default&&Ju(t.default(n));return e.custom?i:Po("a",{"aria-current":n.isExactActive?e.ariaCurrentValue:null,href:n.href,onClick:n.navigate,class:o.value},i)}}}),Zu=Qu;function ed(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)&&!e.defaultPrevented&&!(e.button!==void 0&&e.button!==0)){if(e.currentTarget&&e.currentTarget.getAttribute){const t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function td(e,t){for(const n in t){const s=t[n],o=e[n];if(typeof s=="string"){if(s!==o)return!1}else if(!rt(o)||o.length!==s.length||s.some((i,r)=>i.valueOf()!==o[r].valueOf()))return!1}return!0}function Fi(e){return e?e.aliasOf?e.aliasOf.path:e.path:""}const Hi=(e,t,n)=>e??t??n,nd=gt({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(e,{attrs:t,slots:n}){const s=xt(ao),o=xe(()=>e.route||s.value),i=xt(Ri,0),r=xe(()=>{let u=Le(i);const{matched:c}=o.value;let h;for(;(h=c[u])&&!h.components;)u++;return u}),a=xe(()=>o.value.matched[r.value]);Jn(Ri,xe(()=>r.value+1)),Jn(nu,a),Jn(ao,o);const l=ce();return Qn(()=>[l.value,a.value,e.name],([u,c,h],[p,g,y])=>{c&&(c.instances[h]=u,g&&g!==c&&u&&u===p&&(c.leaveGuards.size||(c.leaveGuards=g.leaveGuards),c.updateGuards.size||(c.updateGuards=g.updateGuards))),u&&c&&(!g||!gn(c,g)||!p)&&(c.enterCallbacks[h]||[]).forEach(_=>_(u))},{flush:"post"}),()=>{const u=o.value,c=e.name,h=a.value,p=h&&h.components[c];if(!p)return qi(n.default,{Component:p,route:u});const g=h.props[c],y=g?g===!0?u.params:typeof g=="function"?g(u):g:null,b=Po(p,ie({},y,t,{onVnodeUnmounted:w=>{w.component.isUnmounted&&(h.instances[c]=null)},ref:l}));return qi(n.default,{Component:b,route:u})||b}}});function qi(e,t){if(!e)return null;const n=e(t);return n.length===1?n[0]:n}const Sa=nd;function sd(e){const t=zu(e.routes,e),n=e.parseQuery||Pu,s=e.stringifyQuery||Di,o=e.history,i=_n(),r=_n(),a=_n(),l=il(Nt);let u=Nt;ln&&e.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const c=qs.bind(null,v=>""+v),h=qs.bind(null,gu),p=qs.bind(null,Wn);function g(v,R){let I,W;return ya(v)?(I=t.getRecordMatcher(v),W=R):W=v,t.addRoute(W,I)}function y(v){const R=t.getRecordMatcher(v);R&&t.removeRoute(R)}function _(){return t.getRoutes().map(v=>v.record)}function b(v){return!!t.getRecordMatcher(v)}function w(v,R){if(R=ie({},R||l.value),typeof v=="string"){const m=Vs(n,v,R.path),k=t.resolve({path:m.path},R),E=o.createHref(m.fullPath);return ie(m,k,{params:p(k.params),hash:Wn(m.hash),redirectedFrom:void 0,href:E})}let I;if(v.path!=null)I=ie({},v,{path:Vs(n,v.path,R.path).path});else{const m=ie({},v.params);for(const k in m)m[k]==null&&delete m[k];I=ie({},v,{params:h(m)}),R.params=h(R.params)}const W=t.resolve(I,R),K=v.hash||"";W.params=c(p(W.params));const d=bu(s,ie({},v,{hash:hu(K),path:W.path})),f=o.createHref(d);return ie({fullPath:d,hash:K,query:s===Di?Iu(v.query):v.query||{}},W,{redirectedFrom:void 0,href:f})}function T(v){return typeof v=="string"?Vs(n,v,l.value.path):ie({},v)}function N(v,R){if(u!==v)return pn(ye.NAVIGATION_CANCELLED,{from:R,to:v})}function A(v){return B(v)}function q(v){return A(ie(T(v),{replace:!0}))}function O(v,R){const I=v.matched[v.matched.length-1];if(I&&I.redirect){const{redirect:W}=I;let K=typeof W=="function"?W(v,R):W;return typeof K=="string"&&(K=K.includes("?")||K.includes("#")?K=T(K):{path:K},K.params={}),ie({query:v.query,hash:v.hash,params:K.path!=null?{}:v.params},K)}}function B(v,R){const I=u=w(v),W=l.value,K=v.state,d=v.force,f=v.replace===!0,m=O(I,W);if(m)return B(ie(T(m),{state:typeof m=="object"?ie({},K,m.state):K,force:d,replace:f}),R||I);const k=I;k.redirectedFrom=R;let E;return!d&&yu(s,W,I)&&(E=pn(ye.NAVIGATION_DUPLICATED,{to:k,from:W}),Xe(W,W,!0,!1)),(E?Promise.resolve(E):U(k,W)).catch(x=>yt(x)?yt(x,ye.NAVIGATION_GUARD_REDIRECT)?x:at(x):ne(x,k,W)).then(x=>{if(x){if(yt(x,ye.NAVIGATION_GUARD_REDIRECT))return B(ie({replace:f},T(x.to),{state:typeof x.to=="object"?ie({},K,x.to.state):K,force:d}),R||k)}else x=V(k,W,!0,f,K);return te(k,W,x),x})}function j(v,R){const I=N(v,R);return I?Promise.reject(I):Promise.resolve()}function L(v){const R=It.values().next().value;return R&&typeof R.runWithContext=="function"?R.runWithContext(v):v()}function U(v,R){let I;const[W,K,d]=Du(v,R);I=Us(W.reverse(),"beforeRouteLeave",v,R);for(const m of W)m.leaveGuards.forEach(k=>{I.push(Ot(k,v,R))});const f=j.bind(null,v,R);return I.push(f),D(I).then(()=>{I=[];for(const m of i.list())I.push(Ot(m,v,R));return I.push(f),D(I)}).then(()=>{I=Us(K,"beforeRouteUpdate",v,R);for(const m of K)m.updateGuards.forEach(k=>{I.push(Ot(k,v,R))});return I.push(f),D(I)}).then(()=>{I=[];for(const m of d)if(m.beforeEnter)if(rt(m.beforeEnter))for(const k of m.beforeEnter)I.push(Ot(k,v,R));else I.push(Ot(m.beforeEnter,v,R));return I.push(f),D(I)}).then(()=>(v.matched.forEach(m=>m.enterCallbacks={}),I=Us(d,"beforeRouteEnter",v,R,L),I.push(f),D(I))).then(()=>{I=[];for(const m of r.list())I.push(Ot(m,v,R));return I.push(f),D(I)}).catch(m=>yt(m,ye.NAVIGATION_CANCELLED)?m:Promise.reject(m))}function te(v,R,I){a.list().forEach(W=>L(()=>W(v,R,I)))}function V(v,R,I,W,K){const d=N(v,R);if(d)return d;const f=R===Nt,m=ln?history.state:{};I&&(W||f?o.replace(v.fullPath,ie({scroll:f&&m&&m.scroll},K)):o.push(v.fullPath,K)),l.value=v,Xe(v,R,I,f),at()}let ee;function we(){ee||(ee=o.listen((v,R,I)=>{if(!mt.listening)return;const W=w(v),K=O(W,mt.currentRoute.value);if(K){B(ie(K,{replace:!0,force:!0}),W).catch(In);return}u=W;const d=l.value;ln&&Eu(Ii(d.fullPath,I.delta),Ts()),U(W,d).catch(f=>yt(f,ye.NAVIGATION_ABORTED|ye.NAVIGATION_CANCELLED)?f:yt(f,ye.NAVIGATION_GUARD_REDIRECT)?(B(ie(T(f.to),{force:!0}),W).then(m=>{yt(m,ye.NAVIGATION_ABORTED|ye.NAVIGATION_DUPLICATED)&&!I.delta&&I.type===co.pop&&o.go(-1,!1)}).catch(In),Promise.reject()):(I.delta&&o.go(-I.delta,!1),ne(f,W,d))).then(f=>{f=f||V(W,d,!1),f&&(I.delta&&!yt(f,ye.NAVIGATION_CANCELLED)?o.go(-I.delta,!1):I.type===co.pop&&yt(f,ye.NAVIGATION_ABORTED|ye.NAVIGATION_DUPLICATED)&&o.go(-1,!1)),te(W,d,f)}).catch(In)}))}let Re=_n(),ve=_n(),oe;function ne(v,R,I){at(v);const W=ve.list();return W.length?W.forEach(K=>K(v,R,I)):console.error(v),Promise.reject(v)}function Ge(){return oe&&l.value!==Nt?Promise.resolve():new Promise((v,R)=>{Re.add([v,R])})}function at(v){return oe||(oe=!v,we(),Re.list().forEach(([R,I])=>v?I(v):R()),Re.reset()),v}function Xe(v,R,I,W){const{scrollBehavior:K}=e;if(!ln||!K)return Promise.resolve();const d=!I&&Ru(Ii(v.fullPath,0))||(W||!I)&&history.state&&history.state.scroll||null;return Cr().then(()=>K(v,R,d)).then(f=>f&&Tu(f)).catch(f=>ne(f,v,R))}const Ae=v=>o.go(v);let Pt;const It=new Set,mt={currentRoute:l,listening:!0,addRoute:g,removeRoute:y,clearRoutes:t.clearRoutes,hasRoute:b,getRoutes:_,resolve:w,options:e,push:A,replace:q,go:Ae,back:()=>Ae(-1),forward:()=>Ae(1),beforeEach:i.add,beforeResolve:r.add,afterEach:a.add,onError:ve.add,isReady:Ge,install(v){v.component("RouterLink",Zu),v.component("RouterView",Sa),v.config.globalProperties.$router=mt,Object.defineProperty(v.config.globalProperties,"$route",{enumerable:!0,get:()=>Le(l)}),ln&&!Pt&&l.value===Nt&&(Pt=!0,A(o.location).catch(W=>{}));const R={};for(const W in Nt)Object.defineProperty(R,W,{get:()=>l.value[W],enumerable:!0});v.provide(Io,mt),v.provide(ha,br(R)),v.provide(ao,l);const I=v.unmount;It.add(v),v.unmount=function(){It.delete(v),It.size<1&&(u=Nt,ee&&ee(),ee=null,l.value=Nt,Pt=!1,oe=!1),I()}}};function D(v){return v.reduce((R,I)=>R.then(()=>L(I)),Promise.resolve())}return mt}const sn=(e,t)=>{const n=e.__vccOpts||e;for(const[s,o]of t)n[s]=o;return n},od={},id={class:"navigation-bar"};function rd(e,t){return le(),pe("nav",id,[...t[0]||(t[0]=[Ze('<div class="nav-container" data-v-5ea7b12e><div class="nav-brand" data-v-5ea7b12e><h1 data-v-5ea7b12e>WebCanvas</h1></div><div class="nav-links" data-v-5ea7b12e><a href="/" class="nav-link" data-v-5ea7b12e>Canvas</a><a href="about" class="nav-link" data-v-5ea7b12e>About</a></div></div>',1)])])}const ad=sn(od,[["render",rd],["__scopeId","data-v-5ea7b12e"]]),ld=gt({__name:"App",setup(e){return(t,n)=>(le(),pe(Ee,null,[C("header",null,[ue(ad)]),ue(Le(Sa))],64))}});class Zt extends Error{constructor(t,n){const s=new.target.prototype;super(`${t}: Status code '${n}'`),this.statusCode=n,this.__proto__=s}}class No extends Error{constructor(t="A timeout occurred."){const n=new.target.prototype;super(t),this.__proto__=n}}class nt extends Error{constructor(t="An abort occurred."){const n=new.target.prototype;super(t),this.__proto__=n}}class cd extends Error{constructor(t,n){const s=new.target.prototype;super(t),this.transport=n,this.errorType="UnsupportedTransportError",this.__proto__=s}}class ud extends Error{constructor(t,n){const s=new.target.prototype;super(t),this.transport=n,this.errorType="DisabledTransportError",this.__proto__=s}}class dd extends Error{constructor(t,n){const s=new.target.prototype;super(t),this.transport=n,this.errorType="FailedToStartTransportError",this.__proto__=s}}class Vi extends Error{constructor(t){const n=new.target.prototype;super(t),this.errorType="FailedToNegotiateWithServerError",this.__proto__=n}}class hd extends Error{constructor(t,n){const s=new.target.prototype;super(t),this.innerErrors=n,this.__proto__=s}}class ka{constructor(t,n,s){this.statusCode=t,this.statusText=n,this.content=s}}class Es{get(t,n){return this.send({...n,method:"GET",url:t})}post(t,n){return this.send({...n,method:"POST",url:t})}delete(t,n){return this.send({...n,method:"DELETE",url:t})}getCookieString(t){return""}}var S;(function(e){e[e.Trace=0]="Trace",e[e.Debug=1]="Debug",e[e.Information=2]="Information",e[e.Warning=3]="Warning",e[e.Error=4]="Error",e[e.Critical=5]="Critical",e[e.None=6]="None"})(S||(S={}));class Fn{constructor(){}log(t,n){}}Fn.instance=new Fn;const fd="10.0.0";class Ce{static isRequired(t,n){if(t==null)throw new Error(`The '${n}' argument is required.`)}static isNotEmpty(t,n){if(!t||t.match(/^\s*$/))throw new Error(`The '${n}' argument should not be empty.`)}static isIn(t,n,s){if(!(t in n))throw new Error(`Unknown ${s} value: ${t}.`)}}class be{static get isBrowser(){return!be.isNode&&typeof window=="object"&&typeof window.document=="object"}static get isWebWorker(){return!be.isNode&&typeof self=="object"&&"importScripts"in self}static get isReactNative(){return!be.isNode&&typeof window=="object"&&typeof window.document>"u"}static get isNode(){return typeof process<"u"&&process.release&&process.release.name==="node"}}function Hn(e,t){let n="";return nn(e)?(n=`Binary data of length ${e.byteLength}`,t&&(n+=`. Content: '${pd(e)}'`)):typeof e=="string"&&(n=`String data of length ${e.length}`,t&&(n+=`. Content: '${e}'`)),n}function pd(e){const t=new Uint8Array(e);let n="";return t.forEach(s=>{const o=s<16?"0":"";n+=`0x${o}${s.toString(16)} `}),n.substring(0,n.length-1)}function nn(e){return e&&typeof ArrayBuffer<"u"&&(e instanceof ArrayBuffer||e.constructor&&e.constructor.name==="ArrayBuffer")}async function xa(e,t,n,s,o,i){const r={},[a,l]=mn();r[a]=l,e.log(S.Trace,`(${t} transport) sending data. ${Hn(o,i.logMessageContent)}.`);const u=nn(o)?"arraybuffer":"text",c=await n.post(s,{content:o,headers:{...r,...i.headers},responseType:u,timeout:i.timeout,withCredentials:i.withCredentials});e.log(S.Trace,`(${t} transport) request complete. Response status: ${c.statusCode}.`)}function gd(e){return e===void 0?new ds(S.Information):e===null?Fn.instance:e.log!==void 0?e:new ds(e)}class md{constructor(t,n){this._subject=t,this._observer=n}dispose(){const t=this._subject.observers.indexOf(this._observer);t>-1&&this._subject.observers.splice(t,1),this._subject.observers.length===0&&this._subject.cancelCallback&&this._subject.cancelCallback().catch(n=>{})}}class ds{constructor(t){this._minLevel=t,this.out=console}log(t,n){if(t>=this._minLevel){const s=`[${new Date().toISOString()}] ${S[t]}: ${n}`;switch(t){case S.Critical:case S.Error:this.out.error(s);break;case S.Warning:this.out.warn(s);break;case S.Information:this.out.info(s);break;default:this.out.log(s);break}}}}function mn(){let e="X-SignalR-User-Agent";return be.isNode&&(e="User-Agent"),[e,vd(fd,bd(),_d(),yd())]}function vd(e,t,n,s){let o="Microsoft SignalR/";const i=e.split(".");return o+=`${i[0]}.${i[1]}`,o+=` (${e}; `,t&&t!==""?o+=`${t}; `:o+="Unknown OS; ",o+=`${n}`,s?o+=`; ${s}`:o+="; Unknown Runtime Version",o+=")",o}function bd(){if(be.isNode)switch(process.platform){case"win32":return"Windows NT";case"darwin":return"macOS";case"linux":return"Linux";default:return process.platform}else return""}function yd(){if(be.isNode)return process.versions.node}function _d(){return be.isNode?"NodeJS":"Browser"}function zs(e){return e.stack?e.stack:e.message?e.message:`${e}`}function wd(){if(typeof globalThis<"u")return globalThis;if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("could not find global")}class Cd extends Es{constructor(t){if(super(),this._logger=t,typeof fetch>"u"||be.isNode){const n=typeof __webpack_require__=="function"?__non_webpack_require__:require;this._jar=new(n("tough-cookie")).CookieJar,typeof fetch>"u"?this._fetchType=n("node-fetch"):this._fetchType=fetch,this._fetchType=n("fetch-cookie")(this._fetchType,this._jar)}else this._fetchType=fetch.bind(wd());if(typeof AbortController>"u"){const n=typeof __webpack_require__=="function"?__non_webpack_require__:require;this._abortControllerType=n("abort-controller")}else this._abortControllerType=AbortController}async send(t){if(t.abortSignal&&t.abortSignal.aborted)throw new nt;if(!t.method)throw new Error("No method defined.");if(!t.url)throw new Error("No url defined.");const n=new this._abortControllerType;let s;t.abortSignal&&(t.abortSignal.onabort=()=>{n.abort(),s=new nt});let o=null;if(t.timeout){const l=t.timeout;o=setTimeout(()=>{n.abort(),this._logger.log(S.Warning,"Timeout from HTTP request."),s=new No},l)}t.content===""&&(t.content=void 0),t.content&&(t.headers=t.headers||{},nn(t.content)?t.headers["Content-Type"]="application/octet-stream":t.headers["Content-Type"]="text/plain;charset=UTF-8");let i;try{i=await this._fetchType(t.url,{body:t.content,cache:"no-cache",credentials:t.withCredentials===!0?"include":"same-origin",headers:{"X-Requested-With":"XMLHttpRequest",...t.headers},method:t.method,mode:"cors",redirect:"follow",signal:n.signal})}catch(l){throw s||(this._logger.log(S.Warning,`Error from HTTP request. ${l}.`),l)}finally{o&&clearTimeout(o),t.abortSignal&&(t.abortSignal.onabort=null)}if(!i.ok){const l=await ji(i,"text");throw new Zt(l||i.statusText,i.status)}const a=await ji(i,t.responseType);return new ka(i.status,i.statusText,a)}getCookieString(t){let n="";return be.isNode&&this._jar&&this._jar.getCookies(t,(s,o)=>n=o.join("; ")),n}}function ji(e,t){let n;switch(t){case"arraybuffer":n=e.arrayBuffer();break;case"text":n=e.text();break;case"blob":case"document":case"json":throw new Error(`${t} is not supported.`);default:n=e.text();break}return n}class Sd extends Es{constructor(t){super(),this._logger=t}send(t){return t.abortSignal&&t.abortSignal.aborted?Promise.reject(new nt):t.method?t.url?new Promise((n,s)=>{const o=new XMLHttpRequest;o.open(t.method,t.url,!0),o.withCredentials=t.withCredentials===void 0?!0:t.withCredentials,o.setRequestHeader("X-Requested-With","XMLHttpRequest"),t.content===""&&(t.content=void 0),t.content&&(nn(t.content)?o.setRequestHeader("Content-Type","application/octet-stream"):o.setRequestHeader("Content-Type","text/plain;charset=UTF-8"));const i=t.headers;i&&Object.keys(i).forEach(r=>{o.setRequestHeader(r,i[r])}),t.responseType&&(o.responseType=t.responseType),t.abortSignal&&(t.abortSignal.onabort=()=>{o.abort(),s(new nt)}),t.timeout&&(o.timeout=t.timeout),o.onload=()=>{t.abortSignal&&(t.abortSignal.onabort=null),o.status>=200&&o.status<300?n(new ka(o.status,o.statusText,o.response||o.responseText)):s(new Zt(o.response||o.responseText||o.statusText,o.status))},o.onerror=()=>{this._logger.log(S.Warning,`Error from HTTP request. ${o.status}: ${o.statusText}.`),s(new Zt(o.statusText,o.status))},o.ontimeout=()=>{this._logger.log(S.Warning,"Timeout from HTTP request."),s(new No)},o.send(t.content)}):Promise.reject(new Error("No url defined.")):Promise.reject(new Error("No method defined."))}}class kd extends Es{constructor(t){if(super(),typeof fetch<"u"||be.isNode)this._httpClient=new Cd(t);else if(typeof XMLHttpRequest<"u")this._httpClient=new Sd(t);else throw new Error("No usable HttpClient found.")}send(t){return t.abortSignal&&t.abortSignal.aborted?Promise.reject(new nt):t.method?t.url?this._httpClient.send(t):Promise.reject(new Error("No url defined.")):Promise.reject(new Error("No method defined."))}getCookieString(t){return this._httpClient.getCookieString(t)}}class Ke{static write(t){return`${t}${Ke.RecordSeparator}`}static parse(t){if(t[t.length-1]!==Ke.RecordSeparator)throw new Error("Message is incomplete.");const n=t.split(Ke.RecordSeparator);return n.pop(),n}}Ke.RecordSeparatorCode=30;Ke.RecordSeparator=String.fromCharCode(Ke.RecordSeparatorCode);class xd{writeHandshakeRequest(t){return Ke.write(JSON.stringify(t))}parseHandshakeResponse(t){let n,s;if(nn(t)){const a=new Uint8Array(t),l=a.indexOf(Ke.RecordSeparatorCode);if(l===-1)throw new Error("Message is incomplete.");const u=l+1;n=String.fromCharCode.apply(null,Array.prototype.slice.call(a.slice(0,u))),s=a.byteLength>u?a.slice(u).buffer:null}else{const a=t,l=a.indexOf(Ke.RecordSeparator);if(l===-1)throw new Error("Message is incomplete.");const u=l+1;n=a.substring(0,u),s=a.length>u?a.substring(u):null}const o=Ke.parse(n),i=JSON.parse(o[0]);if(i.type)throw new Error("Expected a handshake response from the server.");return[s,i]}}var J;(function(e){e[e.Invocation=1]="Invocation",e[e.StreamItem=2]="StreamItem",e[e.Completion=3]="Completion",e[e.StreamInvocation=4]="StreamInvocation",e[e.CancelInvocation=5]="CancelInvocation",e[e.Ping=6]="Ping",e[e.Close=7]="Close",e[e.Ack=8]="Ack",e[e.Sequence=9]="Sequence"})(J||(J={}));class Td{constructor(){this.observers=[]}next(t){for(const n of this.observers)n.next(t)}error(t){for(const n of this.observers)n.error&&n.error(t)}complete(){for(const t of this.observers)t.complete&&t.complete()}subscribe(t){return this.observers.push(t),new md(this,t)}}class Ed{constructor(t,n,s){this._bufferSize=1e5,this._messages=[],this._totalMessageCount=0,this._waitForSequenceMessage=!1,this._nextReceivingSequenceId=1,this._latestReceivedSequenceId=0,this._bufferedByteCount=0,this._reconnectInProgress=!1,this._protocol=t,this._connection=n,this._bufferSize=s}async _send(t){const n=this._protocol.writeMessage(t);let s=Promise.resolve();if(this._isInvocationMessage(t)){this._totalMessageCount++;let o=()=>{},i=()=>{};nn(n)?this._bufferedByteCount+=n.byteLength:this._bufferedByteCount+=n.length,this._bufferedByteCount>=this._bufferSize&&(s=new Promise((r,a)=>{o=r,i=a})),this._messages.push(new Rd(n,this._totalMessageCount,o,i))}try{this._reconnectInProgress||await this._connection.send(n)}catch{this._disconnected()}await s}_ack(t){let n=-1;for(let s=0;s<this._messages.length;s++){const o=this._messages[s];if(o._id<=t.sequenceId)n=s,nn(o._message)?this._bufferedByteCount-=o._message.byteLength:this._bufferedByteCount-=o._message.length,o._resolver();else if(this._bufferedByteCount<this._bufferSize)o._resolver();else break}n!==-1&&(this._messages=this._messages.slice(n+1))}_shouldProcessMessage(t){if(this._waitForSequenceMessage)return t.type!==J.Sequence?!1:(this._waitForSequenceMessage=!1,!0);if(!this._isInvocationMessage(t))return!0;const n=this._nextReceivingSequenceId;return this._nextReceivingSequenceId++,n<=this._latestReceivedSequenceId?(n===this._latestReceivedSequenceId&&this._ackTimer(),!1):(this._latestReceivedSequenceId=n,this._ackTimer(),!0)}_resetSequence(t){if(t.sequenceId>this._nextReceivingSequenceId){this._connection.stop(new Error("Sequence ID greater than amount of messages we've received."));return}this._nextReceivingSequenceId=t.sequenceId}_disconnected(){this._reconnectInProgress=!0,this._waitForSequenceMessage=!0}async _resend(){const t=this._messages.length!==0?this._messages[0]._id:this._totalMessageCount+1;await this._connection.send(this._protocol.writeMessage({type:J.Sequence,sequenceId:t}));const n=this._messages;for(const s of n)await this._connection.send(s._message);this._reconnectInProgress=!1}_dispose(t){t??(t=new Error("Unable to reconnect to server."));for(const n of this._messages)n._rejector(t)}_isInvocationMessage(t){switch(t.type){case J.Invocation:case J.StreamItem:case J.Completion:case J.StreamInvocation:case J.CancelInvocation:return!0;case J.Close:case J.Sequence:case J.Ping:case J.Ack:return!1}}_ackTimer(){this._ackTimerHandle===void 0&&(this._ackTimerHandle=setTimeout(async()=>{try{this._reconnectInProgress||await this._connection.send(this._protocol.writeMessage({type:J.Ack,sequenceId:this._latestReceivedSequenceId}))}catch{}clearTimeout(this._ackTimerHandle),this._ackTimerHandle=void 0},1e3))}}class Rd{constructor(t,n,s,o){this._message=t,this._id=n,this._resolver=s,this._rejector=o}}const Ad=30*1e3,Pd=15*1e3,Id=1e5;var me;(function(e){e.Disconnected="Disconnected",e.Connecting="Connecting",e.Connected="Connected",e.Disconnecting="Disconnecting",e.Reconnecting="Reconnecting"})(me||(me={}));class Mo{static create(t,n,s,o,i,r,a){return new Mo(t,n,s,o,i,r,a)}constructor(t,n,s,o,i,r,a){this._nextKeepAlive=0,this._freezeEventListener=()=>{this._logger.log(S.Warning,"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep")},Ce.isRequired(t,"connection"),Ce.isRequired(n,"logger"),Ce.isRequired(s,"protocol"),this.serverTimeoutInMilliseconds=i??Ad,this.keepAliveIntervalInMilliseconds=r??Pd,this._statefulReconnectBufferSize=a??Id,this._logger=n,this._protocol=s,this.connection=t,this._reconnectPolicy=o,this._handshakeProtocol=new xd,this.connection.onreceive=l=>this._processIncomingData(l),this.connection.onclose=l=>this._connectionClosed(l),this._callbacks={},this._methods={},this._closedCallbacks=[],this._reconnectingCallbacks=[],this._reconnectedCallbacks=[],this._invocationId=0,this._receivedHandshakeResponse=!1,this._connectionState=me.Disconnected,this._connectionStarted=!1,this._cachedPingMessage=this._protocol.writeMessage({type:J.Ping})}get state(){return this._connectionState}get connectionId(){return this.connection&&this.connection.connectionId||null}get baseUrl(){return this.connection.baseUrl||""}set baseUrl(t){if(this._connectionState!==me.Disconnected&&this._connectionState!==me.Reconnecting)throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");if(!t)throw new Error("The HubConnection url must be a valid url.");this.connection.baseUrl=t}start(){return this._startPromise=this._startWithStateTransitions(),this._startPromise}async _startWithStateTransitions(){if(this._connectionState!==me.Disconnected)return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));this._connectionState=me.Connecting,this._logger.log(S.Debug,"Starting HubConnection.");try{await this._startInternal(),be.isBrowser&&window.document.addEventListener("freeze",this._freezeEventListener),this._connectionState=me.Connected,this._connectionStarted=!0,this._logger.log(S.Debug,"HubConnection connected successfully.")}catch(t){return this._connectionState=me.Disconnected,this._logger.log(S.Debug,`HubConnection failed to start successfully because of error '${t}'.`),Promise.reject(t)}}async _startInternal(){this._stopDuringStartError=void 0,this._receivedHandshakeResponse=!1;const t=new Promise((n,s)=>{this._handshakeResolver=n,this._handshakeRejecter=s});await this.connection.start(this._protocol.transferFormat);try{let n=this._protocol.version;this.connection.features.reconnect||(n=1);const s={protocol:this._protocol.name,version:n};if(this._logger.log(S.Debug,"Sending handshake request."),await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(s)),this._logger.log(S.Information,`Using HubProtocol '${this._protocol.name}'.`),this._cleanupTimeout(),this._resetTimeoutPeriod(),this._resetKeepAliveInterval(),await t,this._stopDuringStartError)throw this._stopDuringStartError;this.connection.features.reconnect&&(this._messageBuffer=new Ed(this._protocol,this.connection,this._statefulReconnectBufferSize),this.connection.features.disconnected=this._messageBuffer._disconnected.bind(this._messageBuffer),this.connection.features.resend=()=>{if(this._messageBuffer)return this._messageBuffer._resend()}),this.connection.features.inherentKeepAlive||await this._sendMessage(this._cachedPingMessage)}catch(n){throw this._logger.log(S.Debug,`Hub handshake failed with error '${n}' during start(). Stopping HubConnection.`),this._cleanupTimeout(),this._cleanupPingTimer(),await this.connection.stop(n),n}}async stop(){const t=this._startPromise;this.connection.features.reconnect=!1,this._stopPromise=this._stopInternal(),await this._stopPromise;try{await t}catch{}}_stopInternal(t){if(this._connectionState===me.Disconnected)return this._logger.log(S.Debug,`Call to HubConnection.stop(${t}) ignored because it is already in the disconnected state.`),Promise.resolve();if(this._connectionState===me.Disconnecting)return this._logger.log(S.Debug,`Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnecting state.`),this._stopPromise;const n=this._connectionState;return this._connectionState=me.Disconnecting,this._logger.log(S.Debug,"Stopping HubConnection."),this._reconnectDelayHandle?(this._logger.log(S.Debug,"Connection stopped during reconnect delay. Done reconnecting."),clearTimeout(this._reconnectDelayHandle),this._reconnectDelayHandle=void 0,this._completeClose(),Promise.resolve()):(n===me.Connected&&this._sendCloseMessage(),this._cleanupTimeout(),this._cleanupPingTimer(),this._stopDuringStartError=t||new nt("The connection was stopped before the hub handshake could complete."),this.connection.stop(t))}async _sendCloseMessage(){try{await this._sendWithProtocol(this._createCloseMessage())}catch{}}stream(t,...n){const[s,o]=this._replaceStreamingParams(n),i=this._createStreamInvocation(t,n,o);let r;const a=new Td;return a.cancelCallback=()=>{const l=this._createCancelInvocation(i.invocationId);return delete this._callbacks[i.invocationId],r.then(()=>this._sendWithProtocol(l))},this._callbacks[i.invocationId]=(l,u)=>{if(u){a.error(u);return}else l&&(l.type===J.Completion?l.error?a.error(new Error(l.error)):a.complete():a.next(l.item))},r=this._sendWithProtocol(i).catch(l=>{a.error(l),delete this._callbacks[i.invocationId]}),this._launchStreams(s,r),a}_sendMessage(t){return this._resetKeepAliveInterval(),this.connection.send(t)}_sendWithProtocol(t){return this._messageBuffer?this._messageBuffer._send(t):this._sendMessage(this._protocol.writeMessage(t))}send(t,...n){const[s,o]=this._replaceStreamingParams(n),i=this._sendWithProtocol(this._createInvocation(t,n,!0,o));return this._launchStreams(s,i),i}invoke(t,...n){const[s,o]=this._replaceStreamingParams(n),i=this._createInvocation(t,n,!1,o);return new Promise((a,l)=>{this._callbacks[i.invocationId]=(c,h)=>{if(h){l(h);return}else c&&(c.type===J.Completion?c.error?l(new Error(c.error)):a(c.result):l(new Error(`Unexpected message type: ${c.type}`)))};const u=this._sendWithProtocol(i).catch(c=>{l(c),delete this._callbacks[i.invocationId]});this._launchStreams(s,u)})}on(t,n){!t||!n||(t=t.toLowerCase(),this._methods[t]||(this._methods[t]=[]),this._methods[t].indexOf(n)===-1&&this._methods[t].push(n))}off(t,n){if(!t)return;t=t.toLowerCase();const s=this._methods[t];if(s)if(n){const o=s.indexOf(n);o!==-1&&(s.splice(o,1),s.length===0&&delete this._methods[t])}else delete this._methods[t]}onclose(t){t&&this._closedCallbacks.push(t)}onreconnecting(t){t&&this._reconnectingCallbacks.push(t)}onreconnected(t){t&&this._reconnectedCallbacks.push(t)}_processIncomingData(t){if(this._cleanupTimeout(),this._receivedHandshakeResponse||(t=this._processHandshakeResponse(t),this._receivedHandshakeResponse=!0),t){const n=this._protocol.parseMessages(t,this._logger);for(const s of n)if(!(this._messageBuffer&&!this._messageBuffer._shouldProcessMessage(s)))switch(s.type){case J.Invocation:this._invokeClientMethod(s).catch(o=>{this._logger.log(S.Error,`Invoke client method threw error: ${zs(o)}`)});break;case J.StreamItem:case J.Completion:{const o=this._callbacks[s.invocationId];if(o){s.type===J.Completion&&delete this._callbacks[s.invocationId];try{o(s)}catch(i){this._logger.log(S.Error,`Stream callback threw error: ${zs(i)}`)}}break}case J.Ping:break;case J.Close:{this._logger.log(S.Information,"Close message received from server.");const o=s.error?new Error("Server returned an error on close: "+s.error):void 0;s.allowReconnect===!0?this.connection.stop(o):this._stopPromise=this._stopInternal(o);break}case J.Ack:this._messageBuffer&&this._messageBuffer._ack(s);break;case J.Sequence:this._messageBuffer&&this._messageBuffer._resetSequence(s);break;default:this._logger.log(S.Warning,`Invalid message type: ${s.type}.`);break}}this._resetTimeoutPeriod()}_processHandshakeResponse(t){let n,s;try{[s,n]=this._handshakeProtocol.parseHandshakeResponse(t)}catch(o){const i="Error parsing handshake response: "+o;this._logger.log(S.Error,i);const r=new Error(i);throw this._handshakeRejecter(r),r}if(n.error){const o="Server returned handshake error: "+n.error;this._logger.log(S.Error,o);const i=new Error(o);throw this._handshakeRejecter(i),i}else this._logger.log(S.Debug,"Server handshake complete.");return this._handshakeResolver(),s}_resetKeepAliveInterval(){this.connection.features.inherentKeepAlive||(this._nextKeepAlive=new Date().getTime()+this.keepAliveIntervalInMilliseconds,this._cleanupPingTimer())}_resetTimeoutPeriod(){if(!this.connection.features||!this.connection.features.inherentKeepAlive){this._timeoutHandle=setTimeout(()=>this.serverTimeout(),this.serverTimeoutInMilliseconds);let t=this._nextKeepAlive-new Date().getTime();if(t<0){this._connectionState===me.Connected&&this._trySendPingMessage();return}this._pingServerHandle===void 0&&(t<0&&(t=0),this._pingServerHandle=setTimeout(async()=>{this._connectionState===me.Connected&&await this._trySendPingMessage()},t))}}serverTimeout(){this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."))}async _invokeClientMethod(t){const n=t.target.toLowerCase(),s=this._methods[n];if(!s){this._logger.log(S.Warning,`No client method with the name '${n}' found.`),t.invocationId&&(this._logger.log(S.Warning,`No result given for '${n}' method and invocation ID '${t.invocationId}'.`),await this._sendWithProtocol(this._createCompletionMessage(t.invocationId,"Client didn't provide a result.",null)));return}const o=s.slice(),i=!!t.invocationId;let r,a,l;for(const u of o)try{const c=r;r=await u.apply(this,t.arguments),i&&r&&c&&(this._logger.log(S.Error,`Multiple results provided for '${n}'. Sending error to server.`),l=this._createCompletionMessage(t.invocationId,"Client provided multiple results.",null)),a=void 0}catch(c){a=c,this._logger.log(S.Error,`A callback for the method '${n}' threw error '${c}'.`)}l?await this._sendWithProtocol(l):i?(a?l=this._createCompletionMessage(t.invocationId,`${a}`,null):r!==void 0?l=this._createCompletionMessage(t.invocationId,null,r):(this._logger.log(S.Warning,`No result given for '${n}' method and invocation ID '${t.invocationId}'.`),l=this._createCompletionMessage(t.invocationId,"Client didn't provide a result.",null)),await this._sendWithProtocol(l)):r&&this._logger.log(S.Error,`Result given for '${n}' method but server is not expecting a result.`)}_connectionClosed(t){this._logger.log(S.Debug,`HubConnection.connectionClosed(${t}) called while in state ${this._connectionState}.`),this._stopDuringStartError=this._stopDuringStartError||t||new nt("The underlying connection was closed before the hub handshake could complete."),this._handshakeResolver&&this._handshakeResolver(),this._cancelCallbacksWithError(t||new Error("Invocation canceled due to the underlying connection being closed.")),this._cleanupTimeout(),this._cleanupPingTimer(),this._connectionState===me.Disconnecting?this._completeClose(t):this._connectionState===me.Connected&&this._reconnectPolicy?this._reconnect(t):this._connectionState===me.Connected&&this._completeClose(t)}_completeClose(t){if(this._connectionStarted){this._connectionState=me.Disconnected,this._connectionStarted=!1,this._messageBuffer&&(this._messageBuffer._dispose(t??new Error("Connection closed.")),this._messageBuffer=void 0),be.isBrowser&&window.document.removeEventListener("freeze",this._freezeEventListener);try{this._closedCallbacks.forEach(n=>n.apply(this,[t]))}catch(n){this._logger.log(S.Error,`An onclose callback called with error '${t}' threw error '${n}'.`)}}}async _reconnect(t){const n=Date.now();let s=0,o=t!==void 0?t:new Error("Attempting to reconnect due to a unknown error."),i=this._getNextRetryDelay(s,0,o);if(i===null){this._logger.log(S.Debug,"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."),this._completeClose(t);return}if(this._connectionState=me.Reconnecting,t?this._logger.log(S.Information,`Connection reconnecting because of error '${t}'.`):this._logger.log(S.Information,"Connection reconnecting."),this._reconnectingCallbacks.length!==0){try{this._reconnectingCallbacks.forEach(r=>r.apply(this,[t]))}catch(r){this._logger.log(S.Error,`An onreconnecting callback called with error '${t}' threw error '${r}'.`)}if(this._connectionState!==me.Reconnecting){this._logger.log(S.Debug,"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");return}}for(;i!==null;){if(this._logger.log(S.Information,`Reconnect attempt number ${s+1} will start in ${i} ms.`),await new Promise(r=>{this._reconnectDelayHandle=setTimeout(r,i)}),this._reconnectDelayHandle=void 0,this._connectionState!==me.Reconnecting){this._logger.log(S.Debug,"Connection left the reconnecting state during reconnect delay. Done reconnecting.");return}try{if(await this._startInternal(),this._connectionState=me.Connected,this._logger.log(S.Information,"HubConnection reconnected successfully."),this._reconnectedCallbacks.length!==0)try{this._reconnectedCallbacks.forEach(r=>r.apply(this,[this.connection.connectionId]))}catch(r){this._logger.log(S.Error,`An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${r}'.`)}return}catch(r){if(this._logger.log(S.Information,`Reconnect attempt failed because of error '${r}'.`),this._connectionState!==me.Reconnecting){this._logger.log(S.Debug,`Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`),this._connectionState===me.Disconnecting&&this._completeClose();return}s++,o=r instanceof Error?r:new Error(r.toString()),i=this._getNextRetryDelay(s,Date.now()-n,o)}}this._logger.log(S.Information,`Reconnect retries have been exhausted after ${Date.now()-n} ms and ${s} failed attempts. Connection disconnecting.`),this._completeClose()}_getNextRetryDelay(t,n,s){try{return this._reconnectPolicy.nextRetryDelayInMilliseconds({elapsedMilliseconds:n,previousRetryCount:t,retryReason:s})}catch(o){return this._logger.log(S.Error,`IRetryPolicy.nextRetryDelayInMilliseconds(${t}, ${n}) threw error '${o}'.`),null}}_cancelCallbacksWithError(t){const n=this._callbacks;this._callbacks={},Object.keys(n).forEach(s=>{const o=n[s];try{o(null,t)}catch(i){this._logger.log(S.Error,`Stream 'error' callback called with '${t}' threw error: ${zs(i)}`)}})}_cleanupPingTimer(){this._pingServerHandle&&(clearTimeout(this._pingServerHandle),this._pingServerHandle=void 0)}_cleanupTimeout(){this._timeoutHandle&&clearTimeout(this._timeoutHandle)}_createInvocation(t,n,s,o){if(s)return o.length!==0?{target:t,arguments:n,streamIds:o,type:J.Invocation}:{target:t,arguments:n,type:J.Invocation};{const i=this._invocationId;return this._invocationId++,o.length!==0?{target:t,arguments:n,invocationId:i.toString(),streamIds:o,type:J.Invocation}:{target:t,arguments:n,invocationId:i.toString(),type:J.Invocation}}}_launchStreams(t,n){if(t.length!==0){n||(n=Promise.resolve());for(const s in t)t[s].subscribe({complete:()=>{n=n.then(()=>this._sendWithProtocol(this._createCompletionMessage(s)))},error:o=>{let i;o instanceof Error?i=o.message:o&&o.toString?i=o.toString():i="Unknown error",n=n.then(()=>this._sendWithProtocol(this._createCompletionMessage(s,i)))},next:o=>{n=n.then(()=>this._sendWithProtocol(this._createStreamItemMessage(s,o)))}})}}_replaceStreamingParams(t){const n=[],s=[];for(let o=0;o<t.length;o++){const i=t[o];if(this._isObservable(i)){const r=this._invocationId;this._invocationId++,n[r]=i,s.push(r.toString()),t.splice(o,1)}}return[n,s]}_isObservable(t){return t&&t.subscribe&&typeof t.subscribe=="function"}_createStreamInvocation(t,n,s){const o=this._invocationId;return this._invocationId++,s.length!==0?{target:t,arguments:n,invocationId:o.toString(),streamIds:s,type:J.StreamInvocation}:{target:t,arguments:n,invocationId:o.toString(),type:J.StreamInvocation}}_createCancelInvocation(t){return{invocationId:t,type:J.CancelInvocation}}_createStreamItemMessage(t,n){return{invocationId:t,item:n,type:J.StreamItem}}_createCompletionMessage(t,n,s){return n?{error:n,invocationId:t,type:J.Completion}:{invocationId:t,result:s,type:J.Completion}}_createCloseMessage(){return{type:J.Close}}async _trySendPingMessage(){try{await this._sendMessage(this._cachedPingMessage)}catch{this._cleanupPingTimer()}}}const Dd=[0,2e3,1e4,3e4,null];class Ui{constructor(t){this._retryDelays=t!==void 0?[...t,null]:Dd}nextRetryDelayInMilliseconds(t){return this._retryDelays[t.previousRetryCount]}}class en{}en.Authorization="Authorization";en.Cookie="Cookie";class Nd extends Es{constructor(t,n){super(),this._innerClient=t,this._accessTokenFactory=n}async send(t){let n=!0;this._accessTokenFactory&&(!this._accessToken||t.url&&t.url.indexOf("/negotiate?")>0)&&(n=!1,this._accessToken=await this._accessTokenFactory()),this._setAuthorizationHeader(t);const s=await this._innerClient.send(t);return n&&s.statusCode===401&&this._accessTokenFactory?(this._accessToken=await this._accessTokenFactory(),this._setAuthorizationHeader(t),await this._innerClient.send(t)):s}_setAuthorizationHeader(t){t.headers||(t.headers={}),this._accessToken?t.headers[en.Authorization]=`Bearer ${this._accessToken}`:this._accessTokenFactory&&t.headers[en.Authorization]&&delete t.headers[en.Authorization]}getCookieString(t){return this._innerClient.getCookieString(t)}}var ke;(function(e){e[e.None=0]="None",e[e.WebSockets=1]="WebSockets",e[e.ServerSentEvents=2]="ServerSentEvents",e[e.LongPolling=4]="LongPolling"})(ke||(ke={}));var Ie;(function(e){e[e.Text=1]="Text",e[e.Binary=2]="Binary"})(Ie||(Ie={}));let Md=class{constructor(){this._isAborted=!1,this.onabort=null}abort(){this._isAborted||(this._isAborted=!0,this.onabort&&this.onabort())}get signal(){return this}get aborted(){return this._isAborted}};class zi{get pollAborted(){return this._pollAbort.aborted}constructor(t,n,s){this._httpClient=t,this._logger=n,this._pollAbort=new Md,this._options=s,this._running=!1,this.onreceive=null,this.onclose=null}async connect(t,n){if(Ce.isRequired(t,"url"),Ce.isRequired(n,"transferFormat"),Ce.isIn(n,Ie,"transferFormat"),this._url=t,this._logger.log(S.Trace,"(LongPolling transport) Connecting."),n===Ie.Binary&&typeof XMLHttpRequest<"u"&&typeof new XMLHttpRequest().responseType!="string")throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");const[s,o]=mn(),i={[s]:o,...this._options.headers},r={abortSignal:this._pollAbort.signal,headers:i,timeout:1e5,withCredentials:this._options.withCredentials};n===Ie.Binary&&(r.responseType="arraybuffer");const a=`${t}&_=${Date.now()}`;this._logger.log(S.Trace,`(LongPolling transport) polling: ${a}.`);const l=await this._httpClient.get(a,r);l.statusCode!==200?(this._logger.log(S.Error,`(LongPolling transport) Unexpected response code: ${l.statusCode}.`),this._closeError=new Zt(l.statusText||"",l.statusCode),this._running=!1):this._running=!0,this._receiving=this._poll(this._url,r)}async _poll(t,n){try{for(;this._running;)try{const s=`${t}&_=${Date.now()}`;this._logger.log(S.Trace,`(LongPolling transport) polling: ${s}.`);const o=await this._httpClient.get(s,n);o.statusCode===204?(this._logger.log(S.Information,"(LongPolling transport) Poll terminated by server."),this._running=!1):o.statusCode!==200?(this._logger.log(S.Error,`(LongPolling transport) Unexpected response code: ${o.statusCode}.`),this._closeError=new Zt(o.statusText||"",o.statusCode),this._running=!1):o.content?(this._logger.log(S.Trace,`(LongPolling transport) data received. ${Hn(o.content,this._options.logMessageContent)}.`),this.onreceive&&this.onreceive(o.content)):this._logger.log(S.Trace,"(LongPolling transport) Poll timed out, reissuing.")}catch(s){this._running?s instanceof No?this._logger.log(S.Trace,"(LongPolling transport) Poll timed out, reissuing."):(this._closeError=s,this._running=!1):this._logger.log(S.Trace,`(LongPolling transport) Poll errored after shutdown: ${s.message}`)}}finally{this._logger.log(S.Trace,"(LongPolling transport) Polling complete."),this.pollAborted||this._raiseOnClose()}}async send(t){return this._running?xa(this._logger,"LongPolling",this._httpClient,this._url,t,this._options):Promise.reject(new Error("Cannot send until the transport is connected"))}async stop(){this._logger.log(S.Trace,"(LongPolling transport) Stopping polling."),this._running=!1,this._pollAbort.abort();try{await this._receiving,this._logger.log(S.Trace,`(LongPolling transport) sending DELETE request to ${this._url}.`);const t={},[n,s]=mn();t[n]=s;const o={headers:{...t,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials};let i;try{await this._httpClient.delete(this._url,o)}catch(r){i=r}i?i instanceof Zt&&(i.statusCode===404?this._logger.log(S.Trace,"(LongPolling transport) A 404 response was returned from sending a DELETE request."):this._logger.log(S.Trace,`(LongPolling transport) Error sending a DELETE request: ${i}`)):this._logger.log(S.Trace,"(LongPolling transport) DELETE request accepted.")}finally{this._logger.log(S.Trace,"(LongPolling transport) Stop finished."),this._raiseOnClose()}}_raiseOnClose(){if(this.onclose){let t="(LongPolling transport) Firing onclose event.";this._closeError&&(t+=" Error: "+this._closeError),this._logger.log(S.Trace,t),this.onclose(this._closeError)}}}class $d{constructor(t,n,s,o){this._httpClient=t,this._accessToken=n,this._logger=s,this._options=o,this.onreceive=null,this.onclose=null}async connect(t,n){return Ce.isRequired(t,"url"),Ce.isRequired(n,"transferFormat"),Ce.isIn(n,Ie,"transferFormat"),this._logger.log(S.Trace,"(SSE transport) Connecting."),this._url=t,this._accessToken&&(t+=(t.indexOf("?")<0?"?":"&")+`access_token=${encodeURIComponent(this._accessToken)}`),new Promise((s,o)=>{let i=!1;if(n!==Ie.Text){o(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));return}let r;if(be.isBrowser||be.isWebWorker)r=new this._options.EventSource(t,{withCredentials:this._options.withCredentials});else{const a=this._httpClient.getCookieString(t),l={};l.Cookie=a;const[u,c]=mn();l[u]=c,r=new this._options.EventSource(t,{withCredentials:this._options.withCredentials,headers:{...l,...this._options.headers}})}try{r.onmessage=a=>{if(this.onreceive)try{this._logger.log(S.Trace,`(SSE transport) data received. ${Hn(a.data,this._options.logMessageContent)}.`),this.onreceive(a.data)}catch(l){this._close(l);return}},r.onerror=a=>{i?this._close():o(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."))},r.onopen=()=>{this._logger.log(S.Information,`SSE connected to ${this._url}`),this._eventSource=r,i=!0,s()}}catch(a){o(a);return}})}async send(t){return this._eventSource?xa(this._logger,"SSE",this._httpClient,this._url,t,this._options):Promise.reject(new Error("Cannot send until the transport is connected"))}stop(){return this._close(),Promise.resolve()}_close(t){this._eventSource&&(this._eventSource.close(),this._eventSource=void 0,this.onclose&&this.onclose(t))}}class Bd{constructor(t,n,s,o,i,r){this._logger=s,this._accessTokenFactory=n,this._logMessageContent=o,this._webSocketConstructor=i,this._httpClient=t,this.onreceive=null,this.onclose=null,this._headers=r}async connect(t,n){Ce.isRequired(t,"url"),Ce.isRequired(n,"transferFormat"),Ce.isIn(n,Ie,"transferFormat"),this._logger.log(S.Trace,"(WebSockets transport) Connecting.");let s;return this._accessTokenFactory&&(s=await this._accessTokenFactory()),new Promise((o,i)=>{t=t.replace(/^http/,"ws");let r;const a=this._httpClient.getCookieString(t);let l=!1;if(be.isNode||be.isReactNative){const u={},[c,h]=mn();u[c]=h,s&&(u[en.Authorization]=`Bearer ${s}`),a&&(u[en.Cookie]=a),r=new this._webSocketConstructor(t,void 0,{headers:{...u,...this._headers}})}else s&&(t+=(t.indexOf("?")<0?"?":"&")+`access_token=${encodeURIComponent(s)}`);r||(r=new this._webSocketConstructor(t)),n===Ie.Binary&&(r.binaryType="arraybuffer"),r.onopen=u=>{this._logger.log(S.Information,`WebSocket connected to ${t}.`),this._webSocket=r,l=!0,o()},r.onerror=u=>{let c=null;typeof ErrorEvent<"u"&&u instanceof ErrorEvent?c=u.error:c="There was an error with the transport",this._logger.log(S.Information,`(WebSockets transport) ${c}.`)},r.onmessage=u=>{if(this._logger.log(S.Trace,`(WebSockets transport) data received. ${Hn(u.data,this._logMessageContent)}.`),this.onreceive)try{this.onreceive(u.data)}catch(c){this._close(c);return}},r.onclose=u=>{if(l)this._close(u);else{let c=null;typeof ErrorEvent<"u"&&u instanceof ErrorEvent?c=u.error:c="WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.",i(new Error(c))}}})}send(t){return this._webSocket&&this._webSocket.readyState===this._webSocketConstructor.OPEN?(this._logger.log(S.Trace,`(WebSockets transport) sending data. ${Hn(t,this._logMessageContent)}.`),this._webSocket.send(t),Promise.resolve()):Promise.reject("WebSocket is not in the OPEN state")}stop(){return this._webSocket&&this._close(void 0),Promise.resolve()}_close(t){this._webSocket&&(this._webSocket.onclose=()=>{},this._webSocket.onmessage=()=>{},this._webSocket.onerror=()=>{},this._webSocket.close(),this._webSocket=void 0),this._logger.log(S.Trace,"(WebSockets transport) socket closed."),this.onclose&&(this._isCloseEvent(t)&&(t.wasClean===!1||t.code!==1e3)?this.onclose(new Error(`WebSocket closed with status code: ${t.code} (${t.reason||"no reason given"}).`)):t instanceof Error?this.onclose(t):this.onclose())}_isCloseEvent(t){return t&&typeof t.wasClean=="boolean"&&typeof t.code=="number"}}const Ki=100;class Ld{constructor(t,n={}){if(this._stopPromiseResolver=()=>{},this.features={},this._negotiateVersion=1,Ce.isRequired(t,"url"),this._logger=gd(n.logger),this.baseUrl=this._resolveUrl(t),n=n||{},n.logMessageContent=n.logMessageContent===void 0?!1:n.logMessageContent,typeof n.withCredentials=="boolean"||n.withCredentials===void 0)n.withCredentials=n.withCredentials===void 0?!0:n.withCredentials;else throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");n.timeout=n.timeout===void 0?100*1e3:n.timeout;let s=null,o=null;if(be.isNode&&typeof require<"u"){const i=typeof __webpack_require__=="function"?__non_webpack_require__:require;s=i("ws"),o=i("eventsource")}!be.isNode&&typeof WebSocket<"u"&&!n.WebSocket?n.WebSocket=WebSocket:be.isNode&&!n.WebSocket&&s&&(n.WebSocket=s),!be.isNode&&typeof EventSource<"u"&&!n.EventSource?n.EventSource=EventSource:be.isNode&&!n.EventSource&&typeof o<"u"&&(n.EventSource=o),this._httpClient=new Nd(n.httpClient||new kd(this._logger),n.accessTokenFactory),this._connectionState="Disconnected",this._connectionStarted=!1,this._options=n,this.onreceive=null,this.onclose=null}async start(t){if(t=t||Ie.Binary,Ce.isIn(t,Ie,"transferFormat"),this._logger.log(S.Debug,`Starting connection with transfer format '${Ie[t]}'.`),this._connectionState!=="Disconnected")return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));if(this._connectionState="Connecting",this._startInternalPromise=this._startInternal(t),await this._startInternalPromise,this._connectionState==="Disconnecting"){const n="Failed to start the HttpConnection before stop() was called.";return this._logger.log(S.Error,n),await this._stopPromise,Promise.reject(new nt(n))}else if(this._connectionState!=="Connected"){const n="HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";return this._logger.log(S.Error,n),Promise.reject(new nt(n))}this._connectionStarted=!0}send(t){return this._connectionState!=="Connected"?Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")):(this._sendQueue||(this._sendQueue=new $o(this.transport)),this._sendQueue.send(t))}async stop(t){if(this._connectionState==="Disconnected")return this._logger.log(S.Debug,`Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnected state.`),Promise.resolve();if(this._connectionState==="Disconnecting")return this._logger.log(S.Debug,`Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnecting state.`),this._stopPromise;this._connectionState="Disconnecting",this._stopPromise=new Promise(n=>{this._stopPromiseResolver=n}),await this._stopInternal(t),await this._stopPromise}async _stopInternal(t){this._stopError=t;try{await this._startInternalPromise}catch{}if(this.transport){try{await this.transport.stop()}catch(n){this._logger.log(S.Error,`HttpConnection.transport.stop() threw error '${n}'.`),this._stopConnection()}this.transport=void 0}else this._logger.log(S.Debug,"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.")}async _startInternal(t){let n=this.baseUrl;this._accessTokenFactory=this._options.accessTokenFactory,this._httpClient._accessTokenFactory=this._accessTokenFactory;try{if(this._options.skipNegotiation)if(this._options.transport===ke.WebSockets)this.transport=this._constructTransport(ke.WebSockets),await this._startTransport(n,t);else throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");else{let s=null,o=0;do{if(s=await this._getNegotiationResponse(n),this._connectionState==="Disconnecting"||this._connectionState==="Disconnected")throw new nt("The connection was stopped during negotiation.");if(s.error)throw new Error(s.error);if(s.ProtocolVersion)throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");if(s.url&&(n=s.url),s.accessToken){const i=s.accessToken;this._accessTokenFactory=()=>i,this._httpClient._accessToken=i,this._httpClient._accessTokenFactory=void 0}o++}while(s.url&&o<Ki);if(o===Ki&&s.url)throw new Error("Negotiate redirection limit exceeded.");await this._createTransport(n,this._options.transport,s,t)}this.transport instanceof zi&&(this.features.inherentKeepAlive=!0),this._connectionState==="Connecting"&&(this._logger.log(S.Debug,"The HttpConnection connected successfully."),this._connectionState="Connected")}catch(s){return this._logger.log(S.Error,"Failed to start the connection: "+s),this._connectionState="Disconnected",this.transport=void 0,this._stopPromiseResolver(),Promise.reject(s)}}async _getNegotiationResponse(t){const n={},[s,o]=mn();n[s]=o;const i=this._resolveNegotiateUrl(t);this._logger.log(S.Debug,`Sending negotiation request: ${i}.`);try{const r=await this._httpClient.post(i,{content:"",headers:{...n,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials});if(r.statusCode!==200)return Promise.reject(new Error(`Unexpected status code returned from negotiate '${r.statusCode}'`));const a=JSON.parse(r.content);return(!a.negotiateVersion||a.negotiateVersion<1)&&(a.connectionToken=a.connectionId),a.useStatefulReconnect&&this._options._useStatefulReconnect!==!0?Promise.reject(new Vi("Client didn't negotiate Stateful Reconnect but the server did.")):a}catch(r){let a="Failed to complete negotiation with the server: "+r;return r instanceof Zt&&r.statusCode===404&&(a=a+" Either this is not a SignalR endpoint or there is a proxy blocking the connection."),this._logger.log(S.Error,a),Promise.reject(new Vi(a))}}_createConnectUrl(t,n){return n?t+(t.indexOf("?")===-1?"?":"&")+`id=${n}`:t}async _createTransport(t,n,s,o){let i=this._createConnectUrl(t,s.connectionToken);if(this._isITransport(n)){this._logger.log(S.Debug,"Connection was provided an instance of ITransport, using that directly."),this.transport=n,await this._startTransport(i,o),this.connectionId=s.connectionId;return}const r=[],a=s.availableTransports||[];let l=s;for(const u of a){const c=this._resolveTransportOrError(u,n,o,l?.useStatefulReconnect===!0);if(c instanceof Error)r.push(`${u.transport} failed:`),r.push(c);else if(this._isITransport(c)){if(this.transport=c,!l){try{l=await this._getNegotiationResponse(t)}catch(h){return Promise.reject(h)}i=this._createConnectUrl(t,l.connectionToken)}try{await this._startTransport(i,o),this.connectionId=l.connectionId;return}catch(h){if(this._logger.log(S.Error,`Failed to start the transport '${u.transport}': ${h}`),l=void 0,r.push(new dd(`${u.transport} failed: ${h}`,ke[u.transport])),this._connectionState!=="Connecting"){const p="Failed to select transport before stop() was called.";return this._logger.log(S.Debug,p),Promise.reject(new nt(p))}}}}return r.length>0?Promise.reject(new hd(`Unable to connect to the server with any of the available transports. ${r.join(" ")}`,r)):Promise.reject(new Error("None of the transports supported by the client are supported by the server."))}_constructTransport(t){switch(t){case ke.WebSockets:if(!this._options.WebSocket)throw new Error("'WebSocket' is not supported in your environment.");return new Bd(this._httpClient,this._accessTokenFactory,this._logger,this._options.logMessageContent,this._options.WebSocket,this._options.headers||{});case ke.ServerSentEvents:if(!this._options.EventSource)throw new Error("'EventSource' is not supported in your environment.");return new $d(this._httpClient,this._httpClient._accessToken,this._logger,this._options);case ke.LongPolling:return new zi(this._httpClient,this._logger,this._options);default:throw new Error(`Unknown transport: ${t}.`)}}_startTransport(t,n){return this.transport.onreceive=this.onreceive,this.features.reconnect?this.transport.onclose=async s=>{let o=!1;if(this.features.reconnect)try{this.features.disconnected(),await this.transport.connect(t,n),await this.features.resend()}catch{o=!0}else{this._stopConnection(s);return}o&&this._stopConnection(s)}:this.transport.onclose=s=>this._stopConnection(s),this.transport.connect(t,n)}_resolveTransportOrError(t,n,s,o){const i=ke[t.transport];if(i==null)return this._logger.log(S.Debug,`Skipping transport '${t.transport}' because it is not supported by this client.`),new Error(`Skipping transport '${t.transport}' because it is not supported by this client.`);if(Od(n,i))if(t.transferFormats.map(a=>Ie[a]).indexOf(s)>=0){if(i===ke.WebSockets&&!this._options.WebSocket||i===ke.ServerSentEvents&&!this._options.EventSource)return this._logger.log(S.Debug,`Skipping transport '${ke[i]}' because it is not supported in your environment.'`),new cd(`'${ke[i]}' is not supported in your environment.`,i);this._logger.log(S.Debug,`Selecting transport '${ke[i]}'.`);try{return this.features.reconnect=i===ke.WebSockets?o:void 0,this._constructTransport(i)}catch(a){return a}}else return this._logger.log(S.Debug,`Skipping transport '${ke[i]}' because it does not support the requested transfer format '${Ie[s]}'.`),new Error(`'${ke[i]}' does not support ${Ie[s]}.`);else return this._logger.log(S.Debug,`Skipping transport '${ke[i]}' because it was disabled by the client.`),new ud(`'${ke[i]}' is disabled by the client.`,i)}_isITransport(t){return t&&typeof t=="object"&&"connect"in t}_stopConnection(t){if(this._logger.log(S.Debug,`HttpConnection.stopConnection(${t}) called while in state ${this._connectionState}.`),this.transport=void 0,t=this._stopError||t,this._stopError=void 0,this._connectionState==="Disconnected"){this._logger.log(S.Debug,`Call to HttpConnection.stopConnection(${t}) was ignored because the connection is already in the disconnected state.`);return}if(this._connectionState==="Connecting")throw this._logger.log(S.Warning,`Call to HttpConnection.stopConnection(${t}) was ignored because the connection is still in the connecting state.`),new Error(`HttpConnection.stopConnection(${t}) was called while the connection is still in the connecting state.`);if(this._connectionState==="Disconnecting"&&this._stopPromiseResolver(),t?this._logger.log(S.Error,`Connection disconnected with error '${t}'.`):this._logger.log(S.Information,"Connection disconnected."),this._sendQueue&&(this._sendQueue.stop().catch(n=>{this._logger.log(S.Error,`TransportSendQueue.stop() threw error '${n}'.`)}),this._sendQueue=void 0),this.connectionId=void 0,this._connectionState="Disconnected",this._connectionStarted){this._connectionStarted=!1;try{this.onclose&&this.onclose(t)}catch(n){this._logger.log(S.Error,`HttpConnection.onclose(${t}) threw error '${n}'.`)}}}_resolveUrl(t){if(t.lastIndexOf("https://",0)===0||t.lastIndexOf("http://",0)===0)return t;if(!be.isBrowser)throw new Error(`Cannot resolve '${t}'.`);const n=window.document.createElement("a");return n.href=t,this._logger.log(S.Information,`Normalizing '${t}' to '${n.href}'.`),n.href}_resolveNegotiateUrl(t){const n=new URL(t);n.pathname.endsWith("/")?n.pathname+="negotiate":n.pathname+="/negotiate";const s=new URLSearchParams(n.searchParams);return s.has("negotiateVersion")||s.append("negotiateVersion",this._negotiateVersion.toString()),s.has("useStatefulReconnect")?s.get("useStatefulReconnect")==="true"&&(this._options._useStatefulReconnect=!0):this._options._useStatefulReconnect===!0&&s.append("useStatefulReconnect","true"),n.search=s.toString(),n.toString()}}function Od(e,t){return!e||(t&e)!==0}class $o{constructor(t){this._transport=t,this._buffer=[],this._executing=!0,this._sendBufferedData=new Xn,this._transportResult=new Xn,this._sendLoopPromise=this._sendLoop()}send(t){return this._bufferData(t),this._transportResult||(this._transportResult=new Xn),this._transportResult.promise}stop(){return this._executing=!1,this._sendBufferedData.resolve(),this._sendLoopPromise}_bufferData(t){if(this._buffer.length&&typeof this._buffer[0]!=typeof t)throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof t}`);this._buffer.push(t),this._sendBufferedData.resolve()}async _sendLoop(){for(;;){if(await this._sendBufferedData.promise,!this._executing){this._transportResult&&this._transportResult.reject("Connection stopped.");break}this._sendBufferedData=new Xn;const t=this._transportResult;this._transportResult=void 0;const n=typeof this._buffer[0]=="string"?this._buffer.join(""):$o._concatBuffers(this._buffer);this._buffer.length=0;try{await this._transport.send(n),t.resolve()}catch(s){t.reject(s)}}}static _concatBuffers(t){const n=t.map(i=>i.byteLength).reduce((i,r)=>i+r),s=new Uint8Array(n);let o=0;for(const i of t)s.set(new Uint8Array(i),o),o+=i.byteLength;return s.buffer}}class Xn{constructor(){this.promise=new Promise((t,n)=>[this._resolver,this._rejecter]=[t,n])}resolve(){this._resolver()}reject(t){this._rejecter(t)}}const Wd="json";class Fd{constructor(){this.name=Wd,this.version=2,this.transferFormat=Ie.Text}parseMessages(t,n){if(typeof t!="string")throw new Error("Invalid input for JSON hub protocol. Expected a string.");if(!t)return[];n===null&&(n=Fn.instance);const s=Ke.parse(t),o=[];for(const i of s){const r=JSON.parse(i);if(typeof r.type!="number")throw new Error("Invalid payload.");switch(r.type){case J.Invocation:this._isInvocationMessage(r);break;case J.StreamItem:this._isStreamItemMessage(r);break;case J.Completion:this._isCompletionMessage(r);break;case J.Ping:break;case J.Close:break;case J.Ack:this._isAckMessage(r);break;case J.Sequence:this._isSequenceMessage(r);break;default:n.log(S.Information,"Unknown message type '"+r.type+"' ignored.");continue}o.push(r)}return o}writeMessage(t){return Ke.write(JSON.stringify(t))}_isInvocationMessage(t){this._assertNotEmptyString(t.target,"Invalid payload for Invocation message."),t.invocationId!==void 0&&this._assertNotEmptyString(t.invocationId,"Invalid payload for Invocation message.")}_isStreamItemMessage(t){if(this._assertNotEmptyString(t.invocationId,"Invalid payload for StreamItem message."),t.item===void 0)throw new Error("Invalid payload for StreamItem message.")}_isCompletionMessage(t){if(t.result&&t.error)throw new Error("Invalid payload for Completion message.");!t.result&&t.error&&this._assertNotEmptyString(t.error,"Invalid payload for Completion message."),this._assertNotEmptyString(t.invocationId,"Invalid payload for Completion message.")}_isAckMessage(t){if(typeof t.sequenceId!="number")throw new Error("Invalid SequenceId for Ack message.")}_isSequenceMessage(t){if(typeof t.sequenceId!="number")throw new Error("Invalid SequenceId for Sequence message.")}_assertNotEmptyString(t,n){if(typeof t!="string"||t==="")throw new Error(n)}}const Hd={trace:S.Trace,debug:S.Debug,info:S.Information,information:S.Information,warn:S.Warning,warning:S.Warning,error:S.Error,critical:S.Critical,none:S.None};function qd(e){const t=Hd[e.toLowerCase()];if(typeof t<"u")return t;throw new Error(`Unknown log level: ${e}`)}class Vd{configureLogging(t){if(Ce.isRequired(t,"logging"),jd(t))this.logger=t;else if(typeof t=="string"){const n=qd(t);this.logger=new ds(n)}else this.logger=new ds(t);return this}withUrl(t,n){return Ce.isRequired(t,"url"),Ce.isNotEmpty(t,"url"),this.url=t,typeof n=="object"?this.httpConnectionOptions={...this.httpConnectionOptions,...n}:this.httpConnectionOptions={...this.httpConnectionOptions,transport:n},this}withHubProtocol(t){return Ce.isRequired(t,"protocol"),this.protocol=t,this}withAutomaticReconnect(t){if(this.reconnectPolicy)throw new Error("A reconnectPolicy has already been set.");return t?Array.isArray(t)?this.reconnectPolicy=new Ui(t):this.reconnectPolicy=t:this.reconnectPolicy=new Ui,this}withServerTimeout(t){return Ce.isRequired(t,"milliseconds"),this._serverTimeoutInMilliseconds=t,this}withKeepAliveInterval(t){return Ce.isRequired(t,"milliseconds"),this._keepAliveIntervalInMilliseconds=t,this}withStatefulReconnect(t){return this.httpConnectionOptions===void 0&&(this.httpConnectionOptions={}),this.httpConnectionOptions._useStatefulReconnect=!0,this._statefulReconnectBufferSize=t?.bufferSize,this}build(){const t=this.httpConnectionOptions||{};if(t.logger===void 0&&(t.logger=this.logger),!this.url)throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");const n=new Ld(this.url,t);return Mo.create(n,this.logger||Fn.instance,this.protocol||new Fd,this.reconnectPolicy,this._serverTimeoutInMilliseconds,this._keepAliveIntervalInMilliseconds,this._statefulReconnectBufferSize)}}function jd(e){return e.log!==void 0}const Ud={class:"color-selector-wrapper"},zd=["title"],Kd={key:0,class:"color-selector"},Gd={class:"color-header"},Xd={class:"color-hex"},Yd={class:"slider-group"},Jd={class:"slider-group"},Qd={class:"slider-group"},Zd={class:"preset-colors"},eh={class:"preset-grid"},th=["onClick"],nh=gt({__name:"ColorSelector",emits:["colorChange"],setup(e,{emit:t}){const n=t,s=ce(!1),o=ce(0),i=ce(0),r=ce(100),a=["#FFFFFF","#000000","#FF0000","#00FF00","#0000FF","#FFFF00","#FF00FF","#00FFFF","#FFA500","#800080"],l=(w,T,N)=>{T=T/100,N=N/100;const A=N*T,q=A*(1-Math.abs(w/60%2-1)),O=N-A;let B=0,j=0,L=0;return w>=0&&w<60?(B=A,j=q,L=0):w>=60&&w<120?(B=q,j=A,L=0):w>=120&&w<180?(B=0,j=A,L=q):w>=180&&w<240?(B=0,j=q,L=A):w>=240&&w<300?(B=q,j=0,L=A):(B=A,j=0,L=q),{r:Math.round((B+O)*255),g:Math.round((j+O)*255),b:Math.round((L+O)*255)}},u=(w,T,N)=>"#"+[w,T,N].map(A=>{const q=A.toString(16);return q.length===1?"0"+q:q}).join("").toUpperCase(),c=xe(()=>{const w=l(o.value,i.value,r.value);return{...w,hex:u(w.r,w.g,w.b)}}),h=()=>{n("colorChange",c.value)},p=w=>{const T=parseInt(w.substring(1,3),16),N=parseInt(w.substring(3,5),16),A=parseInt(w.substring(5,7),16),q=T/255,O=N/255,B=A/255,j=Math.max(q,O,B),L=Math.min(q,O,B),U=j-L;r.value=j*100,i.value=j===0?0:U/j*100,U===0?o.value=0:j===q?o.value=60*((O-B)/U%6):j===O?o.value=60*((B-q)/U+2):o.value=60*((q-O)/U+4),o.value<0&&(o.value+=360),h()},g=xe(()=>"linear-gradient(to right, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%)"),y=xe(()=>{const w=l(o.value,100,100);return`linear-gradient(to right, #ffffff 0%, ${u(w.r,w.g,w.b)} 100%)`}),_=xe(()=>"linear-gradient(to right, #000000 0%, #ffffff 100%)"),b=()=>{s.value=!s.value};return(w,T)=>(le(),pe("div",Ud,[C("div",{class:"color-circle",style:Oe({backgroundColor:c.value.hex}),onClick:b,title:s.value?"Close color picker":"Open color picker"},null,12,zd),s.value?(le(),pe("div",Kd,[C("div",Gd,[C("div",{class:"color-display",style:Oe({backgroundColor:c.value.hex})},[C("span",Xd,Be(c.value.hex),1)],4),C("button",{class:"close-button",onClick:b},"")]),C("div",Yd,[T[3]||(T[3]=C("label",null,"Hue",-1)),Ns(C("input",{type:"range",min:"0",max:"360","onUpdate:modelValue":T[0]||(T[0]=N=>o.value=N),onInput:h,class:"slider hue-slider",style:Oe({background:g.value})},null,36),[[Hs,o.value,void 0,{number:!0}]])]),C("div",Jd,[T[4]||(T[4]=C("label",null,"Saturation",-1)),Ns(C("input",{type:"range",min:"0",max:"100","onUpdate:modelValue":T[1]||(T[1]=N=>i.value=N),onInput:h,class:"slider saturation-slider",style:Oe({background:y.value})},null,36),[[Hs,i.value,void 0,{number:!0}]])]),C("div",Qd,[T[5]||(T[5]=C("label",null,"Brightness",-1)),Ns(C("input",{type:"range",min:"0",max:"100","onUpdate:modelValue":T[2]||(T[2]=N=>r.value=N),onInput:h,class:"slider value-slider",style:Oe({background:_.value})},null,36),[[Hs,r.value,void 0,{number:!0}]])]),C("div",Zd,[T[6]||(T[6]=C("div",{class:"preset-label"},"Presets:",-1)),C("div",eh,[(le(),pe(Ee,null,Rn(a,N=>C("button",{key:N,class:"preset-color",style:Oe({backgroundColor:N}),onClick:A=>p(N)},null,12,th)),64))])])])):kt("",!0)]))}}),sh=sn(nh,[["__scopeId","data-v-c85ba3c9"]]),oh={key:0,class:"status-stats"},ih={class:"brush-size-selector"},rh=["onClick","title"],Je=256,Qe=256,ah=gt({__name:"Canvas",setup(e,{expose:t}){const n=ce(null);let s=null,o=null,i=null;const r=ce("disconnected"),a=ce(0),l=ce(0),u=ce(.9),c=ce(0),h=ce(0),p=ce(!1),g=ce(0),y=ce(0),_=ce(!1),b=ce(1),w=D=>{b.value=D},T=D=>{D.stopPropagation()},N=D=>{D.stopPropagation()},A=ce({r:255,g:255,b:255,hex:"#FFFFFF"}),q=D=>{A.value=D},O=D=>D/Qe,B=xe(()=>{const D=n.value?.parentElement;if(!D)return{transform:`translate(${c.value}px, ${h.value}px) scale(${u.value})`,transformOrigin:"0 0"};const v=O(D.clientHeight),R=u.value*v;return{transform:`translate(${c.value}px, ${h.value}px) scale(${R})`,transformOrigin:"0 0"}}),j=(D,v,R,I,W,K=255)=>{if(!o||!s||D<0||D>=Je||v<0||v>=Qe)return!1;const d=(v*Je+D)*4;return o.data[d]===R&&o.data[d+1]===I&&o.data[d+2]===W&&o.data[d+3]===K?!1:(o.data[d]=R,o.data[d+1]=I,o.data[d+2]=W,o.data[d+3]=K,!0)},L=(D,v,R)=>{const I=R.replace("#",""),W=parseInt(I.substring(0,2),16),K=parseInt(I.substring(2,4),16),d=parseInt(I.substring(4,6),16),f=I.length===8?parseInt(I.substring(6,8),16):255;j(D,v,W,K,d,f)},U=()=>{!s||!o||s.putImageData(o,0,0)},te=()=>{s&&(s.fillStyle="#FFFFFF",s.fillRect(0,0,Je,Qe),o&&(o=s.getImageData(0,0,Je,Qe)))},V=(D,v,R)=>{for(let I=-R;I<=R;I++)for(let W=-R;W<=R;W++)if(W*W+I*I<=R*R){const K=D+W,d=v+I;j(K,d,A.value.r,A.value.g,A.value.b,255)&&i&&r.value==="connected"&&(i.invoke("SetPixel",{x:K,y:d,color:{R:A.value.r,G:A.value.g,B:A.value.b}}).then(()=>{l.value++}).catch(m=>{console.error("Failed to send pixel to hub:",m)}),console.log(`Pixel set at (${K}, ${d}) with color (${A.value.r}, ${A.value.g}, ${A.value.b})`))}},ee=D=>{if(!n.value)return null;const v=n.value.getBoundingClientRect(),R=D.clientX-v.left,I=D.clientY-v.top,W=v.width/Je,K=v.height/Qe,d=Math.floor(R/W),f=Math.floor(I/K);return{x:d,y:f}},we=async()=>{try{console.log("Initializing SignalR connection to /canvas..."),r.value="connecting",i=new Vd().withUrl("http://localhost:8080/canvas").withAutomaticReconnect().configureLogging(S.Information).build(),i.on("PixelReceived",D=>{a.value++,j(D.x,D.y,D.color.r,D.color.g,D.color.b,255),U()}),i.on("PixelUpdated",D=>{const v=D.color.r??D.color.R??0,R=D.color.g??D.color.G??0,I=D.color.b??D.color.B??0;console.log(`Pixel updated at (${D.x}, ${D.y}): (${v}, ${R}, ${I})`),j(D.x,D.y,v,R,I,255),U()}),i.on("CanvasStreamComplete",D=>{console.log(`Canvas stream complete: ${D} pixels received`),U()}),i.on("CanvasStreamFailed",D=>{console.error(`Canvas stream failed: ${D}`)}),i.onreconnecting(()=>{console.warn("Connection lost, reconnecting..."),r.value="connecting"}),i.onreconnected(()=>{console.log("Reconnected successfully"),r.value="connected",Re()}),i.onclose(D=>{console.error(`Connection closed: ${D||"No error details"}`),r.value="disconnected"}),await i.start(),console.log("Connected successfully to CanvasHub"),r.value="connected",await Re()}catch(D){console.error("Failed to connect to hub:",D),r.value="disconnected"}},Re=async()=>{if(!i||r.value!=="connected"){console.warn("Cannot stream canvas: not connected");return}try{console.log("Requesting canvas stream..."),await i.invoke("StreamCanvas")}catch(D){console.error("Failed to stream canvas:",D)}},ve=async()=>{if(i)try{await i.stop(),console.log("Disconnected from hub")}catch(D){console.error("Error disconnecting from hub:",D)}};ws(()=>{n.value&&(console.log("Canvas mounted, dimensions:",Je,"x",Qe),n.value.width=Je,n.value.height=Qe,s=n.value.getContext("2d",{willReadFrequently:!0}),s&&(console.log("Context acquired"),o=s.getImageData(0,0,Je,Qe),console.log("ImageData acquired, size:",o.data.length),te(),setTimeout(()=>{Ge()},100),we()))}),Cs(()=>{ve()});const oe=()=>s,ne=()=>n.value,Ge=()=>{u.value=.9;const D=n.value?.parentElement;if(D&&n.value){const v=D.clientWidth,R=D.clientHeight,I=O(R),W=u.value*I,K=Je*W,d=Qe*W;c.value=(v-K)/2,h.value=(R-d)/2}},at=D=>{if(D.preventDefault(),!n.value)return;const I=(D.deltaY>0?-1:1)*.05*u.value,W=Math.max(.05,Math.min(100,u.value+I)),K=n.value.parentElement;if(K){const d=K.clientWidth/2,f=K.clientHeight/2;c.value=d-(d-c.value)*(W/u.value),h.value=f-(f-h.value)*(W/u.value)}u.value=W},Xe=D=>{if(!D.target.closest(".toolbar")){if(D.button===2)p.value=!0,g.value=D.clientX-c.value,y.value=D.clientY-h.value;else if(D.button===0){_.value=!0;const R=ee(D);R&&R.x>=0&&R.x<Je&&R.y>=0&&R.y<Qe&&(V(R.x,R.y,b.value),U())}}},Ae=D=>{if(p.value)c.value=D.clientX-g.value,h.value=D.clientY-y.value;else if(_.value){const v=ee(D);v&&v.x>=0&&v.x<Je&&v.y>=0&&v.y<Qe&&(V(v.x,v.y,b.value),U())}},Pt=()=>{p.value=!1,_.value=!1},It=()=>{p.value=!1,_.value=!1},mt=D=>{D.preventDefault()};return t({setPixel:j,setPixelHex:L,render:U,clear:te,getContext:oe,getCanvas:ne,brushRadius:b,width:Je,height:Qe}),(D,v)=>(le(),pe("div",{class:"canvas-container",onWheel:at,onMousedown:Xe,onMousemove:Ae,onMouseup:Pt,onMouseleave:It,onContextmenu:mt},[C("canvas",{ref_key:"canvasRef",ref:n,class:"canvas",style:Oe(B.value)},null,4),C("div",{class:tn(["status-badge",r.value])},[v[0]||(v[0]=C("div",{class:"status-dot"},null,-1)),C("span",null,Be(r.value==="connected"?"Connected":r.value==="connecting"?"Connecting...":"Disconnected"),1),r.value==="connected"?(le(),pe("div",oh,[C("span",null,""+Be(a.value),1),C("span",null,""+Be(l.value),1)])):kt("",!0)],2),C("div",{class:"toolbar",onMousedown:N,onClick:T},[ue(sh,{onColorChange:q}),v[1]||(v[1]=C("div",{class:"separator"},null,-1)),C("div",ih,[(le(),pe(Ee,null,Rn([0,1,2],R=>C("button",{key:R,class:tn(["brush-size-button",{active:b.value===R}]),onClick:I=>w(R),title:R===0?"Single pixel":`Radius ${R}`},[C("div",{class:"brush-preview",style:Oe({width:`${R*2+8}px`,height:`${R*2+8}px`})},null,4)],10,rh)),64))]),v[2]||(v[2]=C("div",{class:"separator"},null,-1)),C("button",{class:"reset-button",onClick:Ge,title:"Reset view"})],32)],32))}}),lh=sn(ah,[["__scopeId","data-v-a6bbc05e"]]),ch=gt({__name:"CanvasView",setup(e){return(t,n)=>(le(),pe("main",null,[ue(lh)]))}}),uh=sn(ch,[["__scopeId","data-v-dc4e1529"]]),dh=["id"],hh={class:"node-content"},fh=["innerHTML"],ph={class:"node-title"},gh={key:0,class:"node-badge"},mh={class:"tooltip-header"},vh={class:"tooltip-section"},bh={class:"tooltip-value"},yh={key:0,class:"tooltip-section"},_h={class:"tooltip-value"},wh={key:1,class:"tooltip-section"},Ch={class:"tooltip-value"},Sh={key:2,class:"tooltip-section"},kh={class:"tooltip-value"},xh={class:"tooltip-section tooltip-description"},Th={class:"tooltip-value"},Eh=gt({__name:"DiagramNode",props:{id:{},title:{},description:{},icon:{},position:{},targetSection:{},count:{},nodeType:{},language:{},scaling:{}},emits:["click","hover"],setup(e,{emit:t}){const n=e,s=t,o=ce(!1),i=xe(()=>{const u=n.position.x;return u<150?"right":u>950?"left":"center"}),r=()=>{o.value=!0,s("hover",n.id,!0)},a=()=>{o.value=!1,s("hover",n.id,!1)},l=()=>{if(s("click",n.id,n.targetSection),n.targetSection){const u=document.getElementById(n.targetSection);u&&u.scrollIntoView({behavior:"smooth",block:"start"})}};return(u,c)=>(le(),pe("div",{class:"diagram-node",style:Oe({left:e.position.x+"px",top:e.position.y+"px"}),id:`node-${n.id}`,onMouseenter:r,onMouseleave:a,onClick:l},[C("div",hh,[C("div",null,[C("div",{class:"node-icon",innerHTML:e.icon},null,8,fh),C("div",ph,Be(e.title),1),e.count&&e.count>1?(le(),pe("span",gh,Be(e.count),1)):kt("",!0)])]),ue(kc,{name:"tooltip"},{default:Er(()=>[o.value?(le(),pe("div",{key:0,class:tn(["tooltip",`tooltip-${i.value}`])},[C("div",mh,Be(e.title),1),C("div",vh,[c[0]||(c[0]=C("div",{class:"tooltip-label"},"Type:",-1)),C("div",bh,Be(e.nodeType),1)]),e.language?(le(),pe("div",yh,[c[1]||(c[1]=C("div",{class:"tooltip-label"},"Language:",-1)),C("div",_h,Be(e.language),1)])):kt("",!0),e.count&&e.count>1?(le(),pe("div",wh,[c[2]||(c[2]=C("div",{class:"tooltip-label"},"Instances:",-1)),C("div",Ch,Be(e.count),1)])):kt("",!0),e.scaling?(le(),pe("div",Sh,[c[3]||(c[3]=C("div",{class:"tooltip-label"},"Scaling:",-1)),C("div",kh,Be(e.scaling),1)])):kt("",!0),C("div",xh,[c[4]||(c[4]=C("div",{class:"tooltip-label"},"Description:",-1)),C("div",Th,Be(e.description),1)])],2)):kt("",!0)]),_:1})],44,dh))}}),Rh=sn(Eh,[["__scopeId","data-v-4bcf1bc9"]]),Ah={class:"connections-layer",width:"1300",height:"auto",viewBox:"0 0 1300 550"},Ph=["x","y","width","height"],Ih=["x","y"],Dh=["d","stroke-width","stroke-dasharray","opacity"],Nh=["x","y"],Mh=gt({__name:"InteractiveDiagram",props:{nodes:{},connections:{},hpaGroups:{}},setup(e){const t=e,n=ce(null),s=ce(null),o=ce(null),i=ce(1300),r=xe(()=>i.value/1300),a=(y,_)=>{s.value=y,setTimeout(()=>{s.value=null},1e3)},l=(y,_)=>{o.value=_?y:null},u=y=>{const _=t.nodes.find(b=>b.id===y);return _?{x:_.position.x+85,y:_.position.y+60}:{x:0,y:0}},c=(y,_)=>{const b=u(y),w=_.x-b.x,T=_.y-b.y,N=Math.atan2(T,w),A=100,q=105,O=A/2,B=q/2,j=Math.cos(N),L=Math.sin(N),U=Math.sqrt(1/(j*j/(O*O)+L*L/(B*B)));return{x:b.x+j*U,y:b.y+L*U}},h=y=>{const _=u(y.from),b=u(y.to),w=c(y.from,b),T=c(y.to,_),N=T.x-w.x,A=T.y-w.y,q=Math.abs(N)*.3;return y.label==="Register"&&y.from==="backend"?`M ${w.x} ${w.y} Q ${w.x+q} ${w.y+A*2.5}, ${T.x} ${T.y+30}`:y.label==="Consensus"?`M ${w.x+10} ${w.y+20} Q ${w.x+10+q} ${w.y+A*.5}, ${T.x+10} ${T.y}`:y.label==="Forward"?`M ${w.x-10} ${w.y} Q ${w.x-10+q} ${w.y+A*.5-20}, ${T.x-10} ${T.y+20}`:y.label==="Global Clock"?`M ${w.x} ${w.y+20} Q ${w.x+q*-2} ${w.y+20+A*.5}, ${T.x} ${T.y+20}`:`M ${w.x} ${w.y} Q ${w.x+q} ${w.y+A/2}, ${T.x} ${T.y}`},p=y=>{const _=u(y.from),b=u(y.to);return y.label=="W:3 / R:2"?{x:(_.x+b.x)/2+150,y:(_.y+b.y)/2-12}:y.label=="Consensus"?{x:(_.x+b.x)/2+50,y:(_.y+b.y)/2-10}:y.label=="Forward"?{x:(_.x+b.x)/2-40,y:(_.y+b.y)/2+10}:y.label=="Register"&&y.from==="backend"?{x:(_.x+b.x)/2+130,y:(_.y+b.y)/2+90}:y.label=="Register"&&y.from==="controller"?{x:(_.x+b.x)/2,y:(_.y+b.y)/2-5}:y.label=="Global Clock"?{x:(_.x+b.x)/2,y:(_.y+b.y)/2+45}:{x:(_.x+b.x)/2,y:(_.y+b.y)/2-12}},g=()=>{n.value&&(i.value=n.value.offsetWidth)};return ws(()=>{g(),window.addEventListener("resize",g)}),Cs(()=>{window.removeEventListener("resize",g)}),(y,_)=>(le(),pe("div",{class:"interactive-diagram",ref_key:"diagramContainer",ref:n,style:Oe({"--scale":r.value})},[C("div",{class:"diagram-content",style:Oe({transform:`scale(${r.value})`,transformOrigin:"top left"})},[(le(),pe("svg",Ah,[_[0]||(_[0]=C("defs",null,[C("marker",{id:"arrowhead",markerWidth:"10",markerHeight:"10",refX:"9",refY:"3",orient:"auto"},[C("polygon",{points:"0 0, 10 3, 0 6",fill:"#ffffff",opacity:"1"})])],-1)),(le(!0),pe(Ee,null,Rn(e.hpaGroups,b=>(le(),pe("g",{key:b.id},[C("rect",{x:b.x,y:b.y,width:b.width,height:b.height,fill:"none",stroke:"#ffffff","stroke-width":"2","stroke-dasharray":"8,4",rx:"20",ry:"20",opacity:"0.3"},null,8,Ph),C("text",{x:b.x+b.width/2,y:b.y-5,class:"hpa-label","text-anchor":"middle"},Be(b.label),9,Ih)]))),128)),(le(!0),pe(Ee,null,Rn(e.connections,b=>(le(),pe("g",{key:`${b.from}-${b.to}`},[C("path",{d:h(b),stroke:"#ffffff","stroke-width":b.bold?"3":"1.5",fill:"none","stroke-dasharray":b.dashed?"5,5":"none",opacity:b.faded?"0.1":"0.6","marker-end":"url(#arrowhead)",class:tn({"connection-active":s.value===b.from||s.value===b.to,"connection-hover":o.value===b.from||o.value===b.to})},null,10,Dh),b.label?(le(),pe("text",{key:0,x:p(b).x,y:p(b).y,class:"connection-label","text-anchor":"middle"},Be(b.label),9,Nh)):kt("",!0)]))),128))])),(le(!0),pe(Ee,null,Rn(e.nodes,b=>(le(),Ro(Rh,{key:b.id,id:b.id,title:b.title,description:b.description,icon:b.icon,position:b.position,"target-section":b.targetSection,count:b.count,"node-type":b.nodeType,language:b.language,scaling:b.scaling,onClick:a,onHover:l},null,8,["id","title","description","icon","position","target-section","count","node-type","language","scaling"]))),128))],4)],4))}}),$h=sn(Mh,[["__scopeId","data-v-fe149721"]]),Bh={class:"scalable-svg-container"},Lh=["src","alt"],Oh=["src","alt"],Wh=gt({__name:"ScalableSvg",props:{src:{},alt:{}},setup(e){const t=ce(!1),n=ce(1),s=ce(0),o=ce(0),i=ce(null);let r=!1,a=0,l=0,u=0;const c=xe(()=>({transform:`translate(${s.value}px, ${o.value}px) scale(${n.value})`,transformOrigin:"center center",transition:r?"none":"transform 0.2s ease-out"})),h=()=>{t.value=!0,document.body.style.overflow="hidden"},p=()=>{t.value=!1,document.body.style.overflow="",_()},g=()=>{n.value=Math.min(n.value*1.2,5)},y=()=>{n.value=Math.max(n.value/1.2,.5)},_=()=>{n.value=1,s.value=0,o.value=0},b=O=>{O.preventDefault();const B=O.deltaY>0?.9:1.1;n.value=Math.min(Math.max(n.value*B,.5),5)},w=O=>{r=!0,a=O.clientX-s.value,l=O.clientY-o.value;const B=L=>{r&&(s.value=L.clientX-a,o.value=L.clientY-l)},j=()=>{r=!1,document.removeEventListener("mousemove",B),document.removeEventListener("mouseup",j)};document.addEventListener("mousemove",B),document.addEventListener("mouseup",j)},T=O=>{if(O.length<2)return 0;const B=O.item(0),j=O.item(1);if(!B||!j)return 0;const L=B.clientX-j.clientX,U=B.clientY-j.clientY;return Math.sqrt(L*L+U*U)},N=O=>{if(O.touches.length===2)u=T(O.touches);else if(O.touches.length===1){const B=O.touches.item(0);if(!B)return;r=!0,a=B.clientX-s.value,l=B.clientY-o.value}},A=O=>{if(O.preventDefault(),O.touches.length===2){const B=T(O.touches);if(u>0){const j=B/u;n.value=Math.min(Math.max(n.value*j,.5),5)}u=B}else if(O.touches.length===1&&r){const B=O.touches.item(0);if(!B)return;s.value=B.clientX-a,o.value=B.clientY-l}},q=()=>{r=!1,u=0};return(O,B)=>(le(),pe("div",Bh,[C("img",{src:e.src,alt:e.alt,class:"scalable-svg",onClick:h,role:"button",tabindex:"0",onKeydown:[xi(h,["enter"]),xi(h,["space"])]},null,40,Lh),(le(),Ro(yl,{to:"body"},[t.value?(le(),pe("div",{key:0,class:"fullscreen-overlay",onClick:ki(p,["self"])},[C("button",{class:"close-button",onClick:p,"aria-label":"Close fullscreen view"},[...B[0]||(B[0]=[C("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[C("path",{d:"M18 6L6 18M6 6l12 12"})],-1)])]),C("div",{class:"zoom-controls"},[C("button",{onClick:g,"aria-label":"Zoom in"},"+"),C("button",{onClick:_,"aria-label":"Reset zoom"},"Reset"),C("button",{onClick:y,"aria-label":"Zoom out"},"")]),C("div",{class:"fullscreen-content",ref_key:"contentRef",ref:i,onWheel:ki(b,["prevent"]),onMousedown:w,onTouchstart:N,onTouchmove:A,onTouchend:q},[C("img",{src:e.src,alt:e.alt,class:"fullscreen-svg",style:Oe(c.value),draggable:"false"},null,12,Oh)],544)])):kt("",!0)]))]))}}),Mt=sn(Wh,[["__scopeId","data-v-7b356373"]]),Fh="/assets/AspNetBackendSequenceDiagram.drawio-DvfwrMRU.svg",Hh="/assets/AspNetBackendComponents.drawio-DsWqwHyT.svg",qh="/assets/GoPartitioningControllerComponentsDark.drawio-CqKddHQa.svg",Vh="/assets/VeritasComponentsDark.drawio-C1MCIKzc.svg",jh="/assets/VeritasGetSetSequenceDiagramDark.drawio-DsKKUgHi.svg",Uh="/assets/VeritasLeaderElectionSequenceDark.drawio-Blsd4mkj.svg",zh="/assets/NoredbComponentsDark.drawio-BM6qmOrz.svg",Kh="/assets/NoredbSequenceDark.drawio-DsWSdWDT.svg",Gh={class:"about"},Xh={class:"project-structure"},Yh={class:"system-overview"},Jh={class:"interactive-diagram"},Qh={id:"aspnet-backend",class:"component-detail"},Zh={class:"diagram-container"},ef={class:"diagram-container"},tf={id:"partitioning-controller",class:"component-detail"},nf={class:"diagram-container"},sf={id:"veritas-consensus",class:"component-detail"},of={class:"diagram-container"},rf={class:"diagram-container"},af={class:"diagram-container"},lf={id:"noredb-cluster",class:"component-detail"},cf={class:"diagram-container"},uf={class:"diagram-container"},df=gt({__name:"AboutView",setup(e){const t=[{id:"user-pc",title:"Desktop",description:"Desktop browser client accessing WebCanvas via WebSocket connection to backend",icon:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2" fill="none" stroke="currentColor" stroke-width="2"/><path d="M8 21h8M12 17v4" stroke="currentColor" stroke-width="2"/></svg>',position:{x:0,y:120},targetSection:"client-web",nodeType:"Client Device",count:1},{id:"user-mobile",title:"Mobile",description:"Mobile smartphone client accessing WebCanvas with touch interface",icon:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="6" y="2" width="12" height="20" rx="2" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="12" cy="19" r="1" fill="currentColor"/></svg>',position:{x:0,y:350},targetSection:"client-web",nodeType:"Client Device",count:1},{id:"backend",title:"ASP.NET Backend",description:"Handles real-time WebSocket connections via SignalR, broadcasts pixel updates, manages cache invalidation between instances",icon:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><path d="M2 12h20M12 2c-2.5 4-2.5 16 0 20M12 2c2.5 4 2.5 16 0 20" stroke="currentColor" stroke-width="2" fill="none"/></svg>',position:{x:250,y:240},targetSection:"aspnet-backend",count:3,nodeType:"API Service",language:"C# ASP.NET Core",scaling:"Kubernetes HPA (2-10 pods)"},{id:"controller",title:"Partitioning Controller",description:"Manages canvas state distribution and partitioning logic, routes requests to appropriate NoReDB instances based on hash partitioning",icon:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2L2 7v10c0 5 10 7 10 7s10-2 10-7V7z" fill="none" stroke="currentColor" stroke-width="2"/><path d="M12 12v10M12 12L2 7M12 12l10-5" stroke="currentColor" stroke-width="2"/></svg>',position:{x:520,y:240},targetSection:"partitioning-controller",count:3,nodeType:"Service Router",language:"Go",scaling:"Kubernetes HPA (2-8 pods)"},{id:"veritas-leader",title:"Veritas Leader",description:"Consensus leader node using custom protocol for service registration, health checking, and coordination. Maintains distributed system state",icon:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2l2 7h7l-5.5 4.5L17 21l-5-4-5 4 1.5-7.5L3 9h7z" fill="currentColor"/></svg>',position:{x:785,y:100},targetSection:"veritas-consensus",count:1,nodeType:"Consensus Leader",language:"Rust",scaling:"StatefulSet (5 replicas)"},{id:"veritas-followers",title:"Veritas Followers",description:"Follower nodes participating in custom consensus protocol, providing redundancy and automatic leader failover",icon:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="12" cy="12" r="4" fill="currentColor"/></svg>',position:{x:785,y:310},targetSection:"veritas-consensus",count:4,nodeType:"Consensus Follower",language:"Rust",scaling:"StatefulSet (5 replicas)"},{id:"noredb",title:"NoReDB Cluster",description:"Distributed quorum-based database. Write-N:3 replicas per partition, Read-M:2 for quorum. Each partition maps to 3 random instances from the cluster",icon:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" fill="none" stroke="currentColor" stroke-width="2"/><path d="M3 9h18M3 15h18M9 3v18" stroke="currentColor" stroke-width="2"/></svg>',position:{x:1100,y:240},targetSection:"noredb-cluster",count:9,nodeType:"Database",language:"Rust",scaling:"StatefulSet (9 replicas)"}],n=[{id:"backend-hpa",label:"HPA: ASP.NET Backend",x:215,y:210,width:240,height:210},{id:"controller-hpa",label:"HPA: Partitioning Controllers",x:485,y:210,width:240,height:210},{id:"veritas-cluster",label:"Veritas Consensus Cluster",x:750,y:60,width:240,height:420}],s=[{from:"user-pc",to:"backend",label:"WebSocket",bold:!0},{from:"user-mobile",to:"backend",label:"WebSocket",bold:!0},{from:"backend",to:"controller",label:"gRPC",bold:!0},{from:"backend",to:"veritas-followers",label:"Register",dashed:!0,faded:!0},{from:"controller",to:"veritas-followers",label:"Register",dashed:!0,faded:!0},{from:"veritas-followers",to:"veritas-leader",label:"Forward",dashed:!0,faded:!0},{from:"veritas-leader",to:"veritas-followers",label:"Consensus"},{from:"veritas-leader",to:"noredb",label:"",faded:!0},{from:"veritas-followers",to:"noredb",label:"",faded:!0},{from:"controller",to:"noredb",label:"W:3 / R:2",bold:!0},{from:"veritas-followers",to:"controller",label:"Global Clock",dashed:!0,faded:!1}];return(o,i)=>(le(),pe("div",Gh,[i[40]||(i[40]=Ze('<h1>Distributed Systems: WebCanvas</h1><section class="project-attribution"><p><strong class="highlighted">Notice on AI Assistance:</strong> Large Language Models (LLMs), including Claude 4.5, ChatGPT, and Gemini, were utilized as pair-programming collaborators to assist in the development and documentation of this project. </p><p><strong>Division of Labor:</strong> The core system architecture and the implementation of high-complexity distributed systemsspecifically <strong>Veritas</strong> and <strong>NoReDB</strong> (Rust), and the <strong>Partitioning Controller</strong> (Go) were authored entirely by the developer. LLMs were primarily used to generate boilerplate code, technical documentation, and generic frontend components (Vue.js and SignalR). In this workflow, the models generated code based on the developer&#39;s strict specifications, which was then reviewed, refactored, and integrated manually to ensure it met project standards. </p><hr><p class="description"><strong>WebCanvas</strong> is a collaborative online drawing application built using Vue.js for the frontend and SignalR for real-time communication. It allows multiple users to draw on a shared canvas simultaneously, with changes reflected in real-time across all connected clients. The project was implemented for a University of Applied Sciences to demonstrate proficiency in real-time collaboration, system design, distributed databases, and modern web technologies. </p></section><section class="features"><h2>Features</h2><ul><li>Real-time collaborative drawing</li><li>Color selection with HSL sliders and preset colors</li><li>Responsive design for desktop and mobile devices</li><li>Built with Vue.js and SignalR for seamless real-time updates</li><li>Demonstrates real-time collaboration, system design, and distributed databases</li><li>Persistent canvas state stored in a distributed quorum based database for durability and scalability</li><li>Deployed on Kubernetes for scalability and reliability</li></ul></section><section class="technologies"><h2>Technologies Used</h2><ul><li><strong>Vue.js:</strong> A progressive JavaScript framework for building user interfaces.</li><li><strong>SignalR:</strong> A library for ASP.NET that enables real-time web functionality.</li><li><strong>TypeScript:</strong> A typed superset of JavaScript that compiles to plain JavaScript.</li><li><strong>CSS:</strong> Used for styling the application and ensuring a responsive design.</li><li><strong>HTML:</strong> The standard markup language for creating web pages and applications.</li><li><strong>Kubernetes:</strong> An open-source system for automating the deployment, scaling, and management of containerized applications.</li><li><strong>Docker:</strong> A platform for developing, shipping, and running applications in containers.</li><li><strong>ASP.NET Core:</strong> A cross-platform framework for building modern, cloud-based, and internet-connected applications.</li><li><strong>Go:</strong> A statically typed, compiled programming language designed for simplicity and performance.</li><li><strong>Rust:</strong> A systems programming language focused on safety, speed, and concurrency.</li></ul></section><section class="development-process"><h2>Development Process</h2><h3>Project Planning and Design</h3><p> Whether working solo or in small teams on educational, personal, or professional contracts, I have explored various methodologies including Agile, Scrum, <a href="https://publications.lib.chalmers.se/records/fulltext/147143.pdf" target="_blank">Agile Solo</a>, and <a href="https://arxiv.org/pdf/2209.14263" target="_blank">GLUX</a>. While I am a strong advocate for Agile principles, Ive found that the administrative burden of formal frameworks often outweighs the benefits in a solo context. This led me to adopt a lean, self-directed approach. </p><div class="challenges-opportunities"><h4>Unique Solo Dynamics</h4><ul><li><strong>Autonomous Scheduling:</strong> Minimal coordination needs allow for extreme flexibility, though it demands high self-discipline.</li><li><strong>Resource Constraints:</strong> As the sole developer, time is the most finite resource; every hour spent on administration is an hour taken from development.</li><li><strong>Streamlined Execution:</strong> Without dependencies on others, the &quot;speed of thought&quot; can more closely match the &quot;speed of code.&quot;</li></ul></div><div class="adaptation-flexibility"><h4>Adaptation and Flexibility</h4><p> Traditional time estimation is primarily a coordination tool. In solo projects, precise estimates are often unjustifiable because there are no external dependencies to synchronize. Forcing fixed-size sprints can create artificial pressure that leads to burnout rather than productivity. Instead, I focus on <strong>Adaptive Workflow</strong>addressing the most critical tasks without the constraints of a rigid schedule. </p><p> To support this, I utilize the <a href="https://learn.microsoft.com/en-us/azure/devops/boards/work-items/guidance/choose-process?view=azure-devops&amp;tabs=agile-process" target="_blank">Azure DevOps Basic Process</a>. This provides a lightweight framework for tracking progress without excessive overhead: </p><ul><li><strong>Backlog of Epics:</strong> High-level goals are defined as Epics. I use rough Story Point estimates solely to provide stakeholders with a general sense of project scope.</li><li><strong>Goal-Oriented Phases:</strong> Rather than traditional time-boxed sprints, I work in &quot;Phases&quot; (e.g., Design, Backend, Frontend). These are flexible periods focused on achieving specific milestones.</li><li><strong>Just-in-Time Refinement:</strong> I only break Epics into specific <em>Issues</em> and <em>Tasks</em> when I am actively working on that Phase. This prevents &quot;planning rot&quot; and ensures tasks reflect the current state of the project.</li></ul><p> This approach excels at handling emerging requirements. When new challenges or opportunities ariseas they often do during developmentI simply add them to the active Phase and prioritize them immediately. By maintaining this flexibility, I can adapt to customer feedback and technical discoveries far more effectively than a fixed plan would allow. </p><strong>Summary:</strong> By reducing administrative friction, I maximize &quot;maker time.&quot; This adaptive approach ensures that the project remains responsive to change while maintaining a steady, sustainable velocity. </div></section>',5)),C("section",Xh,[i[3]||(i[3]=C("div",{class:"project-structure"},[C("h2",null,"Project Structure"),C("ul",null,[C("li",null,"The project is organized into a frontend, backendstateless and backendstateful."),C("li",null,"The frontend is built with Vue.js and includes components for the canvas, color selector, and navigation bar."),C("li",null,"The backendstateless is implemented in C# and Go and handles real-time communication using SignalR and GRPC."),C("li",null,"The backendstateful is implemented in Rust and manages the persistent canvas state using a distributed quorum based database.")])],-1)),C("div",Yh,[i[2]||(i[2]=Ze("<h4>System Overview</h4><p> The frontend Vue.js application connects to the backend using SignalR for real-time updates. When a user draws on the canvas, the frontend sends pixel data to the backend, which then broadcasts it to all connected clients. The backend also persists the canvas state in a distributed database to ensure durability and scalability. The entire system is deployed on Kubernetes to handle varying loads and ensure high availability. </p><strong>Key Components:</strong><ul><li><strong>Vue.js - Frontend:</strong> Handles the user interface and interactions, including the canvas, color selector, and navigation bar.</li><li><strong>ASP.NET - Backend and SignalR:</strong> Manages real-time communication between the frontend and backend and cache invalidation between Backend instances.</li><li><strong>Go - Partitioning Controller:</strong> Manages the distribution of canvas state across multiple backend instances to ensure consistency and fault tolerance.</li><li><strong>Rust - NoReDB:</strong> Implements the distributed quorum based database for persistent canvas state storage.</li><li><strong>Rust - Veritas:</strong> Handles consensus and coordination for the distributed system.</li></ul>",4)),C("div",Jh,[i[0]||(i[0]=C("h4",{id:"system-diagram"},"Interactive System Diagram",-1)),i[1]||(i[1]=C("p",null," Below is a minimalistic interactive diagram illustrating the distributed architecture of WebCanvas. Hover over each component to see detailed statistics including language, instance count, and role. Click to jump to relevant sections. The diagram shows the complete distributed system with HPA-managed services and consensus coordination. ",-1)),ue($h,{nodes:t,connections:s,"hpa-groups":n})])])]),i[41]||(i[41]=Ze('<section id="client-web" class="component-detail"><h2>Web Client</h2><p> The web client is a Vue.js application accessible from any modern browser on desktop, laptop, mobile, or tablet devices. The responsive interface adapts seamlessly between mouse-based and touch-based interaction. </p><h3>SignalR Hub Connection</h3><p> Upon loading, the client establishes a persistent WebSocket connection to the ASP.NET Backend&#39;s SignalR hub. This bidirectional connection enables real-time communication with sub-millisecond latency, allowing instantaneous synchronization of drawing actions across all connected clients. </p><h3>Pixel-Level Canvas Updates</h3><p> When a user draws on the canvas, the application captures each pixel modification event: </p><ul><li><strong>Sending Updates:</strong> The client transmits pixel data (coordinates, color values) to the SignalR hub immediately as the user draws</li><li><strong>Receiving Updates:</strong> The client listens for incoming pixel updates from other users via the hub and renders them in real-time</li><li><strong>Local Rendering:</strong> Changes are applied to the HTML5 canvas element instantly for responsive user feedback</li></ul><h3>Interface Features</h3><ul><li>Full-screen canvas with mouse and touch support</li><li>HSL color picker with preset color palette</li><li>Brush size adjustment</li><li>Responsive layout adapting to all screen sizes</li><li>Real-time connection status indicator</li></ul></section>',1)),C("section",Qh,[i[6]||(i[6]=C("h2",null,"ASP.NET Backend (SignalR Hub)",-1)),i[7]||(i[7]=C("p",null," The ASP.NET Core backend serves as the central real-time communication hub for WebCanvas. Running as a horizontally scalable service with 2-10 pods managed by Kubernetes HPA, each instance handles WebSocket connections from multiple clients simultaneously while coordinating with the distributed database layer for persistence. ",-1)),i[8]||(i[8]=C("h3",null,"Language Choice: C# and ASP.NET Core",-1)),i[9]||(i[9]=C("p",null," C# and ASP.NET Core were chosen for the backend to leverage the mature ecosystem for building business logic and real-time web applications. SignalR, which is tightly integrated with the ASP.NET framework, provides first-class support for WebSocket management with features like automatic reconnection, connection grouping, and backplane integration that would require significant custom development in other languages. The .NET runtime's managed memory model and comprehensive standard library accelerate development of complex stateful services, while the framework's built-in dependency injection, logging, and configuration systems reduce boilerplate. For an educational project focused on distributed systems architecture rather than low-level performance optimization, C#'s productivity advantages and SignalR's real-time capabilities make it the pragmatic choice for handling WebSocket connections and orchestrating cache invalidation logic. ",-1)),i[10]||(i[10]=C("h3",null,"Architecture Overview",-1)),i[11]||(i[11]=C("p",null," As illustrated in Figure 1 below, the backend architecture follows a multi-layered approach where clients connect via WebSocket to the SignalR hub. When a pixel update arrives, the backend first persists it to the distributed database via the Partitioning Controller using gRPC, then broadcasts the update to all connected clients. When multiple backend instances scale horizontally, a custom in-memory cache ensures all instances broadcast updates to their respective clients, maintaining consistency across the distributed system. ",-1)),C("div",Zh,[ue(Mt,{src:Le(Hh),alt:"ASP.NET Backend Components Diagram"},null,8,["src"]),i[4]||(i[4]=C("p",{class:"diagram-caption"},"Figure 1: ASP.NET Backend component architecture and communication flows",-1))]),i[12]||(i[12]=C("h3",null,"SignalR Hub: Real-Time Communication",-1)),i[13]||(i[13]=C("p",null," The SignalR hub manages WebSocket connections and message broadcasting for the collaborative canvas demonstration. Each client establishes a persistent WebSocket connection to a specific backend instance, where the hub tracks all active connections. When a client sends pixel update data, the hub first ensures the data is persisted to the database, then broadcasts the update to all other connected clients on the same instance. Built-in reconnection logic handles temporary network disruptions transparently. The canvas serves as a demonstration vehicle to showcase the distributed database's capabilities in handling real-time, concurrent updates. ",-1)),i[14]||(i[14]=C("h3",null,"Multi-Instance Coordination",-1)),i[15]||(i[15]=C("p",null," Figure 2 below illustrates the sequence of operations when multiple backend instances run concurrently under HPA scaling. After a backend instance successfully persists a pixel update to the database, it uses a custom in-memory cache to notify other backend instances (B, C, etc.) to broadcast the same update to their connected clients. This architecture ensures all clients see updates regardless of which instance they're connected to, while no single instance holds authoritative stateall coordinate through the Partitioning Controller and NoReDB cluster. ",-1)),C("div",ef,[ue(Mt,{src:Le(Fh),alt:"ASP.NET Backend Sequence Diagram"},null,8,["src"]),i[5]||(i[5]=C("p",{class:"diagram-caption"},"Figure 2: Multi-instance coordination sequence showing cache invalidation flow",-1))]),i[16]||(i[16]=C("h3",null,"gRPC Communication with Partitioning Controller",-1)),i[17]||(i[17]=C("p",null," For persistence, the backend communicates with the Partitioning Controller via gRPC as shown in the diagrams above. When pixel updates arrive, the pixel data is sent to the Partitioning Controller using Protocol Buffers for efficient serialization. The backend waits for database write confirmation before broadcasting updates to clients and peers, ensuring data durability. Multiple pixel updates are batched within a time window before transmission to optimize invalidation call overhead. If the Partitioning Controller becomes unavailable, Kubernetes automatically manages failover through its HPA and Service mechanisms, routing requests to healthy controller instances while maintaining real-time functionality for connected clients. ",-1)),i[18]||(i[18]=C("h3",null,"Service Registration with Veritas",-1)),i[19]||(i[19]=C("p",null," Each backend instance registers itself with the Veritas consensus cluster for service discovery and health monitoring. On startup, the instance sends a registration request to any Veritas follower, which forwards it to the leader. Periodic heartbeats confirm the instance is alive; missed heartbeats trigger automatic deregistration. Load balancing is handled through Kubernetes Service mechanisms or via random selection. During graceful shutdown, the instance deregisters itself before closing connections, allowing clients to reconnect to healthy instances. ",-1))]),C("section",tf,[i[21]||(i[21]=C("h2",null,"Partitioning Controller",-1)),i[22]||(i[22]=C("p",null," The Partitioning Controller is a Go-based service that manages the distribution of data across the NoReDB cluster. Running as a horizontally scalable service with 2-8 pods under Kubernetes HPA, it implements a leader-follower architecture where one instance acts as the leader responsible for partition management and assignment decisions, while follower instances stand ready for automatic failover. The controller acts as an intelligent router, translating pixel coordinates into partition IDs and directing read/write operations to the appropriate NoReDB instances based on the current partition mapping. ",-1)),i[23]||(i[23]=C("h3",null,"Language Choice: Go for Performance and Scalability",-1)),i[24]||(i[24]=C("p",null,[oo(" Go was selected for the Partitioning Controller due to its exceptional characteristics for building fast, lightweight coordination services. The language's lightweight goroutines enable handling thousands of concurrent requests with minimal memory overheadcritical when coordinating operations across multiple NoReDB instances and managing parallel reads and writes. Go's fast compilation and small binary sizes (typically 10-20 MB) enable rapid container startup times, allowing Kubernetes HPA to spin up new controller instances in seconds to meet demand spikes. The language's built-in concurrency primitives (channels, goroutines, and the "),C("code",null,"sync"),oo(" package) make it natural to express the controller's parallel operationssuch as broadcasting writes to multiple replicas or racing reads against a quorumwithout complex threading libraries or callback chains. Additionally, Go's strong static typing and simple error handling model reduce bugs in the critical path of data operations, while its efficient garbage collector ensures predictable latency even under heavy load. For a component that must scale elastically and route requests with minimal overhead, Go's performance-per-watt and operational simplicity make it ideal. ")],-1)),i[25]||(i[25]=C("h3",null,"Understanding NoSQL and Distributed Data Storage",-1)),i[26]||(i[26]=C("p",null," Before diving into the partitioning mechanics, it's essential to understand what NoReDB represents. NoSQL databases differ fundamentally from traditional relational databases by eschewing fixed schemas and ACID guarantees in favor of horizontal scalability and high availability. NoReDB (No-Relational Database) is a custom-built key-value storethe simplest form of NoSQL databasewhere data is stored as simple key-value pairs rather than in structured tables with relationships. This architectural choice enables massive scalability: instead of a single powerful server, the database can spread data across many commodity servers, with each handling a subset of the total workload. ",-1)),C("div",nf,[ue(Mt,{src:Le(qh),alt:"Partitioning Controller Components Diagram"},null,8,["src"]),i[20]||(i[20]=C("p",{class:"diagram-caption"},"Figure 3: Partitioning Controller architecture showing leader election, partition management, and NoReDB cluster coordination",-1))]),i[27]||(i[27]=Ze(`<h3>Partitioning: Dividing Data Across Nodes</h3><p> Partitioning (also called sharding) is the technique of dividing a dataset into smaller, manageable chunks called partitions, with each partition stored on different physical nodes. In WebCanvas, the e.g. 65,536 possible pixel coordinates (e.g. 256256 canvas) are divided into a configurable number of partitions. The controller uses a deterministic hash-based approach: each pixel&#39;s 16-bit coordinates are hashed into a 32-bit key using <code>PixelToKey(x, y)</code>, then mapped to a partition using modulo arithmetic. This ensures that the same pixel always maps to the same partition, regardless of which controller instance handles the request. </p><p> The partition assignment strategy illustrated in Figure 3 shows how the system maintains a configuration mapping each partition to multiple NoReDB instances. For example, partition 0 might be stored on NoReDB instances 1, 4, and 7, while partition 1 resides on instances 2, 5, and 8. This mapping is stored in Veritas and can be dynamically updated by the leader to rebalance load or handle instance failures. The key advantage of this indirection is that partitions (logical divisions) remain fixed while their assignment to physical nodes can change, enabling seamless scaling and failover without data reshuffling. </p><h3>Quorum-Based Replication and Consistency</h3><p> To ensure data durability and availability even when individual nodes fail, NoReDB uses quorum-based replication. Each partition is replicated across multiple NoReDB instances (typically N=3 replicas). When writing data, the system requires confirmation from W replicas (e.g., W=3 for strong consistency), and when reading, it queries R replicas (e.g., R=2), returning the value with the latest timestamp. The quorum rulewhere W + R &gt; Nguarantees that reads always overlap with the most recent writes, ensuring consistency without requiring all replicas to be available simultaneously. </p><p> The controller implements this through parallel operations as shown in the code below. For writes, it generates a hybrid logical timestamp combining a global clock (synchronized via Veritas) and a local monotonic counter, ensuring total ordering of operations across the distributed system. For reads, it performs read-repair: if replicas disagree on a value, the controller detects this by comparing timestamps and writes the latest value back to outdated replicas, healing inconsistencies in the background. </p><h3>Leader Election and Partition Management</h3><p> The controller&#39;s leader election mechanism, visible in the <code>startLeaderElection</code> function, uses Veritas as a coordination service. Each controller instance attempts to become leader by atomically updating a shared variable in Veritas with its unique ID. The instance that successfully writes its ID becomes the leader and begins partition management duties. The leader continuously monitors the health of NoReDB instances through Veritas service registration timestamps, automatically removing instances that haven&#39;t sent heartbeats within a 5-minute window. When the cluster topology changesnodes joining, leaving, or failingthe leader recalculates partition assignments to maintain balance and replication guarantees. </p><p> The rebalancing logic, triggered every 10 seconds as shown in <code>startLeadershipDuties</code>, calculates the current partition distribution and checks for imbalance. If any NoReDB instance has 16 or more partitions than another, the leader initiates rebalancing by invoking <code>transferPartition</code>, which streams all key-value pairs for a partition from the old instance to the new one. This live migration happens transparently while the system continues serving requests, as the controller maintains both old and new mappings during the transfer and only updates the authoritative configuration in Veritas once migration completes. </p><h3>Code Deep Dive: Quorum Writes</h3><p> The <code>Set</code> method demonstrates the quorum write implementation. When a pixel update arrives, the controller first determines the partition ID using <code>getPartition(x, y)</code>, which applies modulo arithmetic to the hashed coordinates. It then retrieves the NoReDB clients responsible for that partition via <code>getClientsForPartition</code>, which looks up the partition-to-instance mapping from the in-memory configuration cache. The controller generates a hybrid logical timestamp by incrementing its local clock and capturing the current global clock value from Veritas: </p><pre><code>func (pc *PartitioningController) getCurrentTimestamp() Timestamp {
    return Timestamp{
        LocalClock:  pc.local_time.Add(1),  // Increment local clock
        GlobalClock: pc.global_time.Load(), // Use current global clock
    }
}</code></pre><p> This timestamp is attached to the pixel data and sent in parallel to all replica instances using goroutines. Each write operation runs asynchronously with a timeout, incrementing an atomic counter <code>completed_writes</code> upon success. A separate goroutine waits for either the write quorum (W=3) to be achieved or the context timeout to expire. If quorum is reached, the operation succeeds and the <code>doneChan</code> is closed to signal completion; otherwise, an error is sent to <code>errorChan</code>. This pattern allows the controller to return success as soon as the minimum required replicas acknowledge the write, without waiting for slower replicas, thus maintaining low latency while ensuring durability. </p><h3>Design Philosophy: Specialization vs. Separation of Concerns</h3><p> A fundamental tension in distributed systems design lies between two competing goals: optimizing for performance through specialization, or optimizing for maintainability and reusability through separation of concerns. This project deliberately chooses the latter approach, making it an educational case study in modular architecture rather than a production system squeezed for every millisecond of performance. Throughout the codebase, you&#39;ll find design decisions that prioritize clean abstractions and component independence over tightly optimized, application-specific solutions. </p><p> In production systems, especially at scale, specialization often wins. Companies like Facebook and Google build databases custom-tailored to specific workloadsa social graph database understands friend relationships natively, a time-series database optimizes for append-heavy temporal data, and a real-time collaboration database might embed application logic directly into the storage layer for minimal latency. These systems achieve incredible performance by sacrificing generality: they do one thing exceptionally well but are difficult to repurpose. The database and application become intertwined, sharing data structures, protocols, and assumptions that make them inseparable. </p><p> WebCanvas takes the opposite approach. Each componentASP.NET backends, Partitioning Controller, NoReDB, and Veritasoperates as an independent service with clear, well-defined interfaces. NoReDB doesn&#39;t &quot;know&quot; it&#39;s storing canvas pixels; it&#39;s a generic key-value store that could just as easily power a user profile service, a distributed cache, or a configuration management system. The Partitioning Controller doesn&#39;t have WebCanvas-specific logic; it&#39;s a general partitioning and quorum coordination layer. This modularity comes with costs: extra network hops for the global clock synchronization, separate timestamp management instead of piggybacking on existing messages, and additional serialization overhead at service boundaries. </p><h3>Concrete Example: Hybrid Clocks vs. Vector Clocks</h3><p> The timestamp mechanism illustrates this philosophy concretely. The system uses hybrid logical clocks (global + local) managed by the Partitioning Controller, rather than vector clocks embedded in cache invalidation messages between ASP.NET backend instances. In a specialized approach, each backend would maintain a version vector and include it with every cache invalidation message, allowing recipients to determine causal ordering without external coordination. This would eliminate the dependency on Veritas for global clock distribution, reduce latency by a few milliseconds, and cut the number of network requests per operation. </p><p> However, this optimization would create tight coupling between the cache layer and the database&#39;s consistency model. The ASP.NET backends would need to understand timestamps, versioning, and conflict resolutionconcerns that properly belong to the database layer. If you wanted to swap NoReDB for a different storage backend, or reuse the caching infrastructure with a different database that uses last-write-wins semantics instead of versioned values, you&#39;d need to refactor significant portions of the backend code. By centralizing timestamp generation in the Partitioning Controller, WebCanvas maintains a clean separation: the database provides timestamped storage, the controller manages coordination, and the backends simply forward operations and invalidate caches based on completion signalsthey never need to understand how consistency is achieved. </p><p> This separation enables independent evolution of each component. NoReDB can change its timestamp format, switch from hybrid clocks to true vector clocks, or even implement a completely different consistency model without touching the ASP.NET backend code. The Partitioning Controller could be replaced with a consistent hashing library or a different coordination service without modifying the database. Each service has a single responsibility and communicates through stable, minimal interfaces. From an educational perspective, this architecture teaches the value of abstraction boundaries and the tradeoffs inherent in distributed system design: you can have maximum performance or maximum flexibility, but rarely both simultaneously. </p><h3>Code Deep Dive: Quorum Reads with Repair</h3><p> The <code>Get</code> method implements quorum reads with built-in read-repair. Similar to writes, it maps coordinates to a partition and retrieves the responsible clients. It then issues parallel read requests to all replicas, with each spawned goroutine tracking successful responses in a shared <code>readValues</code> slice protected by a mutex. Once R=2 responses arrive, a goroutine analyzes the results using <code>getMostCurrentVersion</code>, which compares timestamps to identify the latest value. If all responding replicas agree, the value is immediately returned. However, if replicas have divergedindicating previous partial failuresthe controller triggers read-repair: </p><pre><code>// If not all clients have the latest value, perform read repair
for i, client := range clients {
    if clientRead[i] == 1 &amp;&amp; /* client has stale data */ {
        // Write latest value back to stale replica
        client.Set(ctx, x, y, latestValue.Color, timestamp)
    }
}</code></pre><p> This automatic healing mechanism ensures that temporary network partitions or instance crashes don&#39;t leave permanent inconsistencies in the system. By piggybacking repair on reads, the system converges toward consistency without requiring separate background processes or anti-entropy protocols, a design choice that reduces operational complexity while maintaining strong eventually-consistent semantics. </p><h3>Service Registration and Discovery</h3><p> As depicted in Figure 3, each Partitioning Controller instance registers itself with Veritas on startup through the <code>handleServiceRegistration</code> function in <code>main.go</code>. The registration includes the instance&#39;s hostname and Kubernetes-resolvable DNS address (<code>hostname.service-name.namespace.svc.cluster.local</code>), enabling dynamic service discovery. A background goroutine updates this registration every 10 seconds with a fresh timestamp, allowing other components to distinguish between active and failed instances. The leader uses this same mechanism to monitor NoReDB instance health, automatically removing stale registrations after 5 minutes to prevent routing requests to dead nodes. </p>`,27))]),C("section",sf,[i[31]||(i[31]=Ze("<h2>Veritas: Atomic Operations for Coordination</h2><p> Veritas is a Rust-based coordination service that provides linearizable atomic operations to enable distributed coordination across WebCanvas. Rather than implementing a full-featured consensus system like Raft or Paxos, Veritas focuses on a minimal set of atomic primitives<code>get</code>, <code>set</code>, <code>compare_set</code>, and <code>get_add</code>that higher-level components use to build coordination mechanisms. Running as a 5-node StatefulSet with leader-follower replication in Kubernetes, Veritas maintains a replicated key-value store (a simple in-memory map) and ensures that these operations execute atomically and in a totally ordered sequence, even in the presence of concurrent requests from multiple clients. Notably, these atomic operations are only available after Veritas has successfully elected a leaderthe leader election process itself uses a separate mechanism based on heartbeats and voting rather than relying on the atomic operations it provides. </p><p> Veritas&#39;s role in WebCanvas is specifically to provide coordination primitives for other components: the <strong>Partitioning Controller</strong> (written in Go) uses Veritas&#39;s <code>get_add</code> operation to obtain unique global clock values for timestamp generation and uses <code>compare_set</code> for its own leader election. The <strong>ASP.NET Backend</strong> instances register themselves with Veritas and query it for service discovery. The <strong>NoReDB cluster</strong> stores partition metadata and configuration in Veritas. Each component has distinct responsibilities: Veritas handles coordination primitives (leader-based), Partitioning Controller manages data distribution and routing (leader-based for coordination), ASP.NET Backend handles business logic and WebSocket connections, and NoReDB stores the actual canvas pixel data using a leaderless architecture for reads and writes. </p><p> Importantly, Veritas assumes all participants are well-behaved and operates within a trusted system boundary. It does not defend against Byzantine faults (malicious actors sending corrupt or contradictory messages), undefined behavior from buggy clients, or adversarial attacks. This simplification is appropriate for an educational project where all components are controlled and audited, allowing the implementation to focus on demonstrating core distributed systems principles without the complexity of Byzantine fault tolerance. In a production environment serving untrusted clients, additional validation, authentication, and Byzantine-resistant protocols would be necessary. </p>",4)),C("div",of,[ue(Mt,{src:Le(Vh),alt:"Veritas Components Diagram"},null,8,["src"]),i[28]||(i[28]=C("p",{class:"diagram-caption"},"Figure 4: Veritas architecture showing leader-follower replication and client interaction patterns",-1))]),i[32]||(i[32]=Ze("<h3>Leader-Based vs. Leaderless Systems</h3><p> Distributed systems face a fundamental design choice: use a leader-based architecture or distribute coordination across all nodes in a leaderless fashion. <strong>Leader-based systems</strong> (like Veritas and the Partitioning Controller) designate one node as the authoritative coordinator responsible for serializing operations, resolving conflicts, and maintaining global state. This simplifies reasoning about consistencyall writes flow through a single point that can enforce a total orderingbut creates a potential bottleneck and single point of failure. If the leader crashes, the system must pause operations and elect a new leader before resuming. </p><p><strong>Leaderless systems</strong> (like Dynamo, Cassandra, or Riak) distribute coordination across all nodes, allowing any node to accept writes without consulting a leader. This eliminates the bottleneck and provides better availability during network partitionseven if half the cluster is unreachable, the remaining nodes continue serving requests. However, leaderless systems sacrifice strong consistency: concurrent writes to different replicas create conflicts that must be resolved later through techniques like last-write-wins, vector clocks, or application-specific merge logic. Reads may return stale data or multiple conflicting versions that the application must reconcile. </p><p> WebCanvas intentionally demonstrates both approaches to illustrate their tradeoffs in a single system. <strong>Veritas</strong> uses a leader-based architecture for coordination primitives because operations like timestamp generation require strict total ordering and linearizabilityhaving a single leader serialize these operations is the simplest way to guarantee consistency. The <strong>Partitioning Controller</strong> also uses leader election to coordinate partition assignments and routing decisions, ensuring all controllers have a consistent view of which NoReDB instances own which data ranges. </p><p> However, the <strong>NoReDB cluster</strong> uses a <strong>leaderless architecture</strong> for actual data reads and writes. When a Partitioning Controller receives a pixel write request, it determines which partition owns that pixel and sends the write to multiple replicas in parallel without consulting a leader. Replicas independently accept writes and use timestamps to resolve conflicts. Read requests similarly contact multiple replicas in parallel, returning once a quorum responds. This leaderless design maximizes availabilityeven if some NoReDB instances are unreachable, the system continues serving requests as long as a quorum is availableand eliminates the bottleneck of a single leader processing all data operations. The tradeoff is that the Partitioning Controller must implement conflict resolution logic (using timestamps to determine the latest write) rather than relying on a leader to serialize operations. </p><p> This hybrid approach demonstrates a key distributed systems principle: different components can use different consistency models based on their requirements. Coordination primitives (Veritas, Partitioning Controller) benefit from leader-based strong consistency, while high-throughput data operations (NoReDB) benefit from leaderless availability and parallelism. By implementing both patterns, WebCanvas serves as an educational platform showing when to choose each approach and how they can coexist in a single system. </p><h3>Understanding ACID and Consistency Guarantees</h3><p> Before exploring how Veritas works, it&#39;s essential to understand the consistency guarantees distributed systems strive to provide. Traditional databases advertise <strong>ACID</strong> properties: <strong>Atomicity</strong> (operations complete fully or not at all), <strong>Consistency</strong> (data moves from one valid state to another), <strong>Isolation</strong> (concurrent transactions don&#39;t interfere), and <strong>Durability</strong> (committed data survives failures). While ACID provides strong guarantees for single-node databases, distributed systems face additional challenges: network delays, partial failures, and concurrent operations across nodes create scenarios where maintaining all ACID properties becomes prohibitively expensive or impossible. </p><p> Veritas provides <strong>linearizability</strong>, the strongest single-object consistency model. A system is linearizable if every operation appears to execute atomically at some point between its invocation and completion, and all operations can be ordered in a sequence that respects real-time causality. In simpler terms: if operation A completes before operation B begins (according to real wall-clock time), then the system state must reflect A&#39;s effects before B executes. This is stronger than eventual consistency (where replicas converge &quot;eventually&quot; but may temporarily diverge) and stronger than serializability (which allows reordering operations as long as the final result matches some serial execution, even if that order violates real-time causality). Linearizability is crucial for coordination primitives like leader election and global clocks because it prevents anomalies where, for example, two nodes both believe they are the leader simultaneously. </p><h3>Total Ordering vs. Partial Ordering</h3><p> Distributed systems must reason about the ordering of events across nodes that don&#39;t share a clock. A <strong>partial order</strong> captures causality: if event A causally precedes event B (e.g., A sends a message that B receives), we write A  B. However, events on different nodes with no causal relationship are <strong>concurrent</strong> and can&#39;t be orderedwe can&#39;t say whether A happened &quot;before&quot; or &quot;after&quot; B in any meaningful sense. Vector clocks extend this partial order by tracking causality explicitly, allowing any observer to determine if two events are causally related or concurrent. </p><p> A <strong>total order</strong> goes further by imposing a strict sequence on all events, including concurrent ones. Every pair of events has a defined ordering, even if they&#39;re causally unrelated. Veritas enforces total ordering by routing all writes through a single leader that assigns each operation a monotonically increasing sequence number. This sequence number creates a total order: operation with sequence 100 always precedes operation with sequence 101, regardless of which client issued them or when they were initiated. This total ordering is critical for WebCanvas&#39;s timestamp generationthe global clock obtained via <code>get_add</code> ensures no two writes across different Partitioning Controller instances can receive the same global timestamp, establishing a global happens-before relationship across the entire distributed system. </p><p> The hybrid timestamp scheme (global + local clock) creates a two-level total order. The global clock from Veritas ensures total ordering <em>across nodes</em>: writes from different controllers are totally ordered by their global timestamps. The local clock ensures total ordering <em>within a single node</em>: writes from the same controller are ordered by their local sequence. Together, these form a composite key (global, local) that totally orders all writes system-wide, enabling conflict-free convergence even when replicas temporarily diverge. </p><h3>Atomic Operations: The Building Blocks</h3><p> Veritas exposes four HTTP-based operations that higher-level components invoke. Figure 5 shows the sequence of operations for typical get/set interactions. The <code>get(key)</code> operation retrieves the current value for a key from the leader&#39;s key-value store, forwarding the request to the leader if invoked on a follower. The <code>set(key, value)</code> operation atomically updates a key-value pair, first persisting the value to the leader&#39;s key-value store, then replicating to a quorum of followers who each persist to their own key-value stores, and only then acknowledging success to the client. This ensures durabilitythe operation is not considered complete until multiple replicas have persisted the value. Both operations are linearizable: the leader serializes all operations by processing them sequentially and updating its in-memory map, and followers apply updates in the same order to maintain consistency. </p>",15)),C("div",rf,[ue(Mt,{src:Le(jh),alt:"Veritas Get/Set Sequence Diagram"},null,8,["src"]),i[29]||(i[29]=C("p",{class:"diagram-caption"},"Figure 5: Sequence diagram showing get/set operations with leader-follower replication",-1))]),i[33]||(i[33]=Ze(`<p> The <code>compare_set(key, expected, new_value)</code> operation is a compare-and-swap primitive: it atomically updates the value only if the current value matches <code>expected</code>, persisting the new value to the leader&#39;s key-value store and replicating to followers before returning true if successful, or returning false immediately if the comparison fails. This enables lock-free synchronizationthe Partitioning Controller (a separate component written in Go) uses compare_set for its own leader election: a controller attempts to atomically claim leadership by writing its ID to a well-known key, succeeding only if no other controller has claimed it first. The operation&#39;s atomicity ensures exactly one controller succeeds even if multiple attempt simultaneously. </p><p> Most critically for WebCanvas, <code>get_add(key)</code> atomically reads the integer value at <code>key</code>, increments it by 1, persists the new value to the leader&#39;s key-value store, replicates to followers (who also persist), and only then returns the old value. Each Partitioning Controller instance calls <code>get_add(&quot;global_clock&quot;)</code> to obtain a unique global timestamp. Because the operation is atomic and the leader serializes all <code>get_add</code> calls, no two invocations can return the same valuethe global clock is strictly monotonic across all controllers. As shown in the code below, the leader retrieves the current value from its key-value map, parses it as an integer, increments it, persists the new value, replicates to followers, and only after all persistence completes returns the old value: </p><pre><code>async fn get_add_for_leader(key: &amp;str, data: web::Data&lt;AppState&lt;F&gt;&gt;) -&gt; Result&lt;String, Error&gt; {
    // Ensure we have latest value from followers
    let current_value = Self::get_for_leader(key, data.clone()).await?;
    Self::set_if_newer(key, t_value, &amp;data.kv_store)?;

    // Read from key-value store (in-memory map)
    let mut transaction = data.kv_store.begin_transaction()?;
    let current_value = transaction.get(key).unwrap_or(&quot;0&quot;.to_string());
    
    let old_value = current_value.parse::&lt;i64&gt;().unwrap_or(0);
    let new_value = old_value + 1;
    
    // Persist to leader&#39;s key-value store
    transaction.set(key, &amp;new_value.to_string())?;
    transaction.commit()?;
    
    // Replicate to followers (they persist to their key-value stores)
    Self::replicate_to_followers(&amp;data, key, &amp;new_value.to_string()).await?;
    
    // Return only after persistence completes
    Ok(old_value.to_string())
}</code></pre><h3>Leader Election and Replication</h3><p> Veritas&#39;s leader election mechanism is separate from the atomic operations it providesin fact, the atomic operations require an elected leader to function. As illustrated in Figure 6, the election process uses health checks, candidate selection with loyalty preferences, voting, and result publishing. Each node continuously runs an election cycle (typically every few seconds) where it first checks which other nodes are reachable and healthy by sending heartbeat messages and awaiting responses. This health check establishes which nodes are currently available to participate in consensus. </p><p> After determining which nodes are reachable, each node independently selects its <strong>preferred candidate</strong> using a deterministic algorithm: among all reachable nodes, prefer the one with the lowest ID, which ensures all nodes typically agree on the same candidate. However, the algorithm includes a critical <strong>loyalty</strong> mechanismif the current leader from the previous election cycle is still reachable and healthy, the node remains loyal to it and continues supporting it as the preferred candidate. This loyalty prevents unnecessary leadership changes when the current leader is functioning properly, maintaining stability even when network conditions fluctuate. </p><p> Only nodes that believe <em>they themselves</em> are the preferred candidate initiate a vote requestother nodes remain passive. The candidate broadcasts a vote request to all nodes, and each node grants its vote <strong>only if</strong> the requesting candidate matches the preferred candidate it calculated independently. This ensures vote consistency: if all nodes see the same set of healthy nodes, they all calculate the same preferred candidate and all grant their votes to that single candidate. The candidate counts the votes it receives; if it collects votes from a majority (3 out of 5 nodes in WebCanvas&#39;s deployment), it has won the election. </p><p> When a candidate wins the election, the protocol distinguishes between two scenarios. If the candidate is already the current leader (re-elected in the current cycle), it immediately broadcasts the election result and continues processing operations. However, if there is a <strong>leadership change</strong>a new leader taking over from an old onethe new leader waits for one full election cycle period before assuming leadership duties, giving the old leader time to step down gracefully. After this cooldown, the new leader asks for votes again to confirm it still has majority support. Only after confirming the second vote does it officially assume leadership, update its internal state, and broadcast the election result to all nodes. Other nodes <strong>accept</strong> the published result (not necessarily agreeing with the decision, but acknowledging the leader&#39;s authority), updating their own internal leader ID accordingly. </p><p> Once a leader is established, it begins processing atomic operations (<code>get</code>, <code>set</code>, <code>compare_set</code>, <code>get_add</code>), serializing all client requests through its key-value store. Followers continue replicating updates from the leader, maintaining consistent copies of the key-value map. This two-phase safety mechanismhealth checks with loyalty, followed by a cooldown on leadership transitionsensures stable leadership while preventing split-brain scenarios where multiple nodes believe they are simultaneously the leader. </p>`,9)),C("div",af,[ue(Mt,{src:Le(Uh),alt:"Veritas Leader Election Sequence"},null,8,["src"]),i[30]||(i[30]=C("p",{class:"diagram-caption"},"Figure 6: Leader election sequence using compare_set for atomic leadership claim",-1))]),i[34]||(i[34]=Ze(`<p> The leader replicates every write to a quorum of followers (typically 3 out of 5 nodes), waiting for each follower to persist the value to its own key-value store, before acknowledging the client. This ensures durabilityeven if the leader immediately crashes after acknowledging a write, the new leader will have the committed value in its key-value store and can continue serving it. Followers apply updates in the order received from the leader, maintaining consistency. Read operations can be served by any node (reading from its local key-value map), but only the leader processes writes, ensuring the total ordering property critical for linearizability. </p><h3>Global Clock Generation</h3><p> The Partitioning Controller maintains a cached copy of the global clock value and periodically refreshes it by calling Veritas&#39;s <code>get_add</code> endpoint. When generating a timestamp for a write operation, the controller calls <code>getCurrentTimestamp()</code>, which increments its local monotonic counter and combines it with the current cached global clock: </p><pre><code>func (pc *PartitioningController) getCurrentTimestamp() Timestamp {
    return Timestamp{
        LocalClock:  pc.local_time.Add(1),  // Monotonic local sequence
        GlobalClock: pc.global_time.Load(), // Cached Veritas clock
    }
}

func (pc *PartitioningController) startUpdateGlobalTime(ctx context.Context) {
    ticker := time.NewTicker(MAX_CLOCK_TICK) // e.g., 100ms
    for {
        select {
        case &lt;-ticker.C:
            newGlobalTime := vClient.GetAdd(ctx, TIME_KEY) // Atomic get_add from Veritas
            pc.global_time.Store(newGlobalTime)
        case &lt;-ctx.Done():
            return
        }
    }
}</code></pre><p> This design minimizes the load on Veritascontrollers don&#39;t call <code>get_add</code> for every write, only every 100ms. The local clock handles high-frequency writes within a single controller instance, while the global clock (refreshed periodically from Veritas) ensures global ordering across controllers. The guarantee: if Controller A&#39;s global clock is 100 and Controller B&#39;s is 101, all writes from A with global=100 happened-before all writes from B with global=101, regardless of the local clock values. </p>`,5))]),C("section",lf,[i[37]||(i[37]=Ze("<h2>NoReDB Cluster: Architecture and Implementation</h2><p> NoReDB is a custom-built distributed key-value store written in Rust that serves as the persistent storage layer for WebCanvas. Each NoReDB instance is a high-performance database server capable of storing millions of pixel entries with microsecond read/write latency. The cluster operates in a leaderless, peer-to-peer architecture where each instance independently handles requests routed to it by the Partitioning Controller. This section provides an in-depth look at the internal architecture of a single NoReDB instance, examining the sophisticated storage engine that enables both durability and performance. </p><h3>Storage Architecture: Components and Design Rationale</h3><p> At its core, each NoReDB instance implements a <strong>Canvas Database (CanvasDB)</strong> that manages pixel data through three specialized components working in concert: a <strong>Write-Ahead Log (WAL)</strong>, a <strong>B-tree Index</strong>, and a <strong>Data Store</strong>. This architecture, inspired by modern database systems like RocksDB and PostgreSQL, separates concerns between fast sequential writes (WAL), efficient indexed lookups (B-tree), and persistent storage (Data Store). All three components are built on top of a unified abstraction layer called <strong>Persistent Random Access Memory (PRAM)</strong>, which provides memory-mapped file access with allocation management. </p>",4)),C("div",cf,[ue(Mt,{src:Le(zh),alt:"NoReDB Components Diagram"},null,8,["src"]),i[35]||(i[35]=C("p",{class:"diagram-caption"},"Figure 7: NoReDB instance internal architecture showing WAL, B-tree index, data store, and PRAM abstraction",-1))]),i[38]||(i[38]=Ze(`<p> The <strong>Write-Ahead Log (WAL)</strong> is a circular buffer that records all incoming pixel updates in append-only fashion. Its purpose is twofold: first, it provides crash recoveryif the instance fails before persisting data to the index and store, the WAL can be replayed on restart to restore the database to a consistent state. Second, it decouples write acknowledgment from expensive indexing operations. When a pixel update arrives, it&#39;s immediately appended to the WAL and flushed to disk in batches every 100ms, allowing the server to acknowledge the write quickly without blocking on tree updates or memory allocation. </p><pre><code>// Write-Ahead Log structure
pub struct WriteAheadLog&lt;T&gt; where T: Sized {
    pram: Arc&lt;PersistentRandomAccessMemory&gt;,
    size: usize,                      // Maximum number of entries
    length: Arc&lt;AtomicU64&gt;,          // Current number of entries
    head: Arc&lt;RwLock&lt;Pointer&lt;u64&gt;&gt;&gt;, // Write position
    tail: Arc&lt;RwLock&lt;Pointer&lt;u64&gt;&gt;&gt;, // Read position
    data: Arc&lt;Pointer&lt;T&gt;&gt;,           // Circular buffer data
}</code></pre><p> The <strong>B-tree Index</strong> provides O(log n) lookup time for pixel keys, maintaining a mapping from pixel key (a 32-bit hash of x,y coordinates) to memory address in the data store. The B-tree has an order of 255, chosen to fit within 4KB memory pages, minimizing page faults during tree traversals. Unlike traditional B-trees that store values inline, this index stores only 64-bit pointers to pixel entries in the data store, keeping the tree compact and cache-friendly. Insertions and updates occur asynchronously in background worker threads, processing batched entries from the WAL without blocking incoming writes. </p><pre><code>// B-tree node structure (order 255)
#[repr(C)]
struct BTreeNode {
    keys: [u64; 254],        // 254 keys per node
    values: [u64; 255],      // 255 pointers to data store
    length: usize,           // Number of keys in this node
    is_leaf: bool,           // True if leaf node
}

const BTREE_ORDER: usize = 255;  // Fits in 4KB page
const ROOT_NODE_ADDRESS: u64 = 0;</code></pre><p> The <strong>Data Store</strong> is a heap-managed memory region where actual pixel entries are stored. Each entry contains the pixel&#39;s key (derived from coordinates), RGB color, and a 16-byte timestamp for conflict resolution. The data store supports allocation (<code>malloc</code>) and deallocation (<code>free</code>) of variable-sized blocks, using a free-list allocator to manage fragmentation. When new pixels are inserted, space is allocated in the data store, and the pointer is recorded in the B-tree index. Updates to existing pixels are performed in-place by comparing timestamps and overwriting the entry if the new timestamp is newer. </p><pre><code>#[repr(C)]
pub struct PixelEntry {
    pub pixel: Pixel,           // Key (u32) + color ([u8; 3])
    pub timestamp: TimeStamp,   // 16-byte hybrid logical clock
}

impl CanvasDB {
    pub fn new(width: usize, height: usize, path: &amp;str, wal_size: usize) -&gt; Self {
        // WAL: wal_size * sizeof(PixelEntry) + 1024 bytes overhead
        let wal_pram = PersistentRandomAccessMemory::new(
            wal_size * std::mem::size_of::&lt;PixelEntry&gt;() + 1024,
            &amp;format!(&quot;{}.wal&quot;, path)
        );
        
        // B-tree: (width * height * 32 * 2) + 1024 bytes
        // *32 for each entry (8 bytes key + 8 bytes value + overhead)
        // *2 for internal nodes
        let btree_pram = PersistentRandomAccessMemory::new(
            (width * height * 32 * 2) + 1024,
            &amp;format!(&quot;{}.index&quot;, path)
        );
        
        // Data store: (width * height * sizeof(PixelEntry) * 2) + 1024 bytes
        // *2 for fragmentation and alignment
        let data_store = PersistentRandomAccessMemory::new(
            (width * height * std::mem::size_of::&lt;PixelEntry&gt;() * 2) + 1024,
            &amp;format!(&quot;{}.store&quot;, path)
        );
    }
}</code></pre><h3>Persistent Random Access Memory (PRAM): Unified Abstraction</h3><p> All three storage componentsWAL, B-tree, and Data Storeare built on top of <strong>PRAM (Persistent Random Access Memory)</strong>, a foundational abstraction that provides memory-mapped file I/O with allocation management. PRAM uses <code>mmap</code> to map files directly into the process&#39;s address space, allowing reads and writes to persistent storage via normal memory operations (pointer dereferences) rather than explicit I/O syscalls. This approach, called memory-mapped I/O, leverages the operating system&#39;s page cache and virtual memory system for efficient disk access. </p><p> The PRAM implementation provides three allocation primitives: <code>malloc</code> allocates a new block of memory using a free-list allocator, <code>free</code> returns a block to the free list, and <code>smalloc</code> (static allocation) claims a fixed address for metadata like the WAL&#39;s head/tail pointers. The abstraction exposes typed <code>Pointer&lt;T&gt;</code> objects that encapsulate both the memory address and a weak reference to the PRAM manager, preventing use-after-free bugs while allowing efficient pointer arithmetic and dereferencing. </p><pre><code>pub struct PersistentRandomAccessMemory {
    mmap: Arc&lt;RwLock&lt;MmapMut&gt;&gt;,      // Memory-mapped file
    free_list: Arc&lt;Mutex&lt;BTreeSet&lt;(usize, u64)&gt;&gt;&gt;, // Available blocks (size, address)
    allocated: Arc&lt;Mutex&lt;BTreeSet&lt;(u64, usize)&gt;&gt;&gt;, // Used blocks (address, size)
}

impl PersistentRandomAccessMemory {
    // Dynamic allocation using free-list
    pub fn malloc&lt;T&gt;(&amp;self, size: usize) -&gt; Result&lt;Pointer&lt;T&gt;, Error&gt; {
        let mut free_list = self.free_list.lock();
        // Find first block large enough (first-fit allocation)
        let block = free_list.range((size, 0)..).next().copied();
        // ... split block, update free list, return pointer
    }
    
    // Static allocation at fixed address for metadata
    pub fn smalloc&lt;T&gt;(&amp;self, address: u64, size: usize) -&gt; Result&lt;Pointer&lt;T&gt;, Error&gt; {
        // Mark specific address range as allocated
        // Used for WAL head/tail pointers, B-tree root, etc.
    }
}</code></pre><p> The <strong>Write-Ahead Log</strong> uses PRAM&#39;s <code>smalloc</code> to allocate fixed positions for its metadata: head and tail pointers are stored at offsets 0 and 8, with the circular buffer data starting at offset 16. On initialization, the WAL reads these pointers from disk (if they exist from a previous run) to determine where the log left off, enabling crash recovery. Appending to the WAL simply writes the entry to <code>data[head % size]</code> and increments the head pointer, with periodic <code>persist()</code> calls flushing the memory-mapped region to disk via <code>msync</code>. </p><pre><code>impl&lt;T&gt; WriteAheadLog&lt;T&gt; where T: Sized {
    pub fn new(pram: Arc&lt;PersistentRandomAccessMemory&gt;, size: usize) -&gt; Self {
        // Allocate head/tail pointers at fixed addresses
        let head: Pointer&lt;u64&gt; = pram.smalloc::&lt;u64&gt;(0, 8).unwrap();
        let tail: Pointer&lt;u64&gt; = pram.smalloc::&lt;u64&gt;(8, 8).unwrap();
        
        // Read existing values (for crash recovery)
        let head_val: u64 = head.deref().unwrap_or(0);
        let tail_val: u64 = tail.deref().unwrap_or(0);
        
        // Calculate current length
        let length = if head_val &gt;= tail_val {
            head_val - tail_val
        } else {
            size as u64 - tail_val + head_val
        };
        
        // Allocate circular buffer data region
        let data = pram.smalloc::&lt;T&gt;(16, size * std::mem::size_of::&lt;T&gt;()).unwrap();
        
        WriteAheadLog { pram, size, length, head, tail, data, ... }
    }
    
    pub fn append(&amp;self, entry: &amp;T) -&gt; Result&lt;(), Error&gt; {
        let head_lock = self.head.write();
        let head_val = self.head_cache.load(Ordering::Acquire);
        
        // Write to circular buffer
        let index = head_val % self.size as u64;
        self.data.at(index as usize).set(entry)?;
        
        // Update head pointer
        let new_head = head_val + 1;
        head_lock.set(&amp;new_head)?;
        self.head_cache.store(new_head, Ordering::Release);
        
        Ok(())
    }
}</code></pre><p> Similarly, the <strong>B-tree Index</strong> uses PRAM to allocate tree nodes on demand. When a node splits during insertion, the index calls <code>pram.malloc(sizeof(BTreeNode))</code> to allocate space for the new node, storing its address in the parent node&#39;s values array. Node pointers remain stable across restarts because PRAM preserves the memory-mapped file, allowing the tree structure to be recovered by simply loading the root node from address 0 and traversing the child pointers. The B-tree&#39;s <code>persist()</code> method calls <code>pram.persist()</code> to flush all dirty pages to disk, ensuring durability. </p><h3>Write Path: Asynchronous Persistence Pipeline</h3><p> Understanding NoReDB&#39;s write path reveals why it achieves both high throughput and durability. When a <code>set_pixel</code> request arrives via gRPC, the CanvasDB immediately appends the pixel entry to the WAL, a fast O(1) operation requiring only a pointer increment and memory write. The write is <em>not</em> immediately flushed to diskinstead, a background persistence thread wakes up every 100ms, calls <code>wal.commit()</code> to flush buffered entries via <code>msync</code>, and then invokes all registered listener callbacks to acknowledge the writes. This batching amortizes the cost of disk synchronization across many writes, achieving throughput of hundreds of thousands of operations per second. </p><pre><code>impl CanvasDBTrait for CanvasDB {
    fn set_pixel(&amp;self, pixel: PixelEntry, listener: Option&lt;Box&lt;dyn FnOnce() + Send&gt;&gt;) {
        // Step 1: Append to WAL (fast, in-memory)
        self.write_ahead_log.append(&amp;pixel).expect(&quot;WAL append failed&quot;);
        
        // Step 2: Register listener for acknowledgment after persistence
        if let Some(callback) = listener {
            let mut listeners = self.listeners.lock().unwrap();
            listeners.push(callback);
        }
        
        // Background threads handle steps 3-6 asynchronously
    }
}</code></pre><p> While the persistence thread handles WAL flushing, separate worker threads (typically 4-16 threads) continuously drain entries from the WAL and apply them to the B-tree and Data Store. The persistence coordinator thread runs this loop every 100ms: </p><pre><code>// Persistence coordinator thread (simplified)
loop {
    // Step 1: Peek entries from WAL without removing them
    let entries = wal.peek_many(PERSIST_BATCH_SIZE); // 8192 entries
    
    // Step 2: Send entries to worker threads for processing
    for entry in entries {
        tx_work.send(entry).unwrap();
    }
    
    // Step 3: Wait for all workers to finish processing
    for _ in 0..entries.len() {
        rx_res.recv().unwrap(); // Worker signals completion
    }
    
    // Step 4: Persist B-tree and data store to disk
    data_store.persist()?;
    btree_index.persist()?;
    
    // Step 5: Remove processed entries from WAL
    wal.pop_many(entries.len())?;
    
    // Step 6: Commit WAL (advance tail pointer)
    wal.commit()?;
}</code></pre><p> Each worker thread processes entries by first checking if the pixel key exists in the B-tree index. If found, the worker loads the pointer to the existing entry in the data store and performs an atomic compare-and-swap on the timestamp: if the new entry has a newer timestamp, it overwrites the old data; otherwise, it discards the update. If the key doesn&#39;t exist, the worker allocates space in the data store via <code>malloc</code>, inserts the pointer into the B-tree, and writes the pixel data. This ensures that out-of-order delivery (e.g., an old update arriving after a new one due to network delays) doesn&#39;t corrupt the database. </p><pre><code>// Worker thread processing (simplified)
let pixel = rx.recv().unwrap(); // Receive entry from coordinator

// Check if pixel exists in B-tree
let pointer_address = btree_index.get(pixel.pixel.key as u64);

if let Ok(addr) = pointer_address {
    // Update existing pixel
    let pointer = Pointer::&lt;PixelEntry&gt;::from_address(addr, data_store.clone());
    let entry = pointer.deref()?;
    
    // Compare timestamps and update if newer
    if pixel.timestamp &gt; entry.timestamp {
        pointer.set(&amp;pixel)?;
    }
} else {
    // Insert new pixel
    let new_pointer = data_store.malloc::&lt;PixelEntry&gt;(std::mem::size_of::&lt;PixelEntry&gt;())?;
    new_pointer.set(&amp;pixel)?;
    btree_index.set(pixel.pixel.key as u64, new_pointer.address)?;
}

tx_res.send(()).unwrap(); // Signal completion to coordinator</code></pre><p> This multi-stage pipeline achieves durability without sacrificing performance. The WAL acts as a buffer, absorbing write bursts and providing immediate acknowledgment to clients. The worker threads asynchronously apply updates to the indexed data structures, which are optimized for read performance. Only after both the B-tree and data store are successfully persisted does the coordinator remove entries from the WAL, ensuring that no committed write is lost even if the server crashes mid-process. </p><h3>Read Path: Multi-Layered Lookup with Timestamp Arbitration</h3><p> The read path demonstrates the importance of the WAL in maintaining consistency. When a <code>get_pixel</code> request arrives, CanvasDB must check <em>both</em> the WAL and the indexed data store, returning whichever entry has the newer timestamp. This is necessary because recent writes may still be in the WAL awaiting batch processing, not yet reflected in the B-tree/data store. The implementation first scans the WAL (in batches of 8192 entries to exploit sequential memory access), filtering for the requested pixel key and tracking the entry with the maximum timestamp. </p><pre><code>impl CanvasDBTrait for CanvasDB {
    fn get_pixel(&amp;self, key: u32) -&gt; Option&lt;(Pixel, TimeStamp)&gt; {
        // Step 1: Search WAL for most recent entry
        let most_current_wal = self.write_ahead_log
            .iter(GET_BATCH_SIZE) // 8192 entries per batch
            .flatten()
            .filter(|e| e.pixel.key == key)
            .max_by(|a, b| a.timestamp.cmp(&amp;b.timestamp));
        
        // Step 2: Lookup in B-tree index
        let pointer_address = self.btree_index.get(key as u64);
        
        if let Ok(addr) = pointer_address {
            let pointer = Pointer::&lt;PixelEntry&gt;::from_address(addr, self.data_store.clone());
            let entry = pointer.deref().ok()?;
            
            // Step 3: Compare timestamps and return newest
            if let Some(wal_entry) = most_current_wal {
                if wal_entry.timestamp &gt; entry.timestamp {
                    return Some((wal_entry.pixel, wal_entry.timestamp));
                }
            }
            return Some((entry.pixel, entry.timestamp));
        } else {
            // Not in index, return WAL entry if found
            most_current_wal.map(|e| (e.pixel, e.timestamp))
        }
    }
}</code></pre><p> This dual-lookup strategy ensures <strong>read-after-write consistency</strong>: a client that writes a pixel and immediately reads it back will always see the value it wrote, even if the write hasn&#39;t yet been indexed. The timestamp comparison handles race conditions where a worker thread is concurrently updating the indexed entrythe read path always returns the globally newest value. The tradeoff is that reads must scan the WAL, which adds latency proportional to the current WAL occupancy. To minimize this cost, the WAL is sized to hold only a few seconds of writes (typically 1024-2048 entries), and the batch processing keeps it drained rapidly. </p>`,25)),C("div",uf,[ue(Mt,{src:Le(Kh),alt:"NoReDB Read/Write Sequence Diagram"},null,8,["src"]),i[36]||(i[36]=C("p",{class:"diagram-caption"},"Figure 8: NoReDB read and write operation sequences showing WAL, B-tree index, and data store interactions",-1))]),i[39]||(i[39]=Ze(`<h3>Crash Recovery: Replaying the Write-Ahead Log</h3><p> When a NoReDB instance restarts after a crash, the initialization sequence checks the WAL for uncommitted entries by comparing the head and tail pointers read from PRAM. If the WAL contains entries (head != tail), the system enters recovery mode, replaying each entry by re-executing the worker thread logic: check the B-tree, compare timestamps, update or insert as needed. Because the WAL records operations with idempotent semantics (timestamp-based conflict resolution), replaying entries multiple times is safeapplying the same update twice produces the same result as applying it once. </p><p> This recovery mechanism guarantees that <strong>all acknowledged writes survive crashes</strong>. When the persistence thread calls <code>wal.commit()</code> and then invokes listener callbacks, clients receive acknowledgment only after the WAL has been fsynced to disk. Even if the instance crashes immediately after acknowledgmentbefore the B-tree and data store are persistedthe write is preserved in the WAL and will be replayed on restart. The WAL acts as a transactional log, similar to PostgreSQL&#39;s WAL or MySQL&#39;s redo log, providing atomicity and durability guarantees. </p><h3>Performance Characteristics and Benchmark Results</h3><p> To validate the design, comprehensive benchmarks were conducted using Criterion.rs, measuring throughput and latency across various workloads. The tests ran on a system with an NVMe SSD and 16 CPU cores, simulating realistic canvas operations. Three key benchmark suites were executed: <strong>CanvasDB</strong> (end-to-end pixel operations), <strong>B-tree Index</strong> (isolated tree performance), and <strong>PRAM</strong> (memory allocator overhead). </p><h4>CanvasDB Concurrent Writes</h4><p> The <code>canvasdb_set_concurrent</code> benchmark spawns 8 threads, each writing a disjoint subset of pixel keys to avoid contention. The system was tested with varying canvas sizes (32,768, 65,536, and 131,072 pixels), measuring total throughput: </p><pre><code class="benchmark-results">canvasdb_set_concurrent/32768    time: [186.02 ms  207.60 ms  225.47 ms]
                                      thrpt: [145.33 Kelem/s  157.84 Kelem/s  176.15 Kelem/s]

canvasdb_set_concurrent/65536     time: [226.81 ms  235.65 ms  242.24 ms]
                                      thrpt: [270.54 Kelem/s  278.10 Kelem/s  288.94 Kelem/s]

canvasdb_set_concurrent/131072    time: [240.08 ms  241.38 ms  242.64 ms]
                                      thrpt: [540.19 Kelem/s  543.02 Kelem/s  545.94 Kelem/s]</code></pre><p> These results demonstrate excellent scalability: with 131,072 writes, the system sustains <strong>543,000 writes per second</strong> (543 Kelem/s), translating to approximately 1.8 microseconds per write operation. The near-linear scaling from 32K to 131K elements indicates that the WAL circular buffer and batching strategy effectively amortize synchronization costs. The variance in throughput (10% between runs) stems from OS page cache behavior and background persistence threads competing for disk bandwidth. </p><h4>CanvasDB Concurrent Reads</h4><p> Read performance was measured by pre-populating the database with pixels and then issuing concurrent lookups across 8 threads: </p><pre><code class="benchmark-results">canvasdb_get_concurrent/32768     time: [198.81 ms  208.99 ms  218.58 ms]
                                       thrpt: [149.91 Kelem/s  156.79 Kelem/s  164.82 Kelem/s]

canvasdb_get_concurrent/65536      time: [219.68 ms  233.84 ms  246.69 ms]
                                       thrpt: [265.66 Kelem/s  280.27 Kelem/s  298.32 Kelem/s]

canvasdb_get_concurrent/131072     time: [233.88 ms  244.72 ms  256.32 ms]
                                       thrpt: [511.37 Kelem/s  535.59 Kelem/s  560.43 Kelem/s]</code></pre><p> Read throughput reaches <strong>535,000 reads per second</strong> for the 131K dataset, slightly slower than writes due to the dual-lookup overhead (WAL scan + B-tree traversal). The O(log n) B-tree complexity is evident in the modest increase in latency as dataset size grows: reads scale from 157 Kelem/s (32K) to 535 Kelem/s (131K), roughly 3.4 throughput improvement for 4 data size. This sub-linear scaling confirms that tree depth increases logarithmically, with the 131K dataset requiring one additional tree level compared to 32K. </p><h4>CanvasDB Iterator Performance</h4><p> The <code>canvasdb_iterate_pixels</code> benchmark measures full dataset scans, which traverse the B-tree in sorted order and dereference each pointer to load pixel data from the data store: </p><pre><code class="benchmark-results">canvasdb_iterate_pixels/65536     time: [155.91 ms  170.50 ms  185.22 ms]
                                       thrpt: [353.84 Kelem/s  384.37 Kelem/s  420.34 Kelem/s]

canvasdb_iterate_pixels/131072     time: [189.61 ms  200.75 ms  209.44 ms]
                                       thrpt: [625.82 Kelem/s  652.91 Kelem/s  691.27 Kelem/s]

canvasdb_iterate_pixels/262144     time: [209.81 ms  216.04 ms  221.68 ms]
                                       thrpt: [1.1825 Melem/s  1.2134 Melem/s  1.2494 Melem/s]</code></pre><p> Sequential iteration achieves <strong>1.2 million elements per second</strong> (262K dataset), significantly faster than random access due to spatial locality. Traversing the B-tree in order results in mostly sequential memory access patterns, benefiting from CPU cache prefetching and reduced TLB misses. This performance is critical for bulk operations like snapshotting the canvas or migrating partitions during rebalancing. </p><h2>Project Reflections: Successes and Challenges</h2><p> Building WebCanvas was an ambitious undertaking that pushed the boundaries of what could be accomplished within the project timeline. Looking back, the journey revealed both successes and areas where initial assumptions proved overly optimistic. </p><h4>Scope and Learning Curve</h4><p> The project scope was significantly underestimated at the outset. Building three distributed systems components from scratchVeritas (consensus), NoReDB (database), and the Partitioning Controllerwhile learning <strong>two entirely new programming languages</strong> (Rust and Go, or arguably three if Kubernetes YAML is counted) proved far more time-consuming than anticipated. Both Rust and Go were completely new technologies, requiring simultaneous learning of language syntax, idioms, concurrency models, and ecosystem tooling while architecting distributed systems. Despite this challenge, the agile project management approach allowed for continuous adaptation, prioritizing core functionality and deferring non-essential features when timelines became tight. </p><h4>Technical Evolution and Discovery</h4><p> A significant amount of effort was initially invested in building a <strong>custom memory management system</strong> for persistent storage, complete with manual caching, paging algorithms, and file block management. Only after substantial implementation work did the realization occur that <strong>memory-mapped files</strong> (<code>mmap</code>) provided exactly this functionality at the OS level, rendering the custom solution obsolete. The decision to pivot to memory-mapped I/O, while costly in terms of discarded code, ultimately improved both performance and reliability by leveraging battle-tested kernel implementations rather than reinventing them. </p><h4>LLM-Assisted Development: Effectiveness and Limitations</h4><p> Large Language Models (Claude, ChatGPT, Gemini) proved invaluable for certain tasks but fell short in others. They excelled at generating <strong>documentation, boilerplate code, and frontend Vue.js components</strong>, significantly accelerating development in these areas. However, they struggled dramatically with the <strong>core Rust database implementation and Go partitioning logic</strong>. LLM-generated Rust code frequently exhibited anti-patterns like collecting entire iterators into memory before filtering (materializing the entire B-tree index), incorrect lifetime annotations, and unsafe pointer usage that violated Rust&#39;s guarantees. The generated Go code similarly showed poor understanding of context propagation, goroutine lifecycle management, and channel patterns. These components ultimately required manual authorship from first principles, with LLMs relegated to syntax lookup rather than code generation. </p><h4>Veritas Complexity: Custom Protocol Challenges</h4><p> The <strong>Veritas consensus implementation</strong> was substantially more complex than initially estimated. Designing a custom leader election protocol with loyalty mechanisms, handling split-brain scenarios, and ensuring linearizable atomic operations required deep understanding of distributed systems theory. The decision to build a custom protocol rather than adopting Raft or Paxos was driven by educational curiosity, but the complexity cost was high. Debugging timing-dependent race conditions in leader transitions and vote counting consumed significant development time, though the learning experience was invaluable. </p><h4>Testing Philosophy and Infrastructure</h4><p> Testing strategy varied significantly across components. The <strong>stateful backend components</strong> (NoReDB and Veritas) received extensive unit and integration testing, particularly at the PRAM, WAL, and B-tree levels. However, abstracting implementation details for testability in Rust proved extremely difficultcreating mock <code>PersistentRandomAccessMemory</code> instances or simulating network partitions for Veritas leader election required fighting Rust&#39;s ownership system and trait bounds. The tests that were written provided high confidence in correctness, but achieving comprehensive coverage would have required an architectural redesign prioritizing testability from the start. </p><p> In contrast, the <strong>stateless backend</strong> (ASP.NET SignalR services) and <strong>frontend</strong> received minimal automated testing. The frontend logic was simple enoughprimarily UI state management and WebSocket event handlingthat manual testing sufficed. The backend&#39;s complexity lay in coordination rather than algorithmic logic, making integration tests against the full cluster more valuable than isolated unit tests. Time constraints necessitated prioritizing functional testing over achieving high test coverage metrics. </p><h4>Rust: Pain and Payoff</h4><p> Working with Rust was a love-hate relationship. The language&#39;s <strong>type system and explicit error handling</strong> forced thinking through both success and failure paths at every stepno <code>null</code> pointer exceptions, no unchecked errors, explicit <code>panic!</code> for truly unrecoverable situations. This rigor caught countless bugs at compile time that would have been runtime crashes in C++ or Go. The borrow checker, while frustrating during development, prevented entire classes of concurrency bugs and memory leaks that would have been nightmares to debug in a distributed system. </p><p> However, Rust&#39;s learning curve was steep. Fighting the compiler to express patterns that were trivial in garbage-collected languagessuch as self-referential data structures or dynamic dispatch with shared ownershipconsumed hours that could have been spent on features. With the benefit of hindsight and the experience gained, <strong>many Rust components would be rewritten differently</strong> if starting over: more liberal use of <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> for simplicity rather than complex lifetime annotations, trait-based dependency injection for testability, and clearer separation between hot-path performance code and cold-path configuration logic. </p><h4>Would Do It Again</h4><p> Despite the challenges, undertaking this project was absolutely worthwhile. The hands-on experience of building distributed systems components from scratchwrestling with consensus algorithms, crash recovery, concurrent data structures, and network partition handlingprovided insights that no amount of reading could replicate. Pairing this practical work with <em>Designing Data-Intensive Applications</em> by Martin Kleppmann created a powerful learning loop: the book explained the theory and tradeoffs, the project revealed why those tradeoffs matter in practice. The knowledge gained about distributed systems, Rust, Go, and Kubernetes far exceeded the project&#39;s initial educational goals, making the significant time investment worthwhile. </p><h3>Future Improvements and Production Considerations</h3><p> WebCanvas was designed as an <strong>educational reference implementation</strong> prioritizing clarity and modularity over maximum performance. While the system successfully handles hundreds of thousands of operations per second, transitioning to a production deployment would require several architectural and feature enhancements: </p><h4>Performance Optimizations</h4><ul><li><strong>Backend Image Caching and Delta Streaming:</strong> Currently, the ASP.NET backend forwards every pixel update individually over SignalR. A production system would maintain a <strong>server-side cached render of the full canvas image</strong>, serving initial page loads with the complete image, then streaming only incremental changes (deltas) over the WebSocket connection. This would reduce bandwidth consumption by 10-100 for clients joining an active canvas and eliminate the thundering herd problem when many users connect simultaneously.</li><li><strong>Vector Clocks for Cache Invalidation:</strong> The current system uses hybrid logical clocks (global + local) managed by the Partitioning Controller, requiring periodic <code>get_add</code> calls to Veritas. An alternative would be <strong>vector clocks determined by the ASP.NET backend instances</strong> themselves, piggybacking version vectors on the cache invalidation messages already being broadcast between backend pods. <em>Advantages:</em> Eliminates Veritas dependency for timestamp generation, reduces latency by one network round-trip per write. <em>Disadvantages:</em> Violates separation of concerns by coupling cache invalidation logic to database consistency model, makes backend stateful (must maintain vector clock state), increases implementation complexity. This exemplifies the performance-vs-modularity tradeoff discussed throughout the architecture.</li><li><strong>Specialized Pixel Storage:</strong> The current NoReDB uses a general-purpose B-tree index mapping arbitrary keys to memory addresses. For a canvas with known dimensions (e.g., 38402160), pixels could be stored in a <strong>simple indexed array</strong>: pixel 1 at offset 0, pixel 2 at offset 8, pixel 3 at offset 16, and so forth. This would eliminate the B-tree entirely, replacing $O(\\log n)$ lookups with $O(1)$ array indexing. <em>Advantages:</em> 5-10 faster reads/writes, simpler codebase, reduced memory overhead. <em>Disadvantages:</em> Loses generalitycannot handle sparse canvases with few set pixels, fixed canvas size at compile time, WAL still needed for durability so only partial simplification. This specialization-vs-generality tradeoff is central to production database design.</li><li><strong>Lock-Free Data Structures:</strong> The B-tree uses read-write locks (<code>RwLock</code>) for concurrency control. Implementing lock-free structures using atomic operations (e.g., Bw-tree, skip lists) could eliminate contention on hot paths, improving scalability on high core-count systems. However, lock-free algorithms are notoriously difficult to implement correctly and debug, requiring expert-level understanding of memory ordering and ABA problems.</li><li><strong>Write Combining and Batching:</strong> Currently, each pixel update generates a separate WAL entry. Batching multiple updates into a single entry would reduce metadata overhead and improve cache locality. The Partitioning Controller could accumulate writes for 10-100ms before flushing to NoReDB, trading slight latency for higher throughput.</li></ul><h4>Feature Enhancements</h4><ul><li><strong>User Authentication and Authorization:</strong> Production deployment requires <strong>user accounts</strong> with authentication (OAuth2, JWT tokens), per-user rate limiting to prevent abuse (e.g., max 10 pixels per second), and optional access control (public vs. private canvases, moderator roles).</li><li><strong>Multiple Canvases and Persistence:</strong> The current system supports a single global canvas. Scaling to thousands of independent canvases requires routing logic (hash canvas ID to partition), per-canvas access control, and lifecycle management (archive inactive canvases to cold storage after N days).</li><li><strong>Canvas History and Rollback:</strong> Store not just current state but full history of changes, enabling time-travel queries (&quot;show me the canvas as it looked 1 hour ago&quot;) and rollback functionality for moderation.</li><li><strong>Draw Tools Beyond Pixels:</strong> Lines, rectangles, fill tools, erasers, undo/redo, layersall require moving beyond single-pixel operations to higher-level drawing primitives with transaction semantics.</li></ul><h4>Infrastructure and Operations</h4><ul><li><strong>Established Coordination Service:</strong> Replace Veritas with <strong>etcd, Consul, or ZooKeeper</strong>. While building a custom consensus protocol was educationally valuable, production systems should use battle-tested implementations with years of bug fixes and operational tooling. The custom protocol lacks monitoring, debugging tools, and the expertise of a large community.</li><li><strong>Standard Protocols:</strong> The current system uses custom gRPC message formats and coordination protocols designed for learning purposes. Production deployment should adopt <strong>established protocols</strong> where possible: Raft for consensus, Prometheus for metrics, OpenTelemetry for distributed tracing. Custom protocols incur ongoing maintenance burden and make it difficult for new team members to understand the system.</li><li><strong>Observability and Debugging:</strong> Add comprehensive metrics (latency percentiles, throughput, error rates), distributed tracing to follow requests across services, structured logging with correlation IDs, and health check endpoints for each component. The current system has basic logging but lacks production-grade observability.</li><li><strong>Improved Testing Infrastructure:</strong> Addressing the Rust testability challenges would require <strong>better abstractions</strong>: trait-based dependency injection for PRAM, B-tree, and WAL to allow mock implementations; async test harnesses for simulating network partitions and clock skew; property-based testing (e.g., with <code>proptest</code>) to verify invariants under random operation sequences. The difficulty of testing the current implementation suggests it was not designed with testing as a first-class concern.</li></ul><p> These improvements collectively represent the gap between an educational prototype and a production system. The current implementation successfully demonstrates distributed systems principles and validates the core architecture, achieving performance sufficient for the WebCanvas use case. However, the modularity and clarity that make it valuable for learning would need to be balanced with specialization and optimization for production deployment. This tensionbetween understandable general-purpose code and high-performance specialized systemsis a fundamental tradeoff in software engineering, and one that this project illuminated through direct experience. </p>`,44))])]))}}),hf=sd({history:Bu("/"),routes:[{path:"/",name:"canvas",component:uh},{path:"/about",name:"about",component:df}]}),Ta=Yc(ld);Ta.use(hf);Ta.mount("#app");
