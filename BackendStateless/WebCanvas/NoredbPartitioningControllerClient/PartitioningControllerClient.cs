// Generated by Claude Sonnet based on user discription and related information.
// Adapted and improved by Steininger.

using Grpc.Core;
using Grpc.Net.Client;
using Partitioningcontroller;
using System.Runtime.CompilerServices;

namespace NoredbPartitioningControllerClient;

public interface IPartitioningControllerClient : IDisposable
{
    Task<Commit> SetAsync(uint key, byte[] value, CancellationToken cancellationToken = default);
    Task<DataResponse> GetAsync(uint key, CancellationToken cancellationToken = default);
    IAsyncEnumerable<DataResponse> GetAllAsync(CancellationToken cancellationToken = default);
}

public class PartitioningControllerClient : IPartitioningControllerClient
{
    private const string SERVICE_ADDRESS = "http://partitioning-controller.default.svc.cluster.local:50051";
    
    private readonly GrpcChannel _channel;
    private readonly Database.DatabaseClient _client;
    private readonly Action<string>? _logError;
    private readonly Action<string>? _logInfo;

    public PartitioningControllerClient(
        string? serviceAddress = null, 
        Action<string>? logError = null,
        Action<string>? logInfo = null)
    {
        _logError = logError;
        _logInfo = logInfo;
        var address = serviceAddress ?? SERVICE_ADDRESS;
        
        _logInfo?.Invoke($"Creating PartitioningControllerClient for {address}");
        
        _channel = GrpcChannel.ForAddress(address, new GrpcChannelOptions
        {
            // Allow the channel to handle transient failures
            ThrowOperationCanceledOnCancellation = true,
        });
        
        _client = new Database.DatabaseClient(_channel);
    }

    private async Task<TResponse> ExecuteWithRetryAsync<TResponse>(
        Func<Database.DatabaseClient, CancellationToken, Task<TResponse>> operation,
        CancellationToken cancellationToken)
    {
        const int maxRetries = 3;

        for (int attempt = 0; attempt < maxRetries; attempt++)
        {
            try
            {
                return await operation(_client, cancellationToken);
            }
            catch (RpcException ex) when (ex.StatusCode == StatusCode.Unavailable || 
                                          ex.StatusCode == StatusCode.DeadlineExceeded ||
                                          ex.StatusCode == StatusCode.Internal)
            {
                _logError?.Invoke($"Request failed (attempt {attempt + 1}/{maxRetries}): {ex.Message}");

                if (attempt == maxRetries - 1)
                {
                    throw;
                }

                // Exponential backoff
                await Task.Delay(TimeSpan.FromMilliseconds(100 * Math.Pow(2, attempt)), cancellationToken);
            }
        }

        throw new InvalidOperationException("Failed to execute operation after retries");
    }

    public async Task<Commit> SetAsync(uint key, byte[] value, CancellationToken cancellationToken = default)
    {
        var request = new Data
        {
            Key = key,
            Value = Google.Protobuf.ByteString.CopyFrom(value)
        };

        return await ExecuteWithRetryAsync(
            async (client, ct) => await client.SetAsync(request, cancellationToken: ct),
            cancellationToken);
    }

    public async Task<DataResponse> GetAsync(uint key, CancellationToken cancellationToken = default)
    {
        var request = new DataRequest
        {
            Key = key
        };

        return await ExecuteWithRetryAsync(
            async (client, ct) => await client.GetAsync(request, cancellationToken: ct),
            cancellationToken);
    }

    public async IAsyncEnumerable<DataResponse> GetAllAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        var request = new StreamRequest();
        AsyncServerStreamingCall<DataResponse>? call = null;
        
        call = _client.GetAll(request, cancellationToken: cancellationToken);

        await foreach (var response in call.ResponseStream.ReadAllAsync(cancellationToken))
        {
            yield return response;
        }

        call?.Dispose();
    }

    public void Dispose()
    {
        _channel?.Dispose();
    }
}

